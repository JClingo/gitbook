<?xml version="1.0" encoding="UTF-8"?>
<part id="DDGPresentationLayer"> 
	 <partinfo> 
		  <date role="LastMod">Thursday, October 26, 2006 7:16:44 PM</date> 
	 </partinfo> 
	 <title>Presentation Layer</title> 
	 <partintro> 
		  <para>This part of the Dataphor Developer's Guide focuses on the
				presentation layer of Dataphor applications. It discusses presentation layer
				architecture and features, as well as techniques for achieving re-use through
				the application of metadata tags.</para> 
		  <para>The discussions contained in this part assume a basic familiarity
				with the conceptual model of application development presented in the
				introductory part of this guide. In addition, the material covered in the
				Logical Application Design part of the guide will be referenced
				extensively.</para> 
		  <para>This part of the guide is organized as follows: 
				<itemizedlist> 
					 <listitem> 
						  <para><citetitle>Overview</citetitle></para> 
						  <para>This chapter describes how Dataphor applications work
								from the Frontend perspective. It covers the various components of the
								architecture that enable the automated application development achieved by the
								platform, and covers the preliminaries necessary to begin building the
								presentation layer of a Dataphor application.</para> 
					 </listitem> 
					 <listitem> 
						  <para><citetitle>Putting It All Together</citetitle></para>
						  
						  <para>This chapter builds the presentation layer of the
								Shipping application from start to finish, providing an in-depth example of
								using the Dataphor platform to build a real-world application.</para> 
					 </listitem> 
					 <listitem> 
						  <para><citetitle>The Automation of Forms</citetitle></para>
						  
						  <para>This chapter discusses the process of user-interface
								derivation in detail, including how it can be controlled using metadata
								tags.</para> 
					 </listitem> 
					 <listitem> 
						  <para><citetitle>The Space Between the
									 Data</citetitle></para> 
						  <para>This chapter discusses three important features of
								the Dataphor platform: Navigational Access, Application Transactions, and
								Proposable Interfaces.</para> 
					 </listitem> 
				</itemizedlist></para> 
		  <para><indexterm> 
					 <primary>Automated Application Development (AAD)</primary> 
				</indexterm><indexterm> 
					 <primary>AAD (Automated Application Development)</primary> 
				</indexterm>The aim of each of these chapters is to provide the
				developer with an overall understanding of how the architecture enables
				Automated Application Development (AAD). This understanding will in turn help
				the developer take advantage of the features available in the platform, and
				produce more efficient, more maintainable applications.</para> 
		  <para>The running example introduced in the Logical Application Design
				part of this guide will again be used as a vehicle for explaining the concepts
				and techniques discussed in this part.</para> 
	 </partintro> 
	 <chapter id="DDGOverview"> 
		  <title>Overview</title> 
		  <para>From the external, or user's, perspective, a Dataphor application
				consists of a set of user-interfaces that display information and accept input.
				The presentation layer of the Dataphor platform contains the architecture and
				services that provide these user-interfaces. It is comprised of several layers
				of technology that enable successively higher levels of user-interface
				automation, raising the level of abstraction at which user-interfaces can be
				described and executed. This chapter introduces each of these layers in terms
				of the overall architecture of the Dataphor Frontend.</para> 
		  <para>Architecturally, the Frontend is divided into two main
				categories: the Frontend Server, and the Frontend Clients. The Frontend Server
				provides the services required by the presentation layer such as user-interface
				derivation and document retrieval. The Frontend Clients then use these services
				to produce the presentation layer of a Dataphor application.</para> 
		  <para>The Data Access Layer provides the bridge between the Dataphor
				Server and the Frontend Clients. The services of the Frontend Server are
				accessed through this layer using a set of components called the Data Access
				Components (DAC).</para> 
		  <para>The Forms Layer consists of the components and controls that make
				up the user-interfaces in a Dataphor application. These forms are defined as
				documents and stored within the libraries of the application. Effectively, the
				Forms layer enables a client-independent Rapid Application Development (RAD)
				paradigm that can be used to build forms either manually using a traditional
				forms designer, or dynamically by invoking the user-interface derivation
				services of the Frontend Server.</para> 
		  <para>Lastly, the Frontend Clients bring all the capabilities and
				services of the Frontend Server, Data Access, and Forms Layers together to
				present the end-user with the actual application. Each Frontend Client is
				responsible for displaying the application in a different platform such as
				Microsoft Windows, or over the World-Wide Web.</para> 
		  <para>The following sections will introduce each of these layers, and
				discuss the preliminaries necessary to begin building the presentation layer of
				the Shipping application.</para> 
		  <sect1> 
				<title>Frontend Server</title> 
				<para>The Frontend Server is actually a library within the Dataphor
					 Server called 
					 <phrase role="code">Frontend</phrase>. This library extends the
					 concept of a library within the Dataphor Server to include
					 <emphasis>documents</emphasis>, and introduces several operators for producing
					 user-interface descriptions called <emphasis>forms</emphasis> based on the
					 application schema.</para> 
				<sect2> 
					 <title>Documents</title> 
					 <para>Documents are the logical equivalent of
						  <emphasis>files</emphasis> in a traditional development environment. They are
						  used to house the various products of the development process including
						  database creation scripts, and form definitions. They are centrally located
						  within the libraries that comprise the application.</para> 
					 <para>Dataphor Form Documents (DFDs) provide the mechanism for
						  persistence of a statically defined Dataphor form. These documents are saved
						  within the libraries of an application, and can be loaded through the pipe
						  available on the session, or directly from the CLI using the 
						  <phrase role="code">Frontend.Form</phrase> operator.</para>
					 
					 <para>Note that the 
						  <phrase role="code">Frontend.Form</phrase> operator does
						  not interpret the form definition, it simply returns the form definition as a
						  string value. The Frontend Session's pipe services are used to translate the
						  resulting form definition into an appropriate presentation layer representation
						  of the form. This process is known as
						  <emphasis>deserialization</emphasis>.</para> 
					 <para>During the process of deserialization, as component types
						  are encountered, the system must be able to determine what class of component
						  to create. This decision is made based on the 
						  <phrase role="code">NodeTypes</phrase> table loaded by the
						  Frontend Session. This table is loaded by aggregating the component type
						  definition documents (DNT) for the appropriate client from each library in the
						  application, tracing library dependencies recursively. Each entry in this
						  component types table specifies a .NET Framework type to be used whenever a
						  given component is to be created. Although this type is not required to be
						  client-specific, it can be.</para> 
					 <para>For example, the 
						  <phrase role="code">Source</phrase> entry specifies that
						  the 
						  <phrase role="code">Frontend.Client.Source</phrase> .NET
						  type be used to represent 
						  <phrase role="code">Source</phrase> components. This entry
						  is made for both the Windows and Web clients. However, the 
						  <phrase role="code">TextBox</phrase> entry specifies a
						  completely different class for the Windows client than for the Web. This is
						  because in the Windows client, the 
						  <phrase role="code">TextBox</phrase> corresponds with a
						  Windows edit control, while in the Web client, a control rendering an 
						  <phrase role="code">&lt;INPUT&gt;</phrase> tag is
						  used.</para> 
				</sect2> 
				<sect2> 
					 <title>Derivation</title> 
					 <para>One of the primary goals of the Dataphor platform is to
						  provide applications with as much insulation as possible from structural
						  changes in the database. In order to achieve this goal the application must be,
						  as much as possible, defined by the structure of the database. The Frontend
						  library provides the process of <emphasis>derivation</emphasis> to enable
						  this.</para> 
					 <para>Internally, the process of user-interface derivation is
						  divided into two main steps: <emphasis>elaboration</emphasis>, and
						  <emphasis>derivation</emphasis>. Elaboration consists of constructing an
						  extended query based on a given query expression, and the relationship between
						  the given expression and other table variables in the database. Derivation is
						  in turn divided into three main steps: <emphasis>structuring</emphasis>,
						  <emphasis>layout</emphasis>, and <emphasis>production</emphasis>.</para> 
					 <para>Structuring in derivation is the process of constructing
						  user-interface controls for each column in the query, and grouping those
						  controls as appropriate for the context of each column. Layout consists of
						  determining the visual layout of the controls and groups constructed during the
						  structuring process. And finally, production consists of actually building the
						  form definition based on the controls and visual layout determined by the
						  previous steps.</para> 
					 <para>The input to the derivation process is called the
						  derivation <emphasis>seed</emphasis>, and consists of the expression for which
						  a user-interface is to be derived, the form type, or type of user-interface, an
						  optional set of master and detail key names, and an indicator to determine
						  whether or not elaboration should be performed.</para> 
					 <para>During the derivation process, the engine uses metadata
						  tags associated with the various structural definitions produced by the
						  compiler. For example, when determining the title for a particular derived
						  user-interface, the derivation engine searches for the 
						  <phrase role="code">Frontend.Title</phrase> tag on the
						  result set definition. If found, the value of this tag is used as the title,
						  otherwise, the unqualified name of the table, or the expression itself is used
						  as the title.</para> 
					 <sect3> 
						  <title><indexterm> 
									 <primary>Derivation</primary> 
									 <secondary>Overview</secondary> 
								</indexterm><indexterm> 
									 <primary>Form Types</primary> 
									 <secondary>Derivation And</secondary> 
								</indexterm><indexterm> 
									 <primary>Singular User-Interfaces</primary> 
								</indexterm><indexterm> 
									 <primary>Plural User-Interfaces</primary> 
								</indexterm>Queries as User-Interface</title> 
						  <para>Because of the high degree of logical data
								independence afforded by the D4 language and the Dataphor query processor, the
								results of any table-valued expression can be completely described, both in
								terms of the structure of the table variable itself, as well as the
								relationship of that table variable with the rest of the database.</para> 
						  <para>The derivation engine uses the concept of
								<emphasis>form types</emphasis> to differentiate between the various types of
								user-interfaces that can be derived. Generally, these form types break down
								into two different categories: <emphasis>plural</emphasis> user-interfaces, and
								<emphasis>singular</emphasis> user-interfaces.</para> 
						  <para>Plural user-interfaces are used primarily to expose
								searching and navigation capabilities, and are capable of displaying the result
								set for a particular table or expression. Singular user-interfaces display only
								a single row at any given time, and are used for adding, editing, or viewing
								the information for a given entity.</para> 
						  <para>The following table details the form types exposed by
								the derivation engine: 
								<informaltable> 
									 <tgroup cols="3">
										  <colspec colname="col1" colnum="1" colwidth="*"/>
										  <colspec colname="col2" colnum="2" colwidth="*"/>
										  <colspec colname="col3" colnum="3" colwidth="*"/> 
										  <thead> 
												<row> 
													 <entry colname="col1">Form Type</entry>
													 
													 <entry
													 colname="col2">Cardinality</entry> 
													 <entry colname="col3">Produces a
														  User-Interface for</entry> 
												</row> 
										  </thead> 
										  <tbody> 
												<row> 
													 <entry colname="col1"><phrase
														  role="code">Browse</phrase></entry> 
													 <entry colname="col2">Plural</entry> 
													 <entry colname="col3">Navigation,
														  Searching and Management</entry> 
												</row> 
												<row> 
													 <entry colname="col1"><phrase
														  role="code">List</phrase></entry> 
													 <entry colname="col2">Plural</entry> 
													 <entry colname="col3">Navigation and
														  Searching</entry> 
												</row> 
												<row> 
													 <entry colname="col1"><phrase
														  role="code">Add</phrase></entry> 
													 <entry colname="col2">Singular</entry> 
													 <entry colname="col3">Adding a new
														  row</entry> 
												</row> 
												<row> 
													 <entry colname="col1"><phrase
														  role="code">Edit</phrase></entry> 
													 <entry colname="col2">Singular</entry> 
													 <entry colname="col3">Editing an
														  existing row</entry> 
												</row> 
												<row> 
													 <entry colname="col1"><phrase
														  role="code">Delete</phrase></entry> 
													 <entry colname="col2">Singular</entry> 
													 <entry colname="col3">Viewing an
														  existing row as a delete confirmation</entry> 
												</row> 
												<row> 
													 <entry colname="col1"><phrase
														  role="code">View</phrase></entry> 
													 <entry colname="col2">Singular</entry> 
													 <entry colname="col3">Viewing an
														  existing row (read only)</entry> 
												</row> 
												<row> 
													 <entry colname="col1"><phrase
														  role="code">Preview</phrase></entry> 
													 <entry colname="col2">Singular</entry> 
													 <entry colname="col3">Previewing a
														  corresponding row as an embedded group within another user-interface</entry> 
												</row> 
										  </tbody> 
									 </tgroup> 
								</informaltable></para> 
						  <para>Note that user-interfaces do not necessarily
								correspond one-to-one with form definitions. User-interfaces can be embedded
								within controls in other forms, allowing user-interface definitions to be used
								as building blocks for assembling complex forms with multiple entities exposed.
								For example, the 
								<phrase role="code">Customer</phrase> edit may have a
								page control containing browses for 
								<phrase role="code">ContactEmail</phrase> and 
								<phrase role="code">ContactPhone</phrase>.</para> 
						  <para>In the sections that follow, the various components
								of the structural definition of the result set of a query are considered, and
								how that information is used by the derivation process.</para> 
						  <sect4> 
								<title><indexterm> 
										  <primary>Columns</primary> 
										  <secondary>Derivation And</secondary> 
									 </indexterm>Columns</title> 
								<para>Each column in the result set will correspond
									 with a single control in the resulting user-interface definition. By default
									 the data type of the column is used to determine the type of control to be
									 used, and the title of the control is the unqualified name of the
									 column.</para> 
								<para>Barring other considerations such as derivation
									 tags and grouping based on reference participation, the order of the controls
									 displayed in the user-interface is determined by the order in which the columns
									 appear in the result set.</para> 
								<para>Because the result is being presented within the
									 data access layer, defaults, constraints, and event handlers defined on the
									 column or its data type are exposed as behavior within the user-interface. This
									 is accomplished using the proposable interfaces. Although these interfaces are
									 discussed in more detail later in this part, it is worth noting that defaults,
									 constraints, and event handlers defined at the column and data type levels will
									 be acted on immediately within the user-interface.</para> 
								<para>For example, if a user attempts to enter an
									 invalid value for a particular column, the error message is displayed
									 immediately, rather than waiting for the entire row to be completed. This
									 affords a more intuitive user-interface, and is one reason for declaring
									 constraints as locally as possible. In other words, even though a given column
									 level constraint could be expressed in terms of a row level constraint, doing
									 so would mean that validation of the column value would not take place until
									 the user attempted to post the entire row, rather than immediately upon
									 entering the invalid value.</para> 
						  </sect4> 
						  <sect4> 
								<title><indexterm> 
										  <primary>Keys</primary> 
										  <secondary>Derivation And</secondary> 
									 </indexterm><indexterm> 
										  <primary>Orders</primary> 
										  <secondary>Derivation And</secondary> 
									 </indexterm>Keys and Orders</title> 
								<para>Keys and orders of the result set, whether
									 inferred by the compiler or explicitly defined on table variables, will be
									 exposed in the derived user-interface as possible orderings for the result set.
									 By default, the derivation process will select the clustering key to order the
									 result set in the user-interface. While the notion of a clustering key is an
									 admittedly physical consideration, the reason for the selection is that the
									 clustering key is most likely to be supported by a physical index, and
									 therefore most likely to perform acceptably when presented in a browsing
									 interface.</para> 
								<para>The clustering key is determined by first
									 searching the keys for the 
									 <phrase role="code">Storage.IsClustered</phrase>
									 tag. If no key is marked with this storage tag, the compiler selects the key
									 with the fewest number of columns as the clustering key. Note that this same
									 clustering key determination is used when determining a clustering key in the
									 physical storage layer.</para> 
								<para>In order to allow the user to select a specified
									 ordering for the result set, the order must be specified as a possible
									 ordering, either with a key or an order, within the result set. This
									 requirement allows the developer to control what orderings and searches are
									 allowed for a given result set. In this way, developers can ensure that
									 requests for ordering correspond with actual indexes in the storage
									 layer.</para> 
						  </sect4> 
					 </sect3> 
					 <sect3> 
						  <title><indexterm> 
									 <primary>Elaboration</primary> 
									 <secondary>Overview</secondary> 
								</indexterm>Elaboration</title> 
						  <para>Elaboration is the process of extending a given query
								based on the relationships between that query and the other table variables in
								the database. Elaboration is accomplished by tracing references in the
								database, using the cardinality of the reference to determine whether the
								reference should be followed, and how it should be included in the resulting
								elaborated query.</para> 
						  <para>Elaboration is an optional step, as indicated by the 
								<phrase role="code">Elaborate</phrase> component of the
								derivation seed. If elaboration is not used, not only will the initial query be
								unaffected, but the relationships between the query and the rest of the
								database will not be exposed on the resulting user-interface, neither in
								user-interface controls, nor through menu and tool bar items.</para> 
						  <para>The relationship of the query with other objects in
								the database is determined by examining the set of references in the result
								set. These references may be inferred by the compiler, or explicitly defined on
								table variables in the database. In either case, the cardinality of each
								reference is used to determine how it should be exposed in the
								user-interface.</para> 
						  <para>By far the most important input to the elaboration
								process is the structural information inferred by the compiler about the result
								set. For development purposes, this information can be retrieved in text form
								using the 
								<ulink type="olinka"
								url="O-System.Diagnostics.ShowPlan.html"><phrase
									 role="code">ShowPlan</phrase></ulink> operator.</para> 
						  <para>Reference information is used in two different ways
								by the derivation process: first, to extend the expression to be used to
								provide the result set for the user-interface, and second, in building
								user-interface controls, menu items, and tool bars to allow the user to
								navigate to related information in the database from the derived
								user-interface.</para> 
						  <para>The fact that references must target keys gives rise
								to two different cardinalities for references: one-to-one, and one-to-many. A
								one-to-one reference not only targets a key, but originates in a key as well,
								allowing only one row from the source table variable to reference any given row
								of the target table variable. A one-to-many reference targets a key, but does
								not originate in one, allowing multiple rows of the source table variable to
								reference any given row of the target table variable.</para> 
						  <para>By considering both cardinalities of references from
								the perspective of the source or target table variable, we have four distinct
								types of references: 
								<itemizedlist> 
									 <listitem> 
										  <indexterm> 
												<primary>Parent Reference</primary> 
										  </indexterm> 
										  <para>Parent</para> 
										  <para>A parent reference is a one-to-one
												reference, viewed from the perspective of the source table variable. From this
												perspective the target table variable is the <emphasis>parent</emphasis> of the
												source table variable. In this type of reference, a corresponding row in the
												parent table variable must exist.</para> 
									 </listitem> 
									 <listitem> 
										  <indexterm> 
												<primary>Extension Reference</primary> 
										  </indexterm> 
										  <para>Extension</para> 
										  <para>An extension reference is a one-to-one
												reference, viewed from the perspective of the target table variable. From this
												perspective the source table variable represents <emphasis>extension</emphasis>
												information. In this type of reference, a corresponding row in the extension
												table variable may or may not exist.</para> 
									 </listitem> 
									 <listitem> 
										  <indexterm> 
												<primary>Lookup Reference</primary> 
										  </indexterm> 
										  <para>Lookup</para> 
										  <para>A lookup reference is a one-to-many
												reference, viewed from the perspective of the source table variable. From this
												perspective, the target table variable forms a <emphasis>lookup</emphasis>
												table from which valid values for the columns participating in the reference in
												the source table variable may be selected. In this type of reference, a
												corresponding row in the lookup table variable must exist.</para> 
									 </listitem> 
									 <listitem> 
										  <indexterm> 
												<primary>Detail Reference</primary> 
										  </indexterm> 
										  <para>Detail</para> 
										  <para>A detail reference is a one-to-many
												reference, viewed from the perspective of the target table variable. From this
												perspective, the source table variable represents <emphasis>detail</emphasis>
												information. In this type of reference, a corresponding set of rows in the
												detail table variable may or may not exist.</para> 
									 </listitem> 
								</itemizedlist></para> 
						  <para>A detailed discussion of how each reference is
								considered during the elaboration process is deferred until 
								<ulink
								url="DDGTheAutomationofForms.html"><citetitle>The Automation of
										  Forms</citetitle></ulink>.</para> 
					 </sect3> 
				</sect2> 
		  </sect1> 
		  <sect1> 
				<title>Data Access Layer</title> 
				<para>The Frontend Clients begin where the Dataphor Server ends,
					 namely at the Call-Level Interface (CLI), or the low-level set of APIs that
					 expose the services and functionality of the Dataphor Server. All commands and
					 data retrieval requests, whether they are ad-hoc queries from Dataphoria, or
					 application requests to retrieve or manipulate data, ultimately pass through
					 the CLI.</para> 
				<para>The Data Access Layer is built directly on top of the CLI,
					 and groups all the functionality required by the presentation layer into a set
					 of easy to use components called the Data Access Components (DAC). These
					 components are then used by the forms and controls within the application to
					 manage data retrieval and manipulation.</para> 
				<para>In addition to the traditional cursor-style access exposed by
					 the Dataphor CLI, the Dataphor Server exposes several services that are
					 targeted directly at enabling Automated Application Development. Three of the
					 most important of these are: Navigational Access, Proposable Interfaces, and
					 Application Transactions.</para> 
				<para>Navigational Access is concerned with enabling efficient,
					 scalable access to relational datasets of any size. Using this technology,
					 Dataphor applications can expose the data in any application in an intuitive,
					 searchable manner without the need for developer intervention or complex
					 "filter-down" style user-interfaces.</para> 
				<para>Proposable Interfaces are provided to enable the application
					 to participate in the business-rules enforcement of the Dataphor Server. By
					 utilizing these services, a Dataphor application can efficiently and
					 transparently enforce data integrity while the user is entering data, rather
					 than waiting for the server to reject any invalid information.</para> 
				<para>Application Transactions enable the application to perform
					 data manipulation even in the presence of complex multi-table integrity
					 constraints without requiring data to be entered in a particular order, or
					 using pessimistic transactions. The resulting user-interfaces naturally manage
					 concurrency issues and minimize resource contention.</para> 
				<para>Each of these services will be discussed in detail in 
					 <ulink type="link"
					 url="DDGTheSpaceBetweentheData.html"><citetitle>The Space Between the
								Data</citetitle></ulink>.</para> 
		  </sect1> 
		  <sect1> 
				<title>Forms</title> 
				<para>The Forms which make use of the Data Access Layer are defined
					 in terms of component hierarchies that describe not only the layout and visual
					 controls of the user-interface, but the behavior of the form, and it's
					 connection to other parts of the application. These form definitions are
					 represented as Dataphor Form Documents (DFDs) and stored within the various
					 libraries that make up the application. Each Frontend Client is responsible for
					 retrieving the document definitions through the Data Access Layer, and
					 constructing an appropriate component hierarchy representing that form.</para> 
				<para>In addition to static form definitions stored as documents,
					 the Dataphor platform allows form definitions to be dynamically manufactured
					 using a process called <emphasis>derivation</emphasis>. This process uses the
					 operators exposed by the Frontend Server to produce form definitions based
					 entirely on the application schema.</para> 
				<para>Whether produced statically or dynamically, form definitions
					 can be customized using the same visual designer that is used to create static
					 forms. Customizations to forms are produced using a process called
					 <emphasis>visual inheritance</emphasis>. These customizations are then saved as
					 a Customized Dataphor Form Document (DFDX) and become available in the same way
					 as other form definitions within the application.</para> 
				<para>Form definitions within the Dataphor framework are
					 represented as XML documents corresponding to the component hierarchy defining
					 the form. Each component corresponds with an element in the XML document, with
					 the attributes of the component corresponding to the various properties of the
					 component in the form. The XML schema used to describe these documents is
					 called Dataphor user-Interface Language (DIL).</para> 
				<sect2> 
					 <title>Components and Controls</title> 
					 <para>Forms are the fundamental unit of user-interface in a
						  Dataphor application. Forms are made up of groups of user-interface controls
						  that provide the mechanisms for the user to interact with the data in the
						  database, as well as the application itself. In this respect, forms in a
						  Dataphor application are very similar to the forms in a classic RAD-style
						  application. In the RAD paradigm, forms are collections of software components
						  that are each responsible for a particular common behavior. Groups of these
						  components are "glued" together using a visual forms designer, and any
						  form-specific application code is attached to various events occurring within
						  the components.</para> 
					 <para>RAD development is productive precisely because of the
						  amount of re-use that is gained by relegating automatable application tasks to
						  components within the forms. The Dataphor platform makes use of this paradigm,
						  but separates the form definitions from the client applications, resulting in
						  client-independent form definitions. This abstraction allows the same form
						  definition to be used from a Microsoft Windows based machine, over the Web, or
						  any other platform that has a Dataphor Frontend Client.</para> 
					 <para>This section introduces the underlying architecture and
						  components of the forms within a Dataphor application. This discussion focuses
						  mainly on describing the various controls and techniques that are available for
						  defining forms. Although complete applications can be built from scratch using
						  a traditional RAD approach, the vast majority of Dataphor forms will be
						  derived, rather than manually constructed. The process of deriving forms,
						  however, can be understood more clearly as the automation of the RAD-style
						  development techniques presented here.</para> 
					 <sect3> 
						  <title>Components</title> 
						  <para>All Dataphor forms are described as a hierarchy of
								<emphasis>components</emphasis>. The base component introduces the services
								necessary for each component to participate within the structure of a form
								definition. Each component may be either visual or non-visual. The visual
								components, also called <emphasis>controls</emphasis>, actually have some
								visible representation within the form, while non-visual components handle
								behind-the-scenes interaction such as data access or command processing.</para>
						  
						  <para>Each type of component is responsible for a different
								task within the overall form. For example, a 
								<phrase role="code">Source</phrase> component is used
								to handle communication with the Dataphor Server for a single query and its
								corresponding result set. A 
								<phrase role="code">TextBox</phrase> control may then
								be attached to the 
								<phrase role="code">Source</phrase> in order to expose
								a particular column within that result set. A 
								<phrase role="code">Grid</phrase> control may be used
								to display a navigable view of the result set.</para> 
						  <para>If the particular behavior required by the
								application is not represented by some existing component, the Dataphor
								platform can be easily extended with new components and controls to provide
								whatever functionality is necessary. In addition, there are programmable
								components such as the 
								<phrase role="code">ScriptAction</phrase> and 
								<phrase role="code">DataScriptAction</phrase> that
								allow custom behavior to be written directly into the application.</para> 
						  <para>Each component has an <emphasis>owner</emphasis>,
								which is the owner of the component within the hierarchy. Owners are
								responsible for the cleanup of components that they own. This ownership
								hierarchy is also used to broadcast component events within the form. Each
								visual element, or control, in the form also has a <emphasis>parent</emphasis>
								property that determines the visual containership of the control within the
								form.</para> 
						  <para>Forms are actually hosts for user-interfaces, in that
								a given user-interface may appear hosted within a particular form, or within a
								frame within a control of another form. When a user-interface is embedded
								within another, the containership hierarchy can be followed to its root from
								any component within the embedded user-interface to access the parent
								form.</para> 
						  <para>Note that although the components themselves are
								instances of classes, their behavior is modeled exclusively in terms of
								interfaces (in the formal .NET sense of the word). For example, the basic
								behavior for all components is described by the .NET interface 
								<phrase role="code">INode</phrase>. The base class that
								implements this interface is called a 
								<phrase role="code">Node</phrase>. The reason for the
								exclusive use of interfaces is so that different implementations of a given
								component can be provided without affecting code written against the
								interfaces. This allows each Frontend client to provide different
								implementations of the same behavior. For this reason, whenever components are
								accessed within scripts, the interfaces should be used exclusively,
								guaranteeing that a given script will execute regardless of the actual Frontend
								client in which it runs.</para> 
					 </sect3> 
					 <sect3> 
						  <title>Actions</title> 
						  <para>Actions are specific types of components that perform
								some operation within the form. Actions are an abstraction that is used to
								model the commands that are available within any given user-interface. These
								commands can be triggered from various sources such as buttons, menu items,
								pop-ups, and so on. In addition, actions can be attached to various events that
								occur on other components within the form, or executed directly using
								scripting.</para>

          <!--Discuss all the different actions available-->
					 </sect3> 
					 <sect3> 
						  <title>Controls</title> 
						  <para>Controls are the base component type for all visual
								controls within a Dataphor form. These controls are grouped into container
								controls such as rows, columns, and groups, to provide layout functionality
								within the form. Note that the layout in a Dataphor form is relative, rather
								than absolute. In other words, all layout is handled by containership, rather
								than position in a form-based coordinate system. This layout mechanism allows
								for a much greater degree of flexibility in interpreting form definitions in
								the consuming client, enabling much better cross-client support.</para>

          <!--Discuss all the different controls (non data-aware)-->
					 </sect3> 
					 <sect3> 
						  <title>Data Access</title> 
						  <para>Data access within the presentation layer is provided
								by 
								<phrase role="code">Source</phrase> components. Each
								source is implicitly connected to the Dataphor Server using the Frontend
								session for the application. The source and session together completely expose
								the functionality of the Dataphor Server within Dataphor applications. The
								various data-aware controls of the form connect to 
								<phrase role="code">Source</phrase> components to
								display and manipulate the data in the database.</para>

          <!--Discuss all the different data-aware controls-->
					 </sect3> 
					 <sect3> 
						  <title>Scripting</title> 
						  <para>In addition to providing behavior based on existing
								form components, the Dataphor platform supports application-specific behavior
								using both client-side and server-side scripting.</para> 
						  <para>Client-side scripting is accomplished using the 
								<phrase role="code">ScriptAction</phrase> component,
								using either C# or VB. The script action specifies a block of client-side code
								to be executed. This block of code has access to all the components within the
								form by name, as well as several implicit variables allowing direct access to
								the host form and interfaces.</para> 
						  <para>Server-side scripting is accomplished using the 
								<phrase role="code">DataScriptAction</phrase>
								component. This component allows a D4 script to be executed on the Dataphor
								Server. In addition, the D4 script can be parameterized using 
								<phrase role="code">DataArgument</phrase> components
								connected to sources in the form.</para>

          <!--Examples of each type of scripting-->
					 </sect3> 
				</sect2> 
				<sect2> 
					 <title>Form Behavior</title> 
					 <para>All forms within a Dataphor application share common
						  characteristics and behaviors, including the <emphasis>state</emphasis> of the
						  form, and whether the form is <emphasis>modal</emphasis>.</para> 
					 <para>When a form is waiting for user input, it is in
						  <emphasis>accept-reject</emphasis> state. This state is indicated by the 
						  <phrase role="code">Accept</phrase> and 
						  <phrase role="code">Reject</phrase> buttons available on
						  the toolbar. When not in this state, these buttons are replaced by a standard 
						  <phrase role="code">Close</phrase> button.</para> 
					 <para>In addition to form state, a Dataphor Form may be
						  <emphasis>modal</emphasis>, indicating the form from which the user-interface
						  was launched is not accessible until the child user-interface is closed. This
						  is called <emphasis>child modal</emphasis> because only the launching form is
						  inaccessible. Other forms in the application can still be reached, allowing
						  multiple "threads" of execution within the same application.</para> 
					 <para>All this behavior can be controlled explicitly using the
						  various properties of a 
						  <phrase role="code">ShowFormAction</phrase>. In addition,
						  this action allows data in the child form to be filtered by the calling form,
						  using either the 
						  <phrase role="code">Filter</phrase> property, or by setting
						  up a master/detail relationship using the 
						  <phrase role="code">Detail</phrase> link type.</para> 
				</sect2> 
				<sect2> 
					 <title><indexterm> 
								<primary>Document Expressions</primary> 
						  </indexterm>Document Expressions</title> 
					 <para>In addition to static document definitions, documents can
						  be constructed dynamically using operators available in the D4 language.
						  Whenever a document reference is required within a form definition in the
						  Frontend, a <emphasis>document expression</emphasis> is used to specify the
						  document reference. This can be as simple as the invocation of a 
						  <phrase role="code">Frontend.Load</phrase> operator that
						  simply loads the definition of a static form document directly from a library,
						  or it can be as complex as the actual form document embedded in the expression.
						  For example, the following program listing is a valid document expression: 
						  <programlisting>"&lt;interface/&gt;"</programlisting></para> 
					 <para>Typically, a document expression is one of the following:
						  
						  <itemizedlist> 
								<listitem> 
									 <para><phrase role="code">Frontend.Form(&lt;library
												name&gt;, &lt;document name&gt;)</phrase></para> 
									 <para>This operator allows both static and
										  customized form documents to be loaded. If the document specified is a
										  customized form document, the customization will be expanded and applied, and
										  the final, customized form document will be returned, ready for deserialization
										  in the Frontend.</para> 
								</listitem> 
								<listitem> 
									 <para><phrase
										  role="code">Frontend.Image(&lt;library name&gt;, &lt;document
												name&gt;)</phrase></para> 
									 <para>This operator allows documents containing
										  graphic data such as images and icons to be loaded using streams.</para> 
								</listitem> 
								<listitem> 
									 <para><phrase
										  role="code">Frontend.Derive(&lt;expression&gt;, &lt;pagetype&gt;, &lt;master
												key names&gt;, &lt;detail key names&gt;, &lt;elaborate&gt;)</phrase></para> 
									 <para>This operator invokes the Frontend Server
										  process of user-interface derivation based on the given expression. For more
										  information on the usage and functioning of this operator, refer to 
										  <ulink type="link"
											url="DDGTheAutomationofForms.html"><citetitle>The Automation of
													 Forms</citetitle></ulink> later in this part.</para> 
								</listitem> 
						  </itemizedlist></para> 
					 <para>For a more complete listing of the available document
						  manipulation operators, refer to the Frontend Library reference.</para> 
				</sect2> 
				<sect2> 
					 <title>Visual Inheritance</title> 
					 <para>Visual inheritance allows new forms to be constructed by
						  starting with an existing form definition, and then customizing the definition
						  either by changing existing properties, or adding new components, or both. The
						  customized form definition is saved only in terms of the differences from the
						  base form.</para> 
					 <para>For example, the following document listing shows a
						  simple Dataphor form definition: 
						  <programlisting>&lt;?xml version="1.0" encoding="utf-16"?&gt;
&lt;interface xmlns:bop="www.alphora.com/schemas/bop"&gt;
	&lt;column bop:name="Column"&gt;
		&lt;statictext text="Hello World!" bop:name="StaticText" /&gt;
	&lt;/column&gt;
&lt;/interface&gt;</programlisting></para> 
					 <para>And this document listing shows a customization to that
						  form definition: 
						  <programlisting>&lt;?xml version="1.0" encoding="utf-16" standalone="yes"?&gt;
&lt;dilx xmlns="http://www.alphora.com/schemas/dilx"&gt;
	&lt;ancestor document=".Frontend.Form('General', 'HelloWorld')" /&gt;
 &lt;document&gt;
		&lt;interface xmlns:bop="www.alphora.com/schemas/bop" xmlns:ibop="www.alphora.com/schemas/ibop"&gt;
			&lt;column bop:name="Column"&gt;
				&lt;statictext bop:name="StaticText" text="Custom Hello World!" /&gt;
			&lt;/column&gt;
		&lt;/interface&gt;
	&lt;/document&gt;
&lt;/dilx&gt;</programlisting></para> 
					 <para>Note that components that have been introduced in
						  ancestor documents can not be deleted in a customization. Only the properties
						  of these components may be changed. However, components can be moved to
						  different containers, and they can be made invisible using the 
						  <phrase role="code">Visible</phrase> property.</para> 
					 <para>Note also that visual inheritance allows multiple
						  ancestors to be specified. Each additional ancestor is applied as a
						  customization to the form definition, and then the final customization is
						  applied. In this way, behavior and visual representations from multiple
						  ancestor forms can be combined into a single form definition, allowing a much
						  greater degree of flexibility.</para> 
					 <para>For example, the following two document listings show
						  another static document, and a modified customization that uses two separate
						  ancestors. The resulting form has both the 
						  <phrase role="code">StaticText</phrase> from the initial
						  Hello World document, and the 
						  <phrase role="code">Trigger</phrase> and 
						  <phrase role="code">ScriptAction</phrase> from the second
						  Hello World document: 
						  <programlisting>&lt;?xml version="1.0" encoding="utf-16"?&gt;
&lt;interface xmlns:bop="www.alphora.com/schemas/bop"&gt;
 &lt;column bop:name="Column"&gt;
		&lt;trigger action="ScriptAction" bop:name="Trigger" /&gt;
 &lt;/column&gt;
	&lt;scriptaction 
		script="Trigger.Text = &amp;quot;Dynamic Hello World&amp;quot;;" 
		text="Hello World!" bop:name="ScriptAction" 
	/&gt;
&lt;/interface&gt;</programlisting> 
						  <programlisting>&lt;?xml version="1.0" encoding="utf-16" standalone="yes"?&gt;
&lt;dilx xmlns="http://www.alphora.com/schemas/dilx"&gt;
	&lt;ancestor document=".Frontend.Form('General', 'HelloWorld')" /&gt;
	&lt;ancestor document=".Frontend.Form('General', 'HelloWorldButton')" /&gt;
	&lt;document&gt;
		&lt;interface xmlns:bop="www.alphora.com/schemas/bop" xmlns:ibop="www.alphora.com/schemas/ibop"&gt;
			&lt;column bop:name="Column"&gt;
				&lt;statictext bop:name="StaticText" text="Custom Hello World!" /&gt;
			&lt;/column&gt;
		&lt;/interface&gt;
	&lt;/document&gt;
&lt;/dilx&gt;</programlisting></para>

        <!--Examples of how to actually use visual and multiple visual inheritance, hopefully taken from the Shipping Application-->
				</sect2> 
		  </sect1>

    <!--<sect1>
    <title>Frontend Clients</title>
    <para>Frontend Clients make use of all these layers to actually produce the application for use by the end user.</para>
</sect1>-->
	 </chapter> 
	 <chapter id="DDGPuttingItAllTogether"> 
		  <title>Putting It All Together</title> 
		  <para>In this chapter, we return to the running example and apply the
				technologies and techniques introduced in the previous chapter to the process
				of building the presentation layer of the Shipping application. Each section
				will discuss building a separate portion of the user-interfaces, and explore
				how the Dataphor platform enables declarative solutions to the problems of
				database application development.</para> 
		  <sect1 id="DDGPuttingItAllTogether-LocationManagement"> 
				<title>Location Management</title> 
				<para>We begin the process of building the user-interfaces required
					 for location management by answering in detail two questions: first, what
					 user-interfaces are required, and second, what user-interfaces do the unadorned
					 location structures provide?</para> 
				<para>The following diagram depicts the logical design of the
					 location tables in the Shipping application: 
					 <figure> 
						  <title><indexterm> 
									 <primary>Shipping Database Design</primary> 
									 <secondary>Locations</secondary> 
								</indexterm>Shipping Database Design: Locations</title>
						  
						  <mediaobject> 
								<imageobject role="fo">
									 <imagedata fileref="Images\LocationDiagram.svg" format="SVG" scalefit="1"/> 
								</imageobject> 
								<imageobject role="html">
									 <imagedata fileref="Images\LocationDiagram.emf" scalefit="1"/> 
								</imageobject> 
						  </mediaobject> 
					 </figure></para> 
				<para>From this diagram, we see that we have three tables: 
					 <phrase role="code">State</phrase>, 
					 <phrase role="code">ZipCode</phrase>, and 
					 <phrase role="code">Location</phrase>, with the obvious
					 meanings. However, the diagram also shows the relationships between these three
					 tables in the form of reference constraints, of which there are three: 
					 <phrase role="code">ZipCode_State</phrase>, 
					 <phrase role="code">Location_ZipCode</phrase>, and 
					 <phrase role="code">Location_State</phrase>.</para> 
				<para>Not only do these references enforce the integrity of the
					 database 
					 <footnote> 
						  <para>We note in passing that the design is not entirely
								correct due to the fact that U.S. Postal Service Zip codes do not uniquely
								determine a city and state in all cases. For simplicity, we have omitted this
								detail.</para> 
					 </footnote>, but they are just as important as the definitions
					 of the tables themselves in terms of producing intuitive and effective
					 user-interfaces.</para> 
				<para>Given this subschema, we can answer the first question by
					 simply enumerating the required user-interfaces: 
					 <itemizedlist> 
						  <listitem> 
								<para>Search user-interface for finding a
									 location.</para> 
						  </listitem> 
						  <listitem> 
								<para>Edit user-interface for adding, editing, viewing,
									 or deleting a location.</para> 
						  </listitem> 
						  <listitem> 
								<para>Search user-interface for finding a state.</para>
								
						  </listitem> 
						  <listitem> 
								<para>Edit user-interface for adding, editing, viewing,
									 or deleting a state.</para> 
						  </listitem> 
						  <listitem> 
								<para>Search user-interface for finding a
									 zipcode.</para> 
						  </listitem> 
						  <listitem> 
								<para>Edit user-interface for adding, editing, viewing,
									 or deleting a zipcode.</para> 
						  </listitem> 
					 </itemizedlist></para> 
				<para>To answer the second question, consider the following add
					 form based on the unadorned 
					 <phrase role="code">Location</phrase> table 
					 <footnote> 
						  <para>The document expression for the user-interface shown
								is 
								<phrase role="code">Derive('Location', 'Add')</phrase>.
								Alternatively, the derived form launcher can be used by right-clicking on the 
								<phrase role="code">Location</phrase> table in the
								Dataphor Explorer and selecting 
								<guimenuitem>Derive...</guimenuitem>.</para> 
					 </footnote>: 
					 <mediaobject> 
						  <imageobject>
								<imagedata depth="389" fileref="Images\Part3LocationAddUnadorned.bmp"
								 width="325"/> 
						  </imageobject> 
					 </mediaobject></para> 
				<para>Firstly, we note that the user-interface is not exactly
					 unadorned. There are no metadata tags on the tables or references involved, but
					 there are still metadata tags on the types controlling the titles and widths of
					 the columns.</para> 
				<para>Regarding the lookup controls for the 
					 <phrase role="code">State</phrase> and 
					 <phrase role="code">ZipCode</phrase> columns, these are simply
					 the result of the unadorned references 
					 <phrase role="code">Location_State</phrase> and 
					 <phrase role="code">Location_ZipCode</phrase>, respectively.
					 Other than the titles, the controls are fine, and so we will leave them. As for
					 the titles of these controls, we will set these by setting the titles of the 
					 <phrase role="code">State</phrase> and 
					 <phrase role="code">ZipCode</phrase> tables,
					 respectively.</para> 
				<para>The following script will set the title and plural title for
					 the 
					 <phrase role="code">State</phrase>, 
					 <phrase role="code">ZipCode</phrase>, and 
					 <phrase role="code">Location</phrase> tables: 
					 <programlisting><emphasis role="bold">alter table</emphasis> State <emphasis role="bold">alter tags</emphasis> 
{ 
	<emphasis role="bold">create static</emphasis> Frontend.Title = "State", 
	<emphasis role="bold">create static</emphasis> Frontend.Plural.Title = "States" 
};

<emphasis role="bold">alter table</emphasis> ZipCode <emphasis role="bold">alter tags</emphasis> 
{ 
	<emphasis role="bold">create static</emphasis> Frontend.Title = "Zip Code", 
	<emphasis role="bold">create static</emphasis> Frontend.Plural.Title = "Zip Codes" 
};

<emphasis role="bold">alter table</emphasis> Location <emphasis role="bold">alter tags</emphasis>
{
	<emphasis role="bold">create static</emphasis> Frontend.Title = "Location",
 <emphasis role="bold">create static</emphasis> Frontend.Plural.Title = "Locations"
};</programlisting></para> 
				<para>The plural title will be used whenever a table-level title is
					 required, such as the caption for a browse form. The singular title will be
					 used in singular contexts such as column titles, or row-level user-interfaces.
					 With these adornments, the title of the control for the 
					 <phrase role="code">ZipCode</phrase> column will now be 
					 <phrase role="code">Zip Code</phrase>, based on the singular
					 title tag for the table.</para> 
				<para>Although functional, the default layout of this
					 user-interface could be considerably improved by placing some of the controls
					 on the same horizontal line. This can be accomplished within the derivation
					 framework by changing the <emphasis>flow</emphasis> of the controls during
					 user-interface layout. For the 
					 <phrase role="code">Location</phrase> user-interfaces, we will
					 add a 
					 <phrase role="code">Frontend.FlowBreak</phrase> tag to the 
					 <phrase role="code">City</phrase> and 
					 <phrase role="code">State_ID</phrase> columns. As the following
					 screen shot shows, these tags temporarily change the flow for the next control:
					 
					 <mediaobject> 
						  <imageobject>
								<imagedata depth="310"
								 fileref="Images\Part3LocationAddWithFlowBreak.bmp" width="348"/> 
						  </imageobject> 
					 </mediaobject></para> 
				<para>Note that the flowbreak tags are ignored for plural
					 user-interfaces, so it is not necessary to limit them with a singular or form
					 type qualifier: 
					 <programlisting><emphasis role="bold">alter table</emphasis> Location
{
	<emphasis role="bold">alter column</emphasis> City <emphasis role="bold">alter tags</emphasis> { <emphasis role="bold">create</emphasis> Frontend.FlowBreak = "true" },
	<emphasis role="bold">alter column</emphasis> State_ID <emphasis role="bold">alter tags</emphasis> { <emphasis role="bold">create</emphasis> Frontend.FlowBreak = "true" }
};</programlisting></para> 
				<para>In addition to changing the flow of controls within the
					 user-interface, the grouping of those controls can be changed using tags. For
					 this user-interface, we will place all the address controls in a group labeled 
					 <phrase role="code">Location Address</phrase>: 
					 <programlisting><emphasis role="bold">alter table</emphasis> Location
{
	<emphasis role="bold">alter column</emphasis> Street <emphasis role="bold">alter tags</emphasis> { <emphasis role="bold">create</emphasis> Frontend.Group = "Address" },
	<emphasis role="bold">alter column</emphasis> City <emphasis role="bold">alter tags</emphasis> { <emphasis role="bold">create</emphasis> Frontend.Group = "Address" },
	<emphasis role="bold">alter column</emphasis> State_ID <emphasis role="bold">alter tags</emphasis> { <emphasis role="bold">create</emphasis> Frontend.Group = "Address" },
	<emphasis role="bold">alter column</emphasis> ZipCode <emphasis role="bold">alter tags</emphasis> { <emphasis role="bold">create</emphasis> Frontend.Group = "Address" }
}
	<emphasis role="bold">alter tags</emphasis> { <emphasis role="bold">create</emphasis> Frontend.Group.Address.Title = "Location Address" };</programlisting></para> 
				<para>The resulting user-interface has a group for the address
					 controls: 
					 <mediaobject> 
						  <imageobject>
								<imagedata depth="333" fileref="Images\Part3LocationAddWithGroup.bmp"
								 width="357"/> 
						  </imageobject> 
					 </mediaobject></para> 
				<para>Note the additional table-level tag to set the title of the
					 group. In order to allow group-level tags to be set in this way, derivation
					 requires that group names be valid identifiers within D4. All the standard tags
					 controlling layout and titles can be used with groups.</para> 
				<para>To place a column within a particular group, use the 
					 <phrase role="code">Frontend.Group</phrase> tag on the column.
					 Note that the column can be placed within nested groups by using a backslash
					 (<phrase role="code">\</phrase>) to delineate successive group names. For
					 example: 
					 <programlisting><emphasis role="bold">alter table</emphasis> Location
{
	<emphasis role="bold">alter column</emphasis> Name <emphasis role="bold">alter tags</emphasis> { <emphasis role="bold">create</emphasis> Frontend.Group = "Location" },
	<emphasis role="bold">alter column</emphasis> Phone <emphasis role="bold">alter tags</emphasis> { <emphasis role="bold">create</emphasis> Frontend.Group = "Location" },
	<emphasis role="bold">alter column</emphasis> Street <emphasis role="bold">alter tags</emphasis> { <emphasis role="bold">alter</emphasis> Frontend.Group = "Location\Address" },
	<emphasis role="bold">alter column</emphasis> City <emphasis role="bold">alter tags</emphasis> { <emphasis role="bold">alter</emphasis> Frontend.Group = "Location\Address" },
	<emphasis role="bold">alter column</emphasis> State_ID <emphasis role="bold">alter tags</emphasis> { <emphasis role="bold">alter</emphasis> Frontend.Group = "Location\Address" },
	<emphasis role="bold">alter column</emphasis> ZipCode <emphasis role="bold">alter tags</emphasis> { <emphasis role="bold">alter</emphasis> Frontend.Group = "Location\Address" }
}
	<emphasis role="bold">alter tags</emphasis> 
	{ 
		<emphasis role="bold">drop</emphasis> Frontend.Group.Address.Title,
		<emphasis role="bold">create</emphasis> Frontend.Group.Location.Address.Title = "Location Address" 
	};</programlisting></para> 
				<para>Note that the backslash becomes a qualifier (<phrase
					 role="code">.</phrase>) in the group-level tag. The following screenshot
					 depicts the resulting user-interface: 
					 <mediaobject> 
						  <imageobject>
								<imagedata depth="359" fileref="Images\Part3LocationAddWithLocationGroup.bmp"
								 width="367"/> 
						  </imageobject> 
					 </mediaobject></para> 
				<para>In addition to layout and other cosmetic changes, we would
					 like to provide as useful a user-interface as possible. In addition to the
					 benefits of using automated user-interfaces such as consistent look-and-feel,
					 managed hot-key assignment, and managed tab-order, the Dataphor Server provides
					 the proposable interfaces to allow data entry behavior to be tailored for each
					 application. In this case, we will use the <emphasis>change</emphasis>
					 proposable to set the 
					 <phrase role="code">City</phrase> and 
					 <phrase role="code">State_ID</phrase> columns whenever a 
					 <phrase role="code">ZipCode</phrase> is chosen. The following
					 program listing shows the event handler: 
					 <programlisting>//* Operator: LocationZipCodeChange
<emphasis role="bold">create operator</emphasis> LocationZipCodeChange(<emphasis role="bold">var</emphasis> ARow : <emphasis role="bold">typeof</emphasis>(Location[])) : Boolean
<emphasis role="bold">begin</emphasis>
	<emphasis role="bold">result</emphasis> := <emphasis role="bold">false</emphasis>;
	<emphasis role="bold">if not</emphasis>(IsNil(ARow.ZipCode)) <emphasis role="bold">and</emphasis> IsNil(ARow.City) <emphasis role="bold">and</emphasis> IsNil(ARow.State_ID) <emphasis role="bold">then</emphasis>
	<emphasis role="bold">begin</emphasis>
		<emphasis role="bold">result</emphasis> := <emphasis role="bold">true</emphasis>;
		<emphasis role="bold">var</emphasis> LZipRow := ZipCode[ARow.ZipCode] { ZipCode, City, State_ID };
		<emphasis role="bold">update</emphasis> ARow <emphasis role="bold">set</emphasis> { City := LZipRow.City, State_ID := LZipRow.State_ID };
	<emphasis role="bold">end</emphasis>;
<emphasis role="bold">end</emphasis>;
<emphasis role="bold">attach</emphasis> LocationZipCodeChange <emphasis role="bold">to</emphasis> ZipCode <emphasis role="bold">in</emphasis> Location <emphasis role="bold">on change</emphasis>;</programlisting></para> 
				<para>In connection with this event handler, we note that the
					 handler will <emphasis>not</emphasis> be translated into an application
					 transaction context. By default, operators that do not modify global table
					 variables (functional operators) such as this one are not translated. Although
					 this behavior can be changed using the 
					 <phrase role="code">DAE.ShouldTranslate</phrase> tag on the
					 operator, in this case, we do not want the operator to translate into the A/T
					 space as it is unnecessary. This is because the operator does not update any
					 information in the database, and there is therefore no reason for it to be part
					 of the batch process of inserting or editing a location.</para> 
				<para>This is the extent of the tailoring we will do for the
					 user-interfaces in the location management portion of the Shipping application.
					 With just a few lines of declarative adornments to the existing application
					 schema, we have tailored the appearance of the application. Moreover, we have
					 done so without any client-side code, even when we modified the run-time
					 client-side behavior of the application. The resulting user-interfaces are
					 extremely well insulated from changes in the application schema, indeed, they
					 are entirely defined by the application schema.</para> 
		  </sect1> 
		  <sect1 id="DDGPuttingItAllTogether-ContactManagement"> 
				<title>Contact Management</title> 
				<para>A significant portion of the Shipping application centers
					 around contact management. Many of the core requirements deal exclusively with
					 tracking contact information, and the main purpose of the application, invoice
					 management, would be useless without the ability to correlate invoice
					 information with contacts. This section will first consider the core contact
					 user-interfaces, and will then build on that to provide the Customer and Vendor
					 user-interfaces.</para> 
				<para>To begin, consider the basic contact structures, as shown in
					 the following diagram: 
					 <figure> 
						  <title><indexterm> 
									 <primary>Shipping Database Design</primary> 
									 <secondary>Contacts</secondary> 
								</indexterm>Shipping Database Design: Contacts</title> 
						  <mediaobject> 
								<imageobject role="fo">
									 <imagedata fileref="Images\ContactDiagram.svg" format="SVG" scalefit="1"/> 
								</imageobject> 
								<imageobject role="html">
									 <imagedata fileref="Images\ContactDiagram.emf" scalefit="1"/> 
								</imageobject> 
						  </mediaobject> 
					 </figure></para> 
				<para>The following screenshot depicts the default add
					 user-interface for the 
					 <phrase role="code">Contact</phrase> table: 
					 <mediaobject> 
						  <imageobject>
								<imagedata depth="214" fileref="Images\Part3ContactAdd1.bmp" width="325"/> 
						  </imageobject> 
					 </mediaobject></para> 
				<para>Notice the 
					 <guimenu>Details</guimenu> menu containing links to the 
					 <phrase role="code">ContactPhone</phrase> and 
					 <phrase role="code">ContactAddress</phrase> tables for the
					 current 
					 <phrase role="code">Contact</phrase>. Notice also the group
					 labeled 
					 <phrase role="code">Phone</phrase>, and the inclusion of a
					 read-only control labeled 
					 <phrase role="code">Phone #</phrase>. This was done using the 
					 <phrase role="code">Frontend.Preview.Include</phrase> tag on
					 the 
					 <phrase role="code">Phone</phrase> column of the 
					 <phrase role="code">ContactPhone</phrase> table. This tag is
					 used whenever a lookup is being embedded into a user-interface, and determines
					 which columns from the lookup target table will be included in the
					 user-interface. All the controls for the lookup that are brought in using the
					 include will be placed within a group for the lookup. The default value for
					 this tag is false, meaning that no columns will be brought in. This means that
					 for lookup tables, preview information must be explicitly specified. In
					 addition, if there is only one column being included from the lookup target (as
					 in this case), that column will appear in-line with the lookup control.</para> 
				<para>As discussed in the Logical Application Design part of this
					 guide, tackling the history portions of the contact system required the use of
					 historical tracking tables called <emphasis>during</emphasis> tables [19], and
					 the use of <emphasis>since</emphasis> columns within the contact structures
					 themselves. In addition, several event handlers were defined to make the
					 auditing transparent to the application user. Behind the scenes, the Dataphor
					 Server simply logs changes to the contact information as they occur. In this
					 section, we will expose these history lists on the 
					 <guimenu>Details</guimenu> menu using views and references.
					 Because each of the three history lists (name, address, and phone number) will
					 be handled the same way, we will only discuss the name history.</para> 
				<para>The first task is to provide a view of the audit trail. This
					 is accomplished by combining the current information (from the 
					 <phrase role="code">Contact</phrase> table) with the historical
					 information (from the 
					 <phrase role="code">ContactNameDuring</phrase> table). The
					 following view definition provides the required information: 
					 <programlisting>//* View: ContactNameHistory
<emphasis role="bold">create view</emphasis> ContactNameHistory
	ContactNameDuring
		<emphasis role="bold">union</emphasis> 
		(
			Contact 
			{ 
				ID Contact_ID, 
				NameSince From, 
				DateTime() To, 
				Name, 
				NameBy By 
			}
		)
		<emphasis role="bold">adorn</emphasis>
		{
			From <emphasis role="bold">tags</emphasis> { Frontend.Visible = "true" },
			<emphasis role="bold">key</emphasis> { Contact_ID, From } <emphasis role="bold">tags</emphasis> { Frontend.Visible = "false" },
			<emphasis role="bold">drop key</emphasis> { Contact_ID, From, To, Name, By },
			<emphasis role="bold">drop order</emphasis> { Name },
			<emphasis role="bold">order</emphasis> { Contact_ID, From <emphasis role="bold">desc</emphasis> } <emphasis role="bold">tags</emphasis> { Frontend.IsDefault = "true" }
		}
	<emphasis role="bold">tags</emphasis> 
	{ 
		Frontend.Title = "Name History",
		Frontend.Caption = "Contact Name History", 
		Frontend.UseList = "true", 
		Frontend.Elaborate = "false",
		Frontend.Search.Visible = "false"
	};</programlisting></para> 
				<para>In addition to providing the result set, this view definition
					 includes an adorn operator that further defines the user-interface. First, it
					 includes a 
					 <phrase role="code">Frontend.Visible</phrase> tag for the 
					 <phrase role="code">From</phrase> column. This tag is required
					 because the 
					 <phrase role="code">NameSince</phrase> column on which it is
					 based is set invisible. Without this tag, the 
					 <phrase role="code">From</phrase> column would not be displayed
					 
					 <footnote> 
						  <para>An alternative solution is to declare the visible tag
								on the 
								<phrase role="code">NameSince</phrase> column 
								<phrase role="code"><emphasis
									 role="bold">static</emphasis></phrase>, preventing it from being inferred with
								the expression.</para> 
					 </footnote>.</para> 
				<para>Second, the adorn operator changes the inferred key of the
					 result set by dropping the key inferred from the 
					 <phrase role="code"><emphasis
						  role="bold">union</emphasis></phrase>, and declaring a key on the 
					 <phrase role="code">Contact_ID</phrase> and 
					 <phrase role="code">From</phrase> columns. This is a legitimate
					 usage of an adorned key because the event handlers in place on the 
					 <phrase role="code">Contact</phrase> table ensure that the
					 value of the 
					 <phrase role="code">NameSince</phrase> column in the 
					 <phrase role="code">Contact</phrase> table will always be
					 greater than any value of the 
					 <phrase role="code">From</phrase> column in the 
					 <phrase role="code">ContactNameDuring</phrase> table for a
					 given contact.</para> 
				<para>Next, the adorn operator changes the inferred order of the
					 result set by dropping the order inferred on the 
					 <phrase role="code">Name</phrase> column, and adding an order
					 based on the 
					 <phrase role="code">From</phrase> column descending. This new
					 order is also marked as the default order for the view, instructing the
					 derivation engine to choose this order initially when building a
					 user-interface.</para> 
				<para>Finally, the adorn operator introduces several tags
					 controlling the appearance of the resulting user-interface. Two of the tags,
					 the 
					 <phrase role="code">Frontend.Caption</phrase>, and 
					 <phrase role="code">Frontend.Search.Visible</phrase>, affect
					 the actual user-interface, providing the caption of the form, and removing the
					 search control. The other tags affect how the user-interface will be reached
					 from other forms, and will be discussed next.</para> 
				<para>With the view defined, we need to link it into the main
					 contact user-interface. This is accomplished by declaring a reference from the
					 newly created view to the contact table: 
					 <programlisting>//* Reference: ContactNameHistory_Contact
<emphasis role="bold">create reference</emphasis> ContactNameHistory_Contact
	ContactNameHistory { Contact_ID }
	<emphasis role="bold">references</emphasis> Contact { ID };</programlisting></para> 
				<para>Because of the cardinalities involved, this reference will be
					 treated as a detail from the perspective of the 
					 <phrase role="code">Contact</phrase> table. As such, it will
					 appear as a link on the 
					 <guimenu>Details</guimenu> menu of any derived and elaborated 
					 <phrase role="code">Contact</phrase> user-interface. The title
					 of the link is set with the 
					 <phrase role="code">Frontend.Title</phrase> tag on the view,
					 while the 
					 <phrase role="code">UseList</phrase> and 
					 <phrase role="code">Elaborate</phrase> tags control how the
					 document expression for the link is built. The 
					 <phrase role="code">UseList</phrase> tag indicates that the
					 form type should be 
					 <phrase role="code">List</phrase>, and the 
					 <phrase role="code">Elaborate</phrase> tag turns off
					 elaboration for the derived user-interface. The result is a menu item labeled 
					 <guimenuitem>Name History</guimenuitem> on the 
					 <guimenu>Details</guimenu> menu of the Contact form. Selecting
					 this menu item will display the following form: 
					 <mediaobject> 
						  <imageobject>
								<imagedata depth="342" fileref="Images\Part3ContactNameHistoryList.bmp"
								 width="475"/> 
						  </imageobject> 
					 </mediaobject></para> 
				<para>Using this technique, the various menus available on a given
					 user-interface can be customized to display whatever information is required.
					 We note that by default, references between views are not enforced by the
					 Dataphor Server.</para> 
				<para>Next, we will use the same technique to embed information
					 directly into the contact user-interface. As part of the contact management
					 system, we will allow the user to enter arbitrary notes about each contact.
					 Rather than just allowing the user to edit the contents of existing notes, we
					 would like to keep a running log of notes as they are entered. In order to
					 accomplish this from the logical perspective, the 
					 <phrase role="code">EnterContactNotes</phrase> view was defined
					 in the Logical Application Design part of this guide. We repeat the definition
					 here in order to discuss the presentation layer aspects: 
					 <programlisting>//* View: EnterContactNotes	
<emphasis role="bold">create view</emphasis> EnterContactNotes
	ContactNotes <emphasis role="bold">add</emphasis> { <emphasis role="bold">nil as</emphasis> Notes NewNotes <emphasis role="bold">tags</emphasis> { DAE.IsComputed = "false" } }
		<emphasis role="bold">over</emphasis> { Contact_ID, NewNotes, Notes }
		<emphasis role="bold">adorn</emphasis> 
		{ 
			NewNotes <emphasis role="bold">tags</emphasis> { Frontend.Title = "Enter Notes" },
			Notes <emphasis role="bold">tags</emphasis> { Frontend.ReadOnly = "true" }
		}
	<emphasis role="bold">tags</emphasis>
	{
		Frontend.Title = "Notes"
	};</programlisting></para> 
				<para>This view definition adds a new column for the notes to be
					 entered. Note that the expression defining the column makes use of the 
					 <phrase role="code"><emphasis
						  role="bold">as</emphasis></phrase> operator. This is necessary because without
					 it, the compiler would have no way of inferring the type of the new
					 column.</para> 
				<para>The 
					 <phrase role="code">DAE.IsComputed</phrase> tag instructs the
					 Dataphor Server not to recompute the value of the column during a change
					 proposable. Without this tag, the value of the 
					 <phrase role="code">NewNotes</phrase> column would be reset to 
					 <phrase role="code">nil</phrase> on every change event.</para> 
				<para>Next, the adorn informs the derivation engine that the old 
					 <phrase role="code">Notes</phrase> column should be displayed
					 with a read only control, and sets the title of the view using the 
					 <phrase role="code">Frontend.Title</phrase> tag.</para> 
				<para>The following reference definition embeds the 
					 <phrase role="code">EnterContactNotes</phrase> view in the
					 singular contact user-interfaces: 
					 <programlisting><emphasis role="bold">create reference</emphasis> EnterContactNotes_Contact
	EnterContactNotes { Contact_ID }
	<emphasis role="bold">references</emphasis> Contact { ID }
	<emphasis role="bold">tags</emphasis>
	{
		Frontend.Visible = "false",
		Frontend.Singular.Embedded = "true"
	};</programlisting></para> 
				<para>Because this reference is an extension from the perspective
					 of the 
					 <phrase role="code">Contact</phrase> table, the 
					 <phrase role="code">Embedded</phrase> tag is false by default.
					 The 
					 <phrase role="code">Visible</phrase> tag on the reference
					 prevents it from showing up on the 
					 <guimenu>Extensions</guimenu> menu, and the 
					 <phrase role="code">Singular.Embedded</phrase> tag tells the
					 derivation engine to in-line the extended information directly in the
					 user-interface. The following screen shot depicts the resulting user-interface:
					 
					 <mediaobject> 
						  <imageobject>
								<imagedata depth="423" fileref="Images\Part3ContactAdd2.bmp" width="325"/> 
						  </imageobject> 
					 </mediaobject></para> 
				<para>Another example of this technique involves the ability to
					 categorize contacts in the Shipping application. As described in the Logical
					 Application Design part of this guide, each contact can be associated with
					 multiple categories. Again, we repeat the definition of the view here: 
					 <programlisting>//* View: ContactCategories
<emphasis role="bold">create view</emphasis> ContactCategories
	Contact { ID } 
		<emphasis role="bold">add </emphasis>
		{ 
			Concat
			(
				{ Description, Delimiter } <emphasis role="bold">from</emphasis> 
				(
					ContactCategory 
						<emphasis role="bold">where</emphasis> Contact_ID = ID 
						<emphasis role="bold">join</emphasis> (Category { ID Category_ID, Description }) 
						<emphasis role="bold">add</emphasis> { ', ' Delimiter }
				)
			) Categories <emphasis role="bold">tags</emphasis> { DAE.IsComputed = "false" }
		}
		<emphasis role="bold">rename</emphasis> { ID Contact_ID }
	<emphasis role="bold">tags</emphasis> 
	{ 
		Frontend.Title = "Categories"
	};</programlisting></para> 
				<para>The resulting view provides a result set with a 
					 <phrase role="code">Categories</phrase> value for each 
					 <phrase role="code">Contact</phrase>, containing a
					 comma-delimited list of the categories associated with that contact. This view
					 is then attached to the 
					 <phrase role="code">Contact</phrase> table as an extension with
					 the following reference definition: 
					 <programlisting><emphasis role="bold">create reference</emphasis> ContactCategories_Contact
	ContactCategories { Contact_ID }
	<emphasis role="bold">references</emphasis> Contact { ID }
	<emphasis role="bold">tags</emphasis>
	{
		Frontend.Include = "false",
		Frontend.Extension.Include = "true",
		Frontend.Extension.Title = "Categories",
		Frontend.Extension.Document = "Form('Sample.Shipping', 'ContactCategoriesEdit')"
	};</programlisting></para> 
				<para>As far as the reference definition itself, this example is
					 the same as the other two. However, this definition uses the 
					 <phrase role="code">Frontend.Extension.Document</phrase> tag to
					 set explicitly the document expression to be used. In this case, a
					 customization is loaded with a call to the 
					 <phrase role="code">Form</phrase> operator. The 
					 <phrase role="code">ContactCategoriesEdit</phrase> form is a
					 customization of an edit form derived from the 
					 <phrase role="code">ContactCategories</phrase> view. The
					 customization simply adds a button to the right of the 
					 <phrase role="code">Categories</phrase> column, and attaches it
					 to a 
					 <phrase role="code">ShowFormAction</phrase> that displays a
					 browse of the 
					 <phrase role="code">ContactCategory</phrase> table. When the
					 category lookup is accepted, the selected category is appended to the current
					 value of the 
					 <phrase role="code">Categories</phrase> column with a
					 delimiting comma if necessary. This provides an edit user-interface for the
					 user to select multiple categories for the contact. This example shows that not
					 only can the reference technique be used to guide user-interface automation for
					 derived user-interfaces, but customized, and even from-scratch forms can be
					 used as well.</para> 
				<para>Now that the user-interfaces for the common portions of the
					 contact structures have been built, we can concentrate on providing the
					 specific user-interfaces for the 
					 <phrase role="code">Customer</phrase> and 
					 <phrase role="code">Vendor</phrase> structures. We start with
					 the 
					 <phrase role="code">Customer</phrase> table by building a view
					 that combines the 
					 <phrase role="code">Contact</phrase> and 
					 <phrase role="code">Customer</phrase> tables: 
					 <programlisting>//* View: CustomerDetail
<emphasis role="bold">create view</emphasis> CustomerDetail
	Contact <emphasis role="bold">join</emphasis> Customer
	<emphasis role="bold">tags</emphasis>
	{
		Frontend.Title = "Customer",
		Frontend.Plural.Title = "Customers"
	};</programlisting></para> 
				<para>In addition to this view definition, there are several
					 references created relating the 
					 <phrase role="code">Customer</phrase> table to the 
					 <phrase role="code">ContactAddress</phrase> table: 
					 <programlisting><emphasis role="bold">create reference</emphasis> Customer_Shipping_CustomerAddress Customer { ID, Shipping_Address_Number } 
	<emphasis role="bold">references</emphasis> ContactAddress { Contact_ID, Number } 
	<emphasis role="bold">tags</emphasis> 
	{ 
		Frontend.Title = "Shipping Address", 
		Frontend.Group.Title = "Shipping",
		Frontend.Group.FlowBreak = "true",
		Frontend.Plural.Embedded = "false"
	};
	
<emphasis role="bold">create reference</emphasis> Customer_Billing_CustomerAddress Customer { ID, Billing_Address_Number } 
	<emphasis role="bold">references</emphasis> ContactAddress { Contact_ID, Number } 
	<emphasis role="bold">tags</emphasis> 
	{ 
		Frontend.Title = "Billing Address", 
		Frontend.Group.Title = "Billing",
		Frontend.Plural.Embedded = "false"
	};</programlisting></para> 
				<para>These references not only set the title and embedded
					 properties for the references, but contain the 
					 <phrase role="code">Frontend.Group</phrase> tags that determine
					 how the entire group constructed for the lookups should be handled. The 
					 <phrase role="code">Frontend.Group.FlowBreak</phrase> tag
					 applies a flow break to the shipping address group, resulting in the following
					 user-interface: 
					 <mediaobject> 
						  <imageobject>
								<imagedata depth="594" fileref="Images\Part3ContactAdd3.bmp" width="621"/> 
						  </imageobject> 
					 </mediaobject></para> 
				<para>Notice in particular that the effect of the references is
					 cumulative. The user-interface not only includes the address references
					 introduced for the customer, but also the primary phone reference, history list
					 references, notes edit, and categories edit introduced for the contact. In
					 addition, because this is still a purely derived user-interface, the effects of
					 changes to the base contact structures will be immediately reflected in the
					 customer user-interfaces.</para> 
				<para>One other point to be made in connection with this
					 user-interface is that the 
					 <phrase role="code">Address</phrase> groups within the 
					 <phrase role="code">Shipping</phrase> and 
					 <phrase role="code">Billing</phrase> groups is defined with 
					 <phrase role="code">Frontend.Group</phrase> tags on the columns
					 of the 
					 <phrase role="code">ContactAddress</phrase> table. The 
					 <phrase role="code">Billing</phrase> and 
					 <phrase role="code">Shipping</phrase> groups are constructed
					 automatically by derivation because of the lookup references, and the columns
					 to be included are specified using the 
					 <phrase role="code">Frontend.Preview.Include</phrase> tag on
					 the columns of the 
					 <phrase role="code">ContactAddress</phrase> table. This example
					 shows the flexibility of using tags defined on columns to define user-interface
					 characteristics; even though the tags appear on completely separate tables,
					 they still affect the appearance of the customer user-interface. This level of
					 flexibility and power is only possible because of the rich structural inference
					 capabilities of the Dataphor Server.<!--Too marketese? It's true though!--></para>
				
				<para>We turn now to the vendor structures. Again, we begin by
					 defining the 
					 <phrase role="code">VendorDetail</phrase> view that combines
					 both the 
					 <phrase role="code">Contact</phrase> and 
					 <phrase role="code">Vendor</phrase> tables: 
					 <programlisting>//* View: VendorDetail
<emphasis role="bold">create view</emphasis> VendorDetail
	Contact <emphasis role="bold">join</emphasis> Vendor
		{
			ID, 
			Name, 
			NameSince, 
			NameBy, 
			Primary_PhoneType_ID, 
			ShippingRate, 
			Primary_Address_Number
		}
	<emphasis role="bold">static tags</emphasis>
	{
		Frontend.Title = "Vendor",
		Frontend.Plural.Title = "Vendors"
	};</programlisting></para> 
				<para>Given this view definition, we obtain the following
					 user-interface: 
					 <mediaobject> 
						  <imageobject>
								<imagedata depth="637" fileref="Images\Part3VendorAdd1.bmp" width="326"/> 
						  </imageobject> 
					 </mediaobject></para> 
				<para>Again, although functional, this user-interface is too long
					 vertically, and would be much more cosmetically appealing if the information
					 were distributed more evenly horizontally. To accomplish this, we will modify
					 the definition of the 
					 <phrase role="code">VendorDetail</phrase> view with an 
					 <phrase role="code"><emphasis
						  role="bold">adorn</emphasis></phrase> operator that will place the name, phone,
					 and shipping rate information into a group to the left of the primary address: 
					 <programlisting>//* View: VendorDetail
<emphasis role="bold">create view</emphasis> VendorDetail
	Contact <emphasis role="bold">join</emphasis> Vendor
		{
			ID, 
			Name, 
			NameSince, 
			NameBy, 
			Primary_PhoneType_ID, 
			ShippingRate, 
			Primary_Address_Number
		}
		<emphasis role="bold">adorn</emphasis>
		{
			ID <emphasis role="bold">tags</emphasis> { Frontend.Group = "Vendor" },
			Name <emphasis role="bold">tags</emphasis> { Frontend.Group = "Vendor" },
			Primary_PhoneType_ID <emphasis role="bold">tags</emphasis> { Frontend.Group = "Vendor" },
			<emphasis role="bold">alter reference</emphasis> Contact_ContactPhone 
				<emphasis role="bold">alter tags</emphasis> { <emphasis role="bold">create</emphasis> Frontend.Group = "Vendor" },
			ShippingRate <emphasis role="bold">tags</emphasis> { Frontend.Group = "Vendor" }
		}
	<emphasis role="bold">static tags</emphasis>
	{
		Frontend.Group.Vendor.FlowBreak = "true",
		Frontend.Title = "Vendor",
		Frontend.Plural.Title = "Vendors"
	};</programlisting></para> 
				<para>Note in particular the usage of the 
					 <phrase role="code"><emphasis role="bold">alter
						  reference</emphasis></phrase> clause of the adorn operator to add a tag to the
					 inferred reference 
					 <phrase role="code">Contact_ContactPhone</phrase>. This
					 technique can be used to alter the treatment of a particular reference within
					 the derivation engine for a given view without affecting the treatment of that
					 reference in the rest of the application schema. In other words, the adornment
					 here applies only to the inferred structural information, it does not affect
					 the global 
					 <phrase role="code">Contact_ContactPhone</phrase> reference.
					 The inferred reference is named the same as the global reference on which it is
					 based for ease of reference only. To determine the name of an inferred
					 reference, and what references have been inferred for a given expression, use
					 the 
					 <ulink type="olinka"
					 url="O-System.Diagnostics.ShowPlan.html"><phrase
						  role="code">ShowPlan</phrase></ulink> operator.</para> 
				<para>The inferred 
					 <phrase role="code">Contact_ContactPhone</phrase> reference is
					 marked with the 
					 <phrase role="code">Frontend.Group</phrase> tag to place it
					 within the vendor group in the resulting user-interface. The vendor group is
					 then tagged with a 
					 <phrase role="code">FlowBreak</phrase> and the resulting
					 user-interface now has a much better horizontal distribution: 
					 <mediaobject> 
						  <imageobject>
								<imagedata depth="490" fileref="Images\Part3VendorAdd2.bmp" width="512"/> 
						  </imageobject> 
					 </mediaobject></para> 
				<para>As a final addition to the vendor user-interface, we will
					 embed the inventory types which the vendor supplies as a detail of the vendor
					 user-interfaces: 
					 <programlisting><emphasis role="bold">create reference</emphasis> VendorItemType_Vendor 
	VendorItemType { Vendor_ID } 
	<emphasis role="bold">references</emphasis> Vendor { ID } 
	<emphasis role="bold">tags</emphasis> { Frontend.Detail.Embedded = "true" };</programlisting></para> 
				<para>The 
					 <phrase role="code">Frontend.Detail.Embedded</phrase> tag
					 instructs the derivation engine that this reference should be embedded on all
					 vendor user-interfaces, plural and singular. The following screenshot depicts
					 the final add vendor user-interface: 
					 <mediaobject> 
						  <imageobject>
								<imagedata depth="696" fileref="Images\Part3VendorAdd3.bmp" width="513"/> 
						  </imageobject> 
					 </mediaobject></para> 
				<para>Note that the supplies detail is slimmer vertically than a
					 standard embedded detail would be. This is because the 
					 <phrase role="code">VendorItemType</phrase> table is tagged
					 with a 
					 <phrase role="code">Frontend.Grid.RowCount</phrase> of 5,
					 rather than the default 10. This tag can be used to set the number of rows
					 appearing in a derived plural user-interface.</para> 
				<para>This is the extend of the customization required for the
					 contact, customer, and vendor management user-interfaces. Again, we have built
					 the entire presentation layer with a few simple adornments, and only a single
					 customized user-interface. The more the presentation layer is based solely on
					 the application schema, the more insulated the application will be during
					 subsequent maintenance cycles.</para> 
		  </sect1> 
		  <sect1 id="DDGPuttingItAllTogether-InvoiceManagement"> 
				<title>Invoice Management</title> 
				<para>Now we reach the heart of the Shipping application: Invoice
					 Management. This is the portion of the application that actually tracks
					 customer orders, purchase orders, and shipping and receiving. Most of the
					 processes required here were built during the Logical Application Design part
					 of this guide, but we will repeat the necessary portions for
					 completeness.</para> 
				<para>We begin the discussion with the sale order entry
					 user-interface. As with the other user-interfaces, we will build this form by
					 constructing adorned views and references. As a starting point, consider the
					 type of user-interface we want to end up with: what data can be provided
					 automatically by the system, and what data must be entered by the user? As part
					 of the order entry system, we could provide the ability to select a
					 <emphasis>current</emphasis> location. This would prevent the user from having
					 to enter the location for the invoice each time, as well as prevent possible
					 entry mistakes by selecting the wrong location. The only other piece of
					 information required for a sale order that could not be provided automatically
					 is the customer, and the line item types and quantities.</para> 
				<para>As a first step, we will construct the structures required to
					 track the current location, and the user-interface for selecting it. Rather
					 than store which location a user is logged in to as a permanent fixture of the
					 global database, we will use <emphasis>session</emphasis> tables to track the
					 information temporarily with the session. The user will be required to select a
					 current location prior to entering any sale order, and that information will be
					 maintained with the current session.</para> 
				<para>The following operator definition ensures that the 
					 <phrase role="code">CurrentLocation</phrase> session table has
					 been constructed: 
					 <programlisting>//* Operator: EnsureCurrentLocationTable
<emphasis role="bold">create operator</emphasis> EnsureCurrentLocationTable()
<emphasis role="bold">begin</emphasis>
	<emphasis role="bold">if not</emphasis>(ObjectExists('CurrentLocation')) <emphasis role="bold">then</emphasis>
		Execute
		(
			'
				create session table CurrentLocation { Location_ID : LocationID, key { } };
				create session reference CurrentLocation_Location 
					CurrentLocation { Location_ID } 
					references Location { ID }
					tags 
					{ 
						Frontend.Include = "false", 
						Frontend.Lookup.Include = "true", 
						Frontend.Lookup.Title = "Current Location" 
					};
			'
		);
<emphasis role="bold">end</emphasis>;</programlisting></para> 
				<para>This operator creates the session table 
					 <phrase role="code">CurrentLocation</phrase>, as well as a
					 reference from 
					 <phrase role="code">CurrentLocation</phrase> to the 
					 <phrase role="code">Location</phrase> table in the global
					 catalog. Note that this reference is allowed because it is referencing from a
					 session table to a global table. The other direction would not be allowed,
					 because the session table has a shorter scope than the global table. Despite
					 the fact that these are session-specific objects, they can still be used as the
					 input to user-interface derivation. As a result, the user-interface for
					 selecting a current location is simply a derived edit on the 
					 <phrase role="code">CurrentLocation</phrase> session
					 table.</para> 
				<para>Once a current location has been selected, the sale order
					 entry system must be able to access the information. For this purpose, we
					 provide the 
					 <phrase role="code">CurrentLocationID()</phrase> operator: 
					 <programlisting>//* Operator: CurrentLocationID()
<emphasis role="bold">create operator</emphasis> CurrentLocationID() : LocationID
<emphasis role="bold">begin</emphasis>
	<emphasis role="bold">result</emphasis> := 
		(
			Evaluate('CurrentLocation[].Location_ID')
				<emphasis role="bold">with</emphasis> { IsFunctional = "true", IsDeterministic = "true", IsRepeatable = "true" }
		)
			<emphasis role="bold">as</emphasis> LocationID;
<emphasis role="bold">end</emphasis>
	<emphasis role="bold">tags</emphasis> { DAE.ShouldTranslate = "false" };</programlisting></para> 
				<para>For a more in-depth discussion of this operator, refer to the
					 
					 <ulink type="olinka"
					 url="DDGModelingProcessLogic-Session-SpecificObjects.html">Session-Specific
						  Objects</ulink> discussion in the Logical Application Design part of this
					 guide. For this discussion, we remark only that the operator includes a 
					 <phrase role="code">DAE.ShouldTranslate</phrase> tag
					 instructing the Dataphor Server that this operator should not be translated
					 into an application transaction because it is not necessary.</para> 
				<para>With the 
					 <phrase role="code">CurrentLocationID()</phrase> defined, we
					 are now ready to build the actual sale order entry user-interface. As with many
					 Dataphor user-interfaces, it is based on a view definition: 
					 <programlisting>//* View: SaleOrderEntry
<emphasis role="bold">create view</emphasis> SaleOrderEntry
	Invoice <emphasis role="bold">join</emphasis> SaleOrder
		<emphasis role="bold">adorn</emphasis>
		{
			Location_ID { <emphasis role="bold">default</emphasis> CurrentLocationID() } 
				<emphasis role="bold">tags</emphasis> { Frontend.Add.Visible = "false", Frontend.Edit.Visible = "false" },
			Customer_ID <emphasis role="bold">tags</emphasis> { Frontend.Title = "Customer #" },
			<emphasis role="bold">drop reference</emphasis> Invoice_InvoiceStatus,
			<emphasis role="bold">drop reference</emphasis> Invoice_User,
			<emphasis role="bold">drop reference</emphasis> SaleOrder_Customer,
			<emphasis role="bold">drop reference</emphasis> PurchaseOrder_Invoice,
			<emphasis role="bold">drop reference</emphasis> InvoiceItem_Invoice
		}
	<emphasis role="bold">tags</emphasis>
	{
		Frontend.Title = "Sale Order"
	};
		
<emphasis role="bold">create reference</emphasis> SaleOrderEntry_CustomerDetail
	SaleOrderEntry { Customer_ID }
		<emphasis role="bold">references</emphasis> CustomerDetail { ID };</programlisting></para> 
				<para>This view definition combines the 
					 <phrase role="code">Invoice</phrase> and 
					 <phrase role="code">SaleOrder</phrase> tables using a natural
					 join. The existing metadata from both tables is inferred, so very little
					 adornment is required. The 
					 <phrase role="code">Location_ID</phrase> is defaulted to the 
					 <phrase role="code">CurrentLocationID()</phrase> operator
					 created above, and the column is marked invisible. The 
					 <phrase role="code">Customer_ID</phrase> column is given a
					 title, and several references are removed. It is important to note that only
					 the inferred reference metadata are being removed here. The global reference
					 constraint definitions are unaffected by this view definition.</para> 
				<para>The resulting user-interface is clean and simple: 
					 <mediaobject> 
						  <imageobject>
								<imagedata depth="218" fileref="Images\Part3SaleOrderAdd1.bmp" width="325"/> 
						  </imageobject> 
					 </mediaobject></para> 
				<para>Next, we add the user-interface for the line-items. Each
					 line-item will have an item type, a quantity, a price, and a total. The
					 following view definition gives us this user-interface: 
					 <programlisting>//* View: SaleOrderItem
// Sale order line item entry
<emphasis role="bold">create view</emphasis> SaleOrderItem
	InvoiceItem 
		<emphasis role="bold">add</emphasis> { Quantity * Amount LineTotal }
		<emphasis role="bold">adorn</emphasis> 
		{ 
			Number <emphasis role="bold">tags</emphasis> { Frontend.ReadOnly = "true" },
			Quantity <emphasis role="bold">tags</emphasis> { Frontend.FlowBreak = "true" },
			Amount <emphasis role="bold">tags</emphasis> { Frontend.FlowBreak = "true" },
			LineTotal <emphasis role="bold">tags</emphasis> { Frontend.Title = "Line Total" },
			<emphasis role="bold">drop reference</emphasis> InvoiceItem_ItemType 
		}
	<emphasis role="bold">tags</emphasis>
	{
		Frontend.Title = "Order Item",
		Frontend.Plural.Title = "Order Items"
	};
		
<emphasis role="bold">create reference</emphasis> SaleOrderItem_SaleOrder
	SaleOrderItem { Invoice_ID } <emphasis role="bold">references</emphasis> SaleOrder { ID }
	<emphasis role="bold">tags</emphasis>
	{
		Frontend.Detail.Embedded = "true"
	};</programlisting></para> 
				<para>The reference definition then embeds the line-item detail
					 into the sale order entry user-interface: 
					 <mediaobject> 
						  <imageobject>
								<imagedata depth="518" fileref="Images\Part3SaleOrderAdd2.bmp" width="690"/> 
						  </imageobject> 
					 </mediaobject></para> 
				<para>In addition to providing the plural detail user-interface,
					 the above view definition provides the singular item entry user-interface.
					 However, before it is complete, we have to provide for the lookup to the
					 inventory. Note that the inferred reference for 
					 <phrase role="code">InvoiceItem_ItemType</phrase> was removed
					 from the view definition. This was done to make room for a lookup based on the
					 currently selected location. This will allow us to limit the set of inventory
					 items available for selection on a sale order to the inventory items available
					 for the current location. The following view and reference definitions provide
					 this piece: 
					 <programlisting>//* View: LocationItemType
<emphasis role="bold">create view</emphasis> LocationItemType
	LocationItem 
		<emphasis role="bold">where</emphasis> Location_ID = CurrentLocationID()
		{ ItemType_ID ID }
		<emphasis role="bold">join</emphasis> ItemType
		<emphasis role="bold">adorn</emphasis>
		{
			Description <emphasis role="bold">tags</emphasis> { Frontend.Preview.Include = "true" }
		}
	<emphasis role="bold">tags</emphasis>
	{
		Frontend.Title = "Item Type",
		Frontend.Plural.Title = "Item Types"
	};
	
<emphasis role="bold">create reference</emphasis> SaleOrderItem_ItemType
	SaleOrderItem { ItemType_ID } 
	<emphasis role="bold">references</emphasis> LocationItemType { ID };</programlisting></para> 
				<para>With these views and references in place, the line-item entry
					 user-interface becomes: 
					 <mediaobject> 
						  <imageobject>
								<imagedata depth="257" fileref="Images\Part3SaleOrderItemAdd.bmp" width="441"/>
								
						  </imageobject> 
					 </mediaobject></para> 
				<para>The first item to note is that the 
					 <phrase role="code">Number</phrase> column has been given a
					 value of 1. Obviously, we do not want the user to have provide a value for the
					 line-item number, so we provide an operator to compute this value.</para> 
				<para>The 
					 <phrase role="code">GetNextInvoiceItemNumber</phrase> operator
					 increments a line-item generator per invoice and returns the next line-item
					 number. However, we cannot use a default to provide this value because the
					 generator is based on the value of the 
					 <phrase role="code">Invoice_ID</phrase> column, which is not
					 known during the default proposable call.</para> 
				<para>The value for the 
					 <phrase role="code">Invoice_ID</phrase> is set by the Frontend
					 data access layer after the new row is constructed. When this column is set, a
					 change proposable is triggered, so we can attach an event handler to the change
					 event of the 
					 <phrase role="code">Invoice_ID</phrase> column in order to
					 achieve the desired behavior: 
					 <programlisting>//* Operator: InvoiceItemChangeInvoiceID(var typeof(InvoiceItem[])) : Boolean
<emphasis role="bold">create operator</emphasis> InvoiceItemChangeInvoiceID(<emphasis role="bold">var</emphasis> ARow : <emphasis role="bold">typeof</emphasis>(InvoiceItem[])) : Boolean
<emphasis role="bold">begin</emphasis>
	<emphasis role="bold">if</emphasis> IsNil(ARow.Number) <emphasis role="bold">and not</emphasis>(IsNil(ARow.Invoice_ID)) <emphasis role="bold">then</emphasis>
	<emphasis role="bold">begin</emphasis>
		ARow.Number := GetNextInvoiceItemNumber(ARow.Invoice_ID);
		<emphasis role="bold">result</emphasis> := <emphasis role="bold">true</emphasis>;
	<emphasis role="bold">end</emphasis>
	<emphasis role="bold">else</emphasis>
		<emphasis role="bold">result</emphasis> := <emphasis role="bold">false</emphasis>;
<emphasis role="bold">end</emphasis>;
<emphasis role="bold">attach operator</emphasis> InvoiceItemChangeInvoiceID 
	<emphasis role="bold">to</emphasis> Invoice_ID <emphasis role="bold">in</emphasis> InvoiceItem 
	<emphasis role="bold">on change</emphasis>;</programlisting></para> 
				<para>In addition to providing a value for the 
					 <phrase role="code">Number</phrase> column, we can
					 automatically provide a value for the 
					 <phrase role="code">Amount</phrase> column by looking up the 
					 <phrase role="code">Price</phrase> of the item at the current
					 location. The following event handler provides this behavior: 
					 <programlisting>//* Operator: InvoiceItemChangeItemTypeID(var typeof(InvoiceItem[])) : Boolean
<emphasis role="bold">create operator</emphasis> InvoiceItemChangeItemTypeID(<emphasis role="bold">var</emphasis> ARow : <emphasis role="bold">typeof</emphasis>(InvoiceItem[])) : Boolean
<emphasis role="bold">begin</emphasis>
	<emphasis role="bold">if not</emphasis>(IsNil(ARow.ItemType_ID)) <emphasis role="bold">then</emphasis>
	<emphasis role="bold">begin</emphasis>
		ARow.Amount := LocationItem[CurrentLocationID(), ARow.ItemType_ID].Price;
		<emphasis role="bold">result</emphasis> := <emphasis role="bold">true</emphasis>;
	<emphasis role="bold">end</emphasis>
	<emphasis role="bold">else</emphasis>
		<emphasis role="bold">result</emphasis> := <emphasis role="bold">false</emphasis>;
<emphasis role="bold">end</emphasis>;
<emphasis role="bold">attach operator</emphasis> InvoiceItemChangeItemTypeID 
	<emphasis role="bold">to</emphasis> ItemType_ID <emphasis role="bold">in</emphasis> InvoiceItem 
	<emphasis role="bold">on change</emphasis>;</programlisting></para> 
				<para>This operator uses the newly entered value of the 
					 <phrase role="code">ItemType_ID</phrase> column along with the 
					 <phrase role="code">CurrentLocationID()</phrase> operator to
					 lookup the 
					 <phrase role="code">Price</phrase> for the given item type at
					 the current location. The 
					 <phrase role="code">Amount</phrase> column is then set to this
					 amount. Note also that because the 
					 <phrase role="code">LineTotal</phrase> column is automatically
					 computed in response to changes in the row, it does not matter whether the 
					 <phrase role="code">Quantity</phrase> column is set first, the
					 total for the line will be recomputed in response to either an item type
					 change, which sets the price, or a quantity change.</para> 
				<para>Now that the order entry user-interfaces are complete, we can
					 move on to the purchasing user-interfaces. These will be much less involved
					 from the user-interface perspective, as all the information required to
					 complete a purchase order is already available based on inventory levels and
					 vendor information in the system.</para> 
				<para>As such, the user-interface will involve simply generating a
					 set of bids, deciding which bid should become a purchase order, and processing
					 it. The first step in producing this user-interface is to build the operator
					 that will construct the purchase orders. We begin by defining a view that will
					 provide a listing of the item types that need to be ordered for each location: 
					 <programlisting>//* View: LocationItemsToOrder
<emphasis role="bold">create view</emphasis> LocationItemsToOrder
	LocationItem 
		<emphasis role="bold">add</emphasis> { OnHand + OnPurchase ProjectedOnHand }
		<emphasis role="bold">add</emphasis> 
		{ 
			(<emphasis role="bold">if</emphasis> ProjectedOnHand &lt; OnOrder <emphasis role="bold">then</emphasis> OnOrder - ProjectedOnHand <emphasis role="bold">else</emphasis> 0d) RequiredOnHand,
			(<emphasis role="bold">if</emphasis> ProjectedOnHand &lt; Par <emphasis role="bold">then</emphasis> Par - ProjectedOnHand <emphasis role="bold">else</emphasis> 0d) SuggestedOnHand
		}
		<emphasis role="bold">add</emphasis> { RequiredOnHand + SuggestedOnHand ToOrder }
		<emphasis role="bold">where</emphasis> ToOrder &gt; 0
		<emphasis role="bold">over</emphasis> { Location_ID, ItemType_ID, ToOrder }
	<emphasis role="bold">tags</emphasis>
	{
		Frontend.Title = "Inventory To Order"
	};</programlisting></para> 
				<para>Next, we define a view that uses the 
					 <phrase role="code">LocationItemsToOrder</phrase> view to
					 provide a listing of all vendors that supply the required item, the cost
					 charged by the vendor, as well as the shipping cost based on the distance
					 between the location and the vendor: 
					 <programlisting>//* View: SupplyingVendors
<emphasis role="bold">create view</emphasis> SupplyingVendors
	VendorItemType 
		<emphasis role="bold">join</emphasis> (Vendor rename { ID Vendor_ID })
		<emphasis role="bold">join</emphasis> (ContactAddress { Contact_ID Vendor_ID, Number Primary_Address_Number, ZipCode Source_ZipCode })
		<emphasis role="bold">join</emphasis> (ZipCode { ZipCode Source_ZipCode, Coordinate Source_Coordinate })
		<emphasis role="bold">join</emphasis> LocationItemsToOrder
		<emphasis role="bold">join</emphasis> (Location { ID Location_ID, ZipCode Target_ZipCode })
		<emphasis role="bold">join</emphasis> (ZipCode { ZipCode Target_ZipCode, Coordinate Target_Coordinate })
		<emphasis role="bold">add</emphasis> { Distance(Source_Coordinate, Target_Coordinate) Shipping_Distance }
		<emphasis role="bold">add</emphasis> { ShippingRate * Shipping_Distance Shipping_Cost }
		<emphasis role="bold">add</emphasis> { (Cost * ToOrder) + Shipping_Cost Total_Cost }
		<emphasis role="bold">over</emphasis> { Vendor_ID, Location_ID, ItemType_ID, ToOrder, Cost, Shipping_Cost, Total_Cost }
	{
		<emphasis role="bold">order</emphasis> { Vendor_ID, Location_ID, ItemType_ID, Total_Cost <emphasis role="bold">desc</emphasis> }
	}
	<emphasis role="bold">static tags</emphasis>
	{
		Frontend.Title = "Supplying Vendor",
		Frontend.Plural.Title = "Supplying Vendors"
	};</programlisting></para> 
				<para>This view is somewhat involved, so we will provide a rough
					 English translation for the operation: 
					 <orderedlist> 
						  <listitem> 
								<para>Get the set of vendors together with the item
									 types they supply,</para> 
						  </listitem> 
						  <listitem> 
								<para>Retrieve the vendor information for each
									 vendor,</para> 
						  </listitem> 
						  <listitem> 
								<para>Retrieve the address information for the primary
									 address of each vendor,</para> 
						  </listitem> 
						  <listitem> 
								<para>Retrieve the coordinate for the zipcode of each
									 vendor address,</para> 
						  </listitem> 
						  <listitem> 
								<para>Combine this information with the quantity needed
									 for each item type at each location,</para> 
						  </listitem> 
						  <listitem> 
								<para>Retrieve the zipcode for each location,</para> 
						  </listitem> 
						  <listitem> 
								<para>Retrieve the coordinate for the zipcode of each
									 location,</para> 
						  </listitem> 
						  <listitem> 
								<para>Compute the distance between the vendor and the
									 location for each row,</para> 
						  </listitem> 
						  <listitem> 
								<para>Compute the shipping cost for each row, based on
									 the distance and shipping rate for the vendor,</para> 
						  </listitem> 
						  <listitem> 
								<para>Compute the total cost of filling the order for
									 each item type for each location based on the quantity required, the cost of
									 the item type as supplied by the vendor, and the shipping cost for the
									 vendor,</para> 
						  </listitem> 
						  <listitem> 
								<para>Project over the interesting columns.</para> 
						  </listitem> 
					 </orderedlist></para> 
				<para>Next, the 
					 <phrase role="code">LocationItemsToOrder</phrase> and 
					 <phrase role="code">SupplyingVendors</phrase> views are used in
					 the 
					 <phrase role="code">CreateBidItems</phrase> operator to
					 populate the 
					 <phrase role="code">BidItem</phrase> table with a row for each
					 location and item type with the vendor providing the lowest cost solution to
					 fill the required order: 
					 <programlisting><emphasis role="bold">create operator</emphasis> CreateBidItems(<emphasis role="bold">const</emphasis> ALocationID : LocationID)
<emphasis role="bold">begin</emphasis>
	<emphasis role="bold">delete</emphasis> BidItem <emphasis role="bold">where</emphasis> Location_ID = ALocationID;
	<emphasis role="bold">insert</emphasis>
		LocationItemsToOrder
			<emphasis role="bold">where</emphasis> Location_ID = ALocationID
			<emphasis role="bold">rename</emphasis> { Location_ID ToOrder_Location_ID, ItemType_ID ToOrder_ItemType_ID }
			<emphasis role="bold">where exists</emphasis> (VendorItemType where ItemType_ID = ToOrder_ItemType_ID)
			<emphasis role="bold">add</emphasis> 
			{ 
				(
					SupplyingVendors 
						<emphasis role="bold">where</emphasis> Location_ID = ToOrder_Location_ID <emphasis role="bold">and</emphasis> ItemType_ID = ToOrder_ItemType_ID 
						<emphasis role="bold">return</emphasis> 1 <emphasis role="bold">by</emphasis> { Total_Cost <emphasis role="bold">desc</emphasis>, Vendor_ID }
				)[].Vendor_ID Vendor_ID 
			}
			<emphasis role="bold">join</emphasis> (Vendor rename { ID Vendor_ID } <emphasis role="bold">over</emphasis> { Vendor_ID, ShippingRate })
			<emphasis role="bold">rename</emphasis> { ToOrder_Location_ID Location_ID, ToOrder_ItemType_ID ItemType_ID }
			<emphasis role="bold">join</emphasis> VendorItemType
			<emphasis role="bold">over</emphasis> { Location_ID, ItemType_ID, Vendor_ID, ToOrder }
			<emphasis role="bold">rename</emphasis> { ToOrder Quantity }
		<emphasis role="bold">into</emphasis> BidItem;
<emphasis role="bold">end</emphasis>;</programlisting></para> 
				<para>After executing this operator for a given location, the 
					 <phrase role="code">BidItem</phrase> table will be populated
					 with enough information to produce purchase orders for a given location to each
					 supplying vendor in order to fill the required orders at that location. Once
					 all the operators are defined, we can construct the purchasing
					 user-interfaces.</para> 
				<para>The actual purchasing user-interface begins by displaying the
					 set of locations that need to order inventory, either to satisfy par, or to
					 fulfill orders that have been placed by customers over and above the amount
					 currently on hand at a given location. This is accomplished by defining a view
					 that simply projects 
					 <phrase role="code">LocationItemsToOrder</phrase> over the 
					 <phrase role="code">Location_ID</phrase> column: 
					 <programlisting>//* View: LocationsNeedingItems		
<emphasis role="bold">create view</emphasis> LocationsNeedingItems
	LocationItemsToOrder <emphasis role="bold">over</emphasis> { Location_ID }
	<emphasis role="bold">tags</emphasis>
	{
		Frontend.Title = "Locations Needing Inventory"
	};</programlisting></para> 
				<para>Next, we derive a list user-interface based on this view, and
					 customize the resulting user-interface. The customization adds a button to
					 create the bid items for the selected location. Creating the bid items first
					 calls the 
					 <phrase role="code">CreateBidItems</phrase> action, which is a
					 D4 script action that runs the following code: 
					 <programlisting>CreateBidItems(Main.Location_ID);</programlisting>The argument 
					 <phrase role="code">Main.Location_ID</phrase> is available
					 because of the 
					 <phrase role="code">DataArgument</phrase> component attached to
					 the 
					 <phrase role="code">CreateBidItems</phrase> action. The 
					 <phrase role="code">DataArgument</phrase> component allows the
					 columns of the specified 
					 <phrase role="code">Source</phrase> to be referenced by name
					 within the D4 script action.</para> 
				<para>Next, the bid items are displayed by executing the 
					 <phrase role="code">ShowBidItems</phrase> action. If this form
					 is accepted, the 
					 <phrase role="code">CreatePurchaseOrders</phrase> action is
					 executed. In this case, the 
					 <phrase role="code">ShowBidItems</phrase> action is a C# script
					 action, which runs the following C# script: 
					 <programlisting>Host.Session.ExecuteScript
(
	String.Format
	(
		"CreatePurchaseOrders('{0}');", 
		Main["Main.Location_ID"].AsString
	)
);</programlisting>Note that this is simply to illustrate the use of both types
					 of script actions.</para> 
				<para>The main source is then refreshed (because the 
					 <phrase role="code">AfterExecute</phrase> of the 
					 <phrase role="code">CreatePurchaseOrders</phrase> is set to the
					 
					 <phrase role="code">Refresh</phrase> action for the form), and
					 the location no longer appears on the list, having all required inventory on
					 order.</para> 
				<para>The next set of user-interfaces to build for the Shipping
					 application surround the processing of invoices. There are three types of
					 processing to be done: order approval, shipping, and receiving. Each of these
					 user-interfaces is a simple customization to a derived list form for some view.
					 As such, we will only discuss order approval.</para> 
				<para>We begin by defining the view 
					 <phrase role="code">SaleOrdersToProcess</phrase> which will
					 form the basis for the user-interface: 
					 <programlisting>//* View: SaleOrdersToProcess
<emphasis role="bold">create view</emphasis> SaleOrdersToProcess
	SaleOrderEntry
		<emphasis role="bold">where</emphasis> Status_ID = "NEW";</programlisting></para> 
				<para>This view definition simply selects sale orders that have not
					 yet been processed. Notice that the 
					 <phrase role="code">SaleOrderEntry</phrase> view is used to
					 take advantage of the user-interface elements already defined in that
					 view.</para> 
				<para>A derived list form is then customized to add a button for
					 processing the currently selected invoice. Once the invoice is processed, the
					 main source is refreshed and the invoice no longer appears in the list.</para> 
		  </sect1> 
		  <sect1 id="DDGPuttingItAllTogether-Conclusions"> 
				<title>Conclusions</title> 
				<para>We have now built all the entry points to the application,
					 and simply need to provide a portal, or main form for accessing all the
					 functionality. For this particular application, we will provide a main
					 application form (<phrase role="code">Main</phrase>), a location management
					 form (<phrase role="code">Setup</phrase>), a sales form (<phrase
					 role="code">Sales</phrase>), an inventory management form (<phrase
					 role="code">Inventory</phrase>), and a processing form (<phrase
					 role="code">Processing</phrase>). Each of these forms simply provides links to
					 the various entry points required by the application. In fact, because the
					 functionality in the application is segmented along user roles, each portal
					 form could be exposed as its own application, further simplifying the overall
					 user-interface.</para> 
				<para>Looking back over the tasks performed in building the
					 presentation layer of the Shipping application, we see that most of the
					 development centered around building views. This is only natural, as every
					 user-interface in a database application can be seen as a "view" of the data in
					 the database, at least conceptually. By building the primary definitions of all
					 the user-interfaces for a given application into the application schema, rather
					 than into a client-side executable as traditional RAD platforms do, the
					 Dataphor platform provides a revolutionary paradigm for application development
					 and maintenance. As the application schema evolves, so does the application.<!--More here!--></para>
				
		  </sect1> 
	 </chapter> 
	 <chapter id="DDGTheAutomationofForms"> 
		  <title>The Automation of Forms</title> 
		  <para>Now that we have seen the end-result of Dataphor development, we
				will delve a little deeper into the process of user-interface derivation. By
				default, the user-interfaces produced by this process are quite usable, and in
				general need little modification. However, in order to provide the flexibility
				to produce any kind of user-interface, the derivation process can be guided at
				every step.</para> 
		  <para>This chapter discusses the process of derivation in detail and
				how it can be tailored for specific scenarios through the use of metadata tags.
				These tags can be used at a number of different points during the derivation
				process to steer almost every aspect of a given user-interface
				derivation.</para> 
		  <sect1 id="DDGTheAutomationofForms-GuidingDerivation"> 
				<title><indexterm> 
						  <primary>Guiding Derivation</primary> 
					 </indexterm>Guiding Derivation</title> 
				<para>The derivation engine looks for metadata tags at each step of
					 the process, allowing the developer to specify what the resulting
					 user-interface should look like, without the need to duplicate schema in manual
					 form definitions. Form definitions inherently contain information about the
					 application schema such as column names, data types, and references. By
					 completely deriving form definitions from the application schema, the
					 duplication of this information is entirely avoided. Using derivation, as the
					 application schema changes, so do the resulting user-interfaces.</para> 
				<para>Because metadata is inferred by the compiler, defining the 
					 <phrase role="code">Frontend.Title</phrase> tag on a base table
					 variable will introduce the tag to any expression involving that table
					 variable. In order to prevent this inference from occurring for a specific tag,
					 the 
					 <phrase role="code"><emphasis
						  role="bold">static</emphasis></phrase> keyword can be used to indicate that the
					 compiler should not infer the tag through expressions.</para> 
				<para>To introduce metadata into an expression at any point, the 
					 <phrase role="code"><emphasis
						  role="bold">adorn</emphasis></phrase> operator can be used. This allows derived
					 table variables to be used as the basis for form definitions within the
					 application.</para> 
				<para>Whenever the derivation engine is searching for a specific
					 tag, the following sequence of steps is used:</para> 
				<procedure> 
					 <step> 
						  <para>The tag name qualified with the form type is used,
								i.e. 
								<phrase role="code">Frontend.Add.Title</phrase></para> 
					 </step> 
					 <step> 
						  <para>The tag name qualified with the cardinality of the
								form type is used, i.e. 
								<phrase
								role="code">Frontend.Singular.Title</phrase></para> 
					 </step> 
					 <step> 
						  <para>The tag name itself is used, i.e. 
								<phrase role="code">Frontend.Title</phrase></para> 
					 </step> 
					 <step> 
						  <para>The default value for the tag is used</para> 
					 </step> 
				</procedure> 
				<para>In some cases, the derivation engine will also search for
					 reference type specific tags. In these cases, the following steps are used to
					 find the tag value:</para> 
				<procedure> 
					 <step> 
						  <para>The tag name qualified with the form type and
								reference type is used, i.e. 
								<phrase
								role="code">Frontend.Add.Detail.Title</phrase></para> 
					 </step> 
					 <step> 
						  <para>The tag name qualified with the cardinality of the
								form type and the reference type is used, i.e. 
								<phrase
								role="code">Frontend.Singular.Detail.Title</phrase></para> 
					 </step> 
					 <step> 
						  <para>The tag name qualified with the form type is used,
								i.e. 
								<phrase role="code">Frontend.Add.Title</phrase></para> 
					 </step> 
					 <step> 
						  <para>The tag name qualified with the cardinality of the
								form type is used, i.e. 
								<phrase
								role="code">Frontend.Singular.Title</phrase></para> 
					 </step> 
					 <step> 
						  <para>The tag name qualified with the reference type is
								used, i.e. 
								<phrase
								role="code">Frontend.Detail.Title</phrase></para> 
					 </step> 
					 <step> 
						  <para>The tag name itself is used, i.e. 
								<phrase role="code">Frontend.Title</phrase></para> 
					 </step> 
					 <step> 
						  <para>The default value for the tag is used</para> 
					 </step> 
				</procedure> 
				<para>In addition, the derivation engine makes use of
					 <emphasis>extraction contexts</emphasis> which allow subsets of metadata to be
					 specified by qualifying each tag with a particular qualifier. For example,
					 within the metadata for a table, the metadata for a group can be specified by
					 qualifying each tag with the qualifier 
					 <phrase role="code">Group.&lt;group name&gt;</phrase>. All the
					 tags specified within this context are extracted by removing the extraction
					 qualifier and applying the unqualified tags to the object in question. The
					 derivation engine recognizes the following extraction contexts: 
					 <itemizedlist> 
						  <listitem> 
								<para><phrase role="code">Group.&lt;group
										  name&gt;</phrase></para> 
								<para>When building groups, metadata that should apply
									 to the group is extracted from the table-level metadata for the derivation
									 using this extraction context. Note that backslashes (<phrase
									 role="code">\</phrase>) within 
									 <phrase role="code">&lt;group name&gt;</phrase>
									 will be replaced with qualifiers (<phrase role="code">.</phrase>).</para> 
						  </listitem> 
						  <listitem> 
								<para><phrase role="code">RowExists</phrase></para> 
								<para>When constructing the row exists column for an
									 extension reference, the derivation engine will use the 
									 <phrase role="code">RowExists</phrase> extraction
									 context to extract metadata from the reference metadata.</para> 
						  </listitem> 
						  <listitem> 
								<para><phrase role="code">Modifier</phrase></para> 
								<para>When building the 
									 <phrase role="code"><emphasis role="bold">left
										  join</emphasis></phrase> expression to embed parent, lookup, and extension
									 references into an expression, elaboration will use the 
									 <phrase role="code">Modifier</phrase> extraction
									 context to extract modifiers from the reference metadata.</para> 
						  </listitem> 
						  <listitem> 
								<para><phrase role="code">Group</phrase></para> 
								<para>When building the group for an embedded parent or
									 lookup reference, the derivation engine will use the 
									 <phrase role="code">Group</phrase> extraction
									 context to extract metadata that should apply to the group from the reference
									 metadata.</para> 
						  </listitem> 
						  <listitem> 
								<para><phrase role="code">Grid</phrase></para> 
								<para>When building the 
									 <phrase role="code">Grid</phrase> control for a
									 plural user-interface, the derivation engine will use the 
									 <phrase role="code">Grid</phrase> extraction
									 context to extract metadata that should apply to the grid from the table-level
									 metadata for the derivation.</para> 
								<para>When building grid columns for the 
									 <phrase role="code">Grid</phrase> control in a
									 plural user-interface, the derivation engine will use the 
									 <phrase role="code">Grid</phrase> extraction
									 context to extract metadata that should apply to the grid column from the
									 column metadata.</para> 
						  </listitem>
						  <listitem>
								<para><phrase>Interface</phrase></para>
								<para>When building the root form interface for a
									 user-interface, the derivation engine will use the 
									 <phrase role="code">Interface</phrase> extraction
									 context to extract metadata that should apply to the interface. This context is
									 called Interface rather than 
									 <phrase>FormInterface</phrase> because 
									 <phrase>FormInterface</phrase> is only one type of
									 root interface node; FrameInterface is another.</para>
								<para>This extraction context is useful for setting
									 properties of the interface, such as 
									 <phrase>HelpKeyword</phrase> and 
									 <phrase>IconImage</phrase>.</para>
						  </listitem> 
						  <listitem> 
								<para><phrase role="code">Search</phrase></para> 
								<para>When building the 
									 <phrase role="code">Search</phrase> control for a
									 plural user-interface, the derivation engine will use the 
									 <phrase role="code">Search</phrase> extraction
									 context to extract metadata that should apply to the search from the
									 table-level metadata for the derivation.</para> 
								<para>When building search columns for the 
									 <phrase role="code">Search</phrase> control in a
									 plural user-interface, the derivation engine will use the 
									 <phrase role="code">Search</phrase> extraction
									 context to extract metadata that should apply to the search column from the
									 column metadata.</para> 
						  </listitem>
						  <listitem>
								<para><phrase>Source</phrase></para>
								<para>Properties of the main 
									 <phrase>Source</phrase> component for a
									 user-interface can be set by the 
									 <phrase>Source</phrase> extraction context, such as
									 IsReadOnly as RefreshAfterPost. </para>
						  </listitem> 
						  <listitem> 
								<para><phrase role="code">&lt;element
										  type&gt;</phrase></para> 
								<para>When building column-level controls, the
									 derivation engine will use the 
									 <phrase role="code">&lt;element type&gt;</phrase>
									 extraction context to retrieve metadata that should be passed through
									 derivation directly to the control as properties in the resulting form
									 definition. This works not only directly on columns but anywhere that a control
									 will be built by the derivation engine.</para> 
						  </listitem> 
					 </itemizedlist></para> 
				<para>The following sections will consider in detail what tags are
					 available for guiding the process of derivation at each step.</para> 
				<sect2 id="DDGTheAutomationofForms-GuidingDerivation-Elaboration"> 
					 <title><indexterm> 
								<primary>Elaboration</primary> 
						  </indexterm><indexterm> 
								<primary>Derivation</primary> 
								<secondary>Elaboration</secondary> 
						  </indexterm>Elaboration</title> 
					 <para>As discussed previously, elaboration consists of
						  extending the derivation expression with related information from the database.
						  This is done based on the references that are available to and from the
						  derivation expression.</para> 
					 <para>Recall that we distinguish four types of references,
						  depending on the cardinality of the reference, and the perspective of the
						  reference with respect to the query in the derivation seed: 
						  <itemizedlist> 
								<listitem> 
									 <para>Parent</para> 
								</listitem> 
								<listitem> 
									 <para>Lookup</para> 
								</listitem> 
								<listitem> 
									 <para>Extension</para> 
								</listitem> 
								<listitem> 
									 <para>Detail</para> 
								</listitem> 
						  </itemizedlist></para> 
					 <para>In the following sections, the effect of each type of
						  reference on the user-interface derivation process is considered in detail.
						  Note that if elaboration is not used, these effects will not be seen in the
						  resulting user-interface.</para> 
					 <sect3> 
						  <title><indexterm> 
									 <primary>Parent/Lookup References</primary> 
								</indexterm><indexterm> 
									 <primary>Elaboration</primary> 
									 <secondary>Parent/Lookup References</secondary> 
								</indexterm>Parent/Lookup References</title> 
						  <para>For the purposes of user-interface derivation, parent
								and lookup references are both treated as lookups. The columns of the query
								that participate in the reference are placed in a group, and a lookup control
								is used to allow the column values to be set. If there is only one column
								participating in the reference and it is visible in the user-interface, a 
								<phrase role="code">QuickLookup</phrase> control will
								be used. Otherwise, a 
								<phrase role="code">FullLookup</phrase> control will be
								used, with each column value displayed within the full lookup control using the
								normal control for the column. The 
								<phrase role="code">Frontend.UseFullLookup</phrase> tag
								can be used to force derivation to use a 
								<phrase role="code">FullLookup</phrase> control.</para>
						  
						  <para>Tags that should affect the lookup group can be
								passed through the reference using the 
								<phrase role="code">Group</phrase> extraction context.
								For example, to set the caption of the lookup group, use the tag 
								<phrase role="code">Frontend.Group.Caption</phrase> on
								the reference.</para> 
						  <para>The 
								<phrase role="code">Modifier</phrase> extraction
								context can be used to pass language modifiers through derivation to apply to
								the 
								<phrase role="code"><emphasis
									 role="bold">join</emphasis></phrase> operator used to embed the reference in
								the expression. For example, to specify that a given left join should be a
								detail lookup, use the tag 
								<phrase
								role="code">Frontend.Modifier.IsDetailLookup</phrase>.</para> 
						  <para>Elaboration continues by considering the target table
								variable of the parent or lookup reference as the starting point for another
								elaboration. This sub-elaboration is slightly different in that references are
								not automatically included in the elaboration. The 
								<phrase role="code">Frontend.Elaborate</phrase> tag
								must be explicitly set to true either on the parent or lookup reference, or on
								the target table variable itself in order to force elaboration to occur for the
								target table variable. In addition, the 
								<phrase role="code">Frontend.Include</phrase> tag must
								be explicitly set to true for every reference associated with the target table
								variable that should be followed for the sub-elaboration. This feature is
								particularly useful if the meaningful definition of a target table variable is
								contained within some other table, and the derivation should always include the
								other table variable in derived user-interfaces.</para> 
						  <para>By default, parent and lookup references are
								considered <emphasis>embedded</emphasis>, meaning they are to be included in
								the expression, as well as the user-interface. This behavior can be changed by
								setting the 
								<phrase role="code">Frontend.Embedded</phrase> tag.
								Parent or lookup references are included in the expression using the 
								<phrase role="code"><emphasis role="bold">left
									 lookup</emphasis></phrase> operator. The right argument to this operator is a
								projection of the parent or lookup table variable over the
								<emphasis>included</emphasis> columns. By default, only the key columns of the
								table are included, but this can be changed using the 
								<phrase role="code">Frontend.Include</phrase> tag. Note
								that the 
								<phrase role="code">Preview</phrase> form type is used
								when embedding the parent or lookup table. If the embedding results only in the
								key columns of the reference, the expression is not modified, as the left
								lookup would not bring any new columns into the result set.</para> 
						  <para>In addition to producing lookup controls within the
								user-interface, parent and lookup references appear on the 
								<guimenu>View</guimenu> menu. Each reference is
								displayed as a single menu item, allowing the corresponding row in the lookup
								table variable to be viewed.<!--Example of lookup UI--></para> 
						  <para>The name of this menu item is selected using the
								following steps:</para> 
						  <procedure> 
								<step> 
									 <para>If the title of the reference is specified
										  (using the 
										  <phrase role="code">Frontend.Title</phrase>
										  tag), it is used.</para> 
								</step> 
								<step> 
									 <para>If the title of the parent/lookup table
										  variable is specified (using the 
										  <phrase role="code">Frontend.Title</phrase>
										  tag), it is used.</para> 
								</step> 
								<step> 
									 <para>Otherwise, the unqualified name of the
										  parent/lookup table variable is used.</para> 
								</step> 
						  </procedure> 
						  <para>Note that for the purposes of user-interface, it may
								be desirable to show a parent reference as a join, rather than a lookup. In
								this case, the desired effect can be achieved by using the join expression as
								the derivation query.<!--Example of parent join derivation--></para> 
					 </sect3> 
					 <sect3> 
						  <title><indexterm> 
									 <primary>Extension References</primary> 
								</indexterm><indexterm> 
									 <primary>Elaboration</primary> 
									 <secondary>Extension References</secondary> 
								</indexterm>Extension References</title> 
						  <para>Extension references represent additional information
								about an entity that may or may not be present. By default, extension
								references show up only as menu items in the 
								<guimenu>Extensions</guimenu> menu. Each reference is
								displayed as a single menu item, allowing the extended information to be
								edited.</para> 
						  <para>The name of the menu item is selected using the
								following steps:</para> 
						  <procedure> 
								<step> 
									 <para>If the title of the reference is specified
										  (using the 
										  <phrase role="code">Frontend.Title</phrase>
										  tag), it is used.</para> 
								</step> 
								<step> 
									 <para>If the title of the extension table variable
										  is specified (using the 
										  <phrase role="code">Frontend.Title</phrase>
										  tag), it is used.</para> 
								</step> 
								<step> 
									 <para>Otherwise, the unqualified name of the
										  extension table variable is used.</para> 
								</step> 
						  </procedure> 
						  <para>Extension references can be included in the
								user-interface itself as well by setting the 
								<phrase role="code">Frontend.Embedded</phrase> tag to 
								<phrase role="code">True</phrase>. This results in the
								columns of the extension table being included in the result set, as well as an
								additional column that indicates whether the extension row exists. This
								embedding is accomplished by extending the expression using a 
								<phrase role="code"><emphasis role="bold">left
									 join</emphasis></phrase> operator with an include clause to bring in the row
								exists indicator.<!--Example of embedded extension UI--></para> 
						  <para>As with parent and lookup references, the 
								<phrase role="code">Modifier</phrase> extraction
								context can be used to pass language modifiers to the 
								<phrase role="code"><emphasis
									 role="bold">join</emphasis></phrase> operator used to embed the reference in
								the expression. For example, to specify that a given left join should be a
								detail lookup, use the tag 
								<phrase
								role="code">Frontend.Modifier.IsDetailLookup</phrase>.</para> 
						  <para>Metadata tags that should affect the row exists
								column can be added to the reference definition using the 
								<phrase role="code">RowExists</phrase>. extraction
								context. All tags appearing on the reference and matching the qualifier, either
								explicitly or with the form type qualifier will be added to the include clause
								of the extension. For example, to set the title of the row exists indicator
								from the reference, the tag 
								<phrase role="code">Frontend.RowExists.Title</phrase>
								could be used.</para> 
					 </sect3> 
					 <sect3> 
						  <title><indexterm> 
									 <primary>Detail References</primary> 
								</indexterm><indexterm> 
									 <primary>Elaboration</primary> 
									 <secondary>Detail References</secondary> 
								</indexterm>Detail References</title> 
						  <para>Detail references represent additional information
								about an entity that may have multiple corresponding rows in the detail table
								variable. By default, detail references show up only as menu items in the 
								<guimenu>Details</guimenu> menu. Each reference is
								displayed as a single menu item, allowing the detail information to be
								displayed using a browse.</para> 
						  <para>The name of the menu item is selected using the
								following steps:</para> 
						  <procedure> 
								<step> 
									 <para>If the title of the reference is specified
										  (using the 
										  <phrase role="code">Frontend.Title</phrase>
										  tag), it is used.</para> 
								</step> 
								<step> 
									 <para>If the title of the detail table variable is
										  specified (using the 
										  <phrase role="code">Frontend.Title</phrase>
										  tag), it is used.</para> 
								</step> 
								<step> 
									 <para>Otherwise, the unqualified name of the detail
										  table variable is used.</para> 
								</step> 
						  </procedure> 
						  <para>Detail references can also be included in the
								user-interface itself by setting the 
								<phrase role="code">Frontend.Embedded</phrase> tag to 
								<phrase role="code">True</phrase>. This results in a
								browse of the detail table being embedded in the user-interface directly.
								Because detail references have a different cardinality than the result set of
								the user-interface being derived, they are not embedded into the derivation
								expression, only into the user-interface.<!--Example of embedded detail UI--></para>
						  
					 </sect3> 
					 <sect3> 
						  <title>Guiding Elaboration</title> 
						  <para>This section discusses the various metadata tags that
								can be placed on references to control the process of elaboration.</para> 
						  <sect4> 
								<title><indexterm> 
										  <primary><phrase
												role="code">Frontend.Embedded</phrase></primary> 
										  <secondary>Elaboration And</secondary> 
									 </indexterm><indexterm> 
										  <primary>Elaboration</primary> 
										  <secondary>Frontend.Embedded</secondary> 
									 </indexterm>Frontend.Embedded</title> 
								<para>The 
									 <phrase role="code">Frontend.Embedded</phrase> tag
									 is used to control whether or not a given reference is included in the
									 resulting user-interface, either by directly including the reference in the
									 expression (in the case of parent, lookup, and extension references), or by
									 embedding a plural user-interface for the reference (in the case of detail
									 references).</para> 
								<para>By default, the value of the 
									 <phrase role="code">Frontend.Embedded</phrase> tag
									 is true for parent and lookup references, and false for extension and detail
									 references.</para> 
						  </sect4> 
						  <sect4> 
								<title><indexterm> 
										  <primary><phrase
												role="code">Frontend.Include</phrase></primary> 
										  <secondary>Elaboration And</secondary> 
									 </indexterm><indexterm> 
										  <primary>Elaboration</primary> 
										  <secondary>Frontend.Include</secondary> 
									 </indexterm>Frontend.Include</title> 
								<para>The 
									 <phrase role="code">Frontend.Include</phrase> tag
									 is used in two different ways by elaboration: first, to indicate which columns
									 of a given table variable should be included in the result set, and second, to
									 control whether or not a given reference should be included in the resulting
									 user-interface.</para> 
								<para>For determining the set of columns to be included
									 in the result, the default value is false for the 
									 <phrase role="code">Preview</phrase> form type.
									 When including columns from a lookup table variable, the 
									 <phrase role="code">Preview</phrase> form type is
									 used, and by default, no columns are included. For all other form types, the
									 default value is true, resulting in all columns included in the result
									 set.</para> 
								<para>For determining whether or not a given reference
									 should be included in elaboration, the default value is true, but this
									 determination is also subject to the following conditions: 
									 <itemizedlist> 
										  <listitem> 
												<para>The user requesting the derivation
													 must have select rights for the table variable that will be included by the
													 reference.</para> 
										  </listitem> 
										  <listitem> 
												<para>The reference must not be the
													 <emphasis>inclusion</emphasis> reference used to arrive at this derivation
													 request.</para> 
										  </listitem> 
										  <listitem> 
												<para>The reference must not be a directly
													 circular reference.</para> 
										  </listitem> 
										  <listitem> 
												<para>All the columns of the reference must
													 be included in the result set.</para> 
										  </listitem> 
									 </itemizedlist></para> 
								<para>If any of these conditions are not met, the
									 reference will not be included in the elaboration. The inclusion reference for
									 a given derivation is the source or target reference of the derivation
									 expression that has the same keys as the detail key names specified as part of
									 the derivation seed. A reference is directly circular if it is sourced or
									 targeted in the same table variable under consideration.</para> 
								<para>Note that an included reference may or may not be
									 embedded in the user-interface, but that an excluded reference will not appear
									 anywhere on the resulting user-interface. In other words, the 
									 <phrase role="code">Embedded</phrase> tag controls
									 whether the reference is included as part of the data, while the 
									 <phrase role="code">Include</phrase> tag determines
									 whether the reference is considered by derivation at all.</para> 
								<para>As noted in the discussion of parent and lookup
									 references, the 
									 <phrase role="code">Frontend.Include</phrase> tag
									 can be used in conjunction with the 
									 <phrase role="code">Frontend.Elaborate</phrase> tag
									 to extend the elaboration process to the references associated with the target
									 of a parent or lookup reference.</para> 
						  </sect4> 
						  <sect4> 
								<title><indexterm> 
										  <primary><phrase
												role="code">Frontend.Priority</phrase></primary> 
										  <secondary>Elaboration And</secondary> 
									 </indexterm><indexterm> 
										  <primary>Elaboration</primary> 
										  <secondary>Frontend.Priority</secondary> 
									 </indexterm>Frontend.Priority</title> 
								<para>The 
									 <phrase role="code">Frontend.Priority</phrase> tag
									 is used to control the order in which references encountered in the structural
									 definition of the result set are considered by elaboration. The default value
									 for this tag is 
									 <phrase role="code">0</phrase>, with negative
									 numbers indicating lower priority, meaning they will appear sooner in the
									 user-interface than items with higher priority.</para> 
						  </sect4> 
					 </sect3> 
					 <sect3 id="DDGBuildingtheExpression"> 
						  <title><indexterm> 
									 <primary>Elaboration</primary> 
									 <secondary>Building the Expression</secondary> 
								</indexterm>Building the Expression</title> 
						  <para>As a final step in the elaboration process, the
								derivation engine actually produces the full cursor definition to be used to
								produce the result set for the interface. By default, the cursor definition
								will include an order specification based on the default order determined for
								the derivation expression. This default order is determined using the following
								steps:</para> 
						  <procedure> 
								<step> 
									 <para>The set of orders inferred from the
										  elaborated expression is searched for an order with the 
										  <phrase role="code">Frontend.IsDefault</phrase>
										  tag specified. The first order found with this tag set to true is used.</para> 
								</step> 
								<step> 
									 <para>The set of keys inferred from the elaborated
										  expression is searched for a key with the 
										  <phrase role="code">Frontend.IsDefault</phrase>
										  tag specified. The first key found with this tag set to true is used to
										  construct an order specification.</para> 
								</step> 
								<step> 
									 <para>The clustering key for the elaborated
										  expression is used to construct an order specification. If all the columns of
										  the key are visible, as determined by the 
										  <phrase role="code">Frontend.Visible</phrase>
										  tag, the resulting order is used.</para> 
								</step> 
								<step> 
									 <para>The first key for which all the columns of
										  the key are visible, as determined by the 
										  <phrase role="code">Frontend.Visible</phrase>
										  tag, is used to construct an order specification.</para> 
								</step> 
								<step> 
									 <para>The first order for which all the columns of
										  the order are visible, as determined by the 
										  <phrase role="code">Frontend.Visible</phrase>
										  tag, and the order itself is visible, is used to order the result set.</para> 
								</step> 
								<step> 
									 <para>Otherwise, the order of the result set is
										  undefined, and left up to the Dataphor Server.</para> 
								</step> 
						  </procedure> 
					 </sect3> 
				</sect2> 
				<sect2 id="DDGTheAutomationofForms-GuidingDerivation-Structuring"> 
					 <title><indexterm> 
								<primary>Structuring</primary> 
						  </indexterm><indexterm> 
								<primary>Derivation</primary> 
								<secondary>Structuring</secondary> 
						  </indexterm>Structuring</title> 
					 <para>The primary function of structuring is to construct the
						  definitions for the controls that will be used to display each column in the
						  user-interface, and place those controls in the appropriate groups, as defined
						  by derivation tags, or by inclusion from a parent or lookup reference.</para> 
					 <para>There are three main structures that are built by the
						  structuring step, depending on the type of user-interface being derived:
						  singular structures, plural structures, and search structures.</para> 
					 <sect3 id="DDGRowStructuring"> 
						  <title><indexterm> 
									 <primary>Singular Structuring</primary> 
								</indexterm><indexterm> 
									 <primary>Structuring</primary> 
									 <secondary>Singular Structuring</secondary> 
								</indexterm>Singular Structuring</title> 
						  <para>The singular structure builder constructs a singular
								user-interface with a visual control for each visible column in the result set.
								By default, the type of control constructed is based on the native
								representation of the data type of the column, according to the following
								table: 
								<informaltable> 
									 <tgroup cols="2">
										  <colspec colname="col1" colnum="1" colwidth="*"/>
										  <colspec colname="col2" colnum="2" colwidth="*"/> 
										  <thead> 
												<row> 
													 <entry colname="col1">Native
														  Representation (.NET Framework type)</entry> 
													 <entry colname="col2">Control
														  Type</entry> 
												</row> 
										  </thead> 
										  <tbody> 
												<row> 
													 <entry colname="col1"><phrase
														  role="code">Boolean</phrase></entry> 
													 <entry colname="col2"><phrase
														  role="code">CheckBox</phrase></entry> 
												</row> 
												<row> 
													 <entry colname="col1"><phrase
														  role="code">DateTime</phrase></entry> 
													 <entry colname="col2"><phrase
														  role="code">DateTimeBox</phrase></entry> 
												</row> 
												<row> 
													 <entry colname="col1"><phrase
														  role="code">Decimal</phrase></entry> 
													 <entry colname="col2"><phrase
														  role="code">NumericTextBox</phrase></entry> 
												</row> 
												<row> 
													 <entry colname="col1"><phrase
														  role="code">Int64</phrase></entry> 
													 <entry colname="col2"><phrase
														  role="code">NumericTextBox</phrase></entry> 
												</row> 
												<row> 
													 <entry colname="col1"><phrase
														  role="code">Int32</phrase></entry> 
													 <entry colname="col2"><phrase
														  role="code">NumericTextBox</phrase></entry> 
												</row> 
												<row> 
													 <entry colname="col1"><phrase
														  role="code">Int16</phrase></entry> 
													 <entry colname="col2"><phrase
														  role="code">NumericTextBox</phrase></entry> 
												</row> 
												<row> 
													 <entry colname="col1"><phrase
														  role="code">Byte</phrase></entry> 
													 <entry colname="col2"><phrase
														  role="code">NumericTextBox</phrase></entry> 
												</row> 
												<row> 
													 <entry colname="col1">All
														  others</entry> 
													 <entry colname="col2"><phrase
														  role="code">TextBox</phrase></entry> 
												</row> 
										  </tbody> 
									 </tgroup> 
								</informaltable></para> 
						  <para>The 
								<phrase role="code">Frontend.ElementType</phrase> tag
								specified on the column can be used to control the control type for the
								column.</para> 
						  <para>When a column is included in the result set by a
								parent or lookup reference, that column is placed in a group within the
								resulting user-interface. The title of this group is the title of the
								reference. In addition to determining the group for the column, the reference
								may determine the control to be used to display the column. For example, if the
								column participates in the key of the reference, it will be used to lookup the
								corresponding row from the lookup table. If the column is the only column in
								the reference, a 
								<phrase role="code">QuickLookup</phrase> control will
								be used. Otherwise, a 
								<phrase role="code">FullLookup</phrase> control will be
								used, with all columns participating in the reference, or included by the
								reference, contained within the 
								<phrase role="code">FullLookup</phrase>.</para> 
						  <para>The control type used to perform the lookup can be
								specified on the reference metadata with the 
								<phrase role="code">Frontend.ElementType</phrase> tag.
								In addition, the 
								<phrase role="code">Frontend.UseFullLookup</phrase> tag
								can be specified on the reference to indicate that a full lookup control should
								be used, regardless of whether a 
								<phrase role="code">QuickLookup</phrase> could be used.
								Note that this tag cannot be used to force a multi-column lookup to use a quick
								lookup, only to force a single-column lookup to use a full lookup.</para> 
					 </sect3> 
					 <sect3 id="DDGTableStructuring"> 
						  <title><indexterm> 
									 <primary>Plural Structuring</primary> 
								</indexterm><indexterm> 
									 <primary>Structuring</primary> 
									 <secondary>Plural Structuring</secondary> 
								</indexterm>Plural Structuring</title> 
						  <para>The plural structure builder constructs a plural
								user-interface with a single grid control for displaying the entire result set,
								and a grid column for each visible column in the result set. By default, the
								type of grid column control constructed is based on the native representation
								of the data type of the column, according to the following table: 
								<informaltable> 
									 <tgroup cols="2">
										  <colspec colname="col1" colnum="1" colwidth="*"/>
										  <colspec colname="col2" colnum="2" colwidth="*"/> 
										  <thead> 
												<row> 
													 <entry colname="col1">Native
														  Representation (.NET Framework type)</entry> 
													 <entry colname="col2">Control
														  Type</entry> 
												</row> 
										  </thead> 
										  <tbody> 
												<row> 
													 <entry colname="col1"><phrase
														  role="code">Boolean</phrase></entry> 
													 <entry colname="col2"><phrase
														  role="code">CheckBoxColumn</phrase></entry> 
												</row> 
												<row> 
													 <entry colname="col1">All
														  others</entry> 
													 <entry colname="col2"><phrase
														  role="code">TextColumn</phrase></entry> 
												</row> 
										  </tbody> 
									 </tgroup> 
								</informaltable></para> 
						  <para>The control type of the grid control can be
								controlled using the 
								<phrase role="code">Frontend.Grid.ElementType</phrase>
								tag specified on the derivation expression. The control type of each column
								within the grid can be controlled using the 
								<phrase role="code">Frontend.Grid.ElementType</phrase>
								tag specified on the column.</para> 
						  <para>The title for the columns within the grid that are
								included as a result of parent or lookup references is based on the title of
								the reference, and the title of the column. The tag 
								<phrase role="code">Frontend.IncludeGroupTitle</phrase>
								specified on the reference can be used to indicate that the reference title
								should not be included when constructing the title for the control.</para> 
					 </sect3> 
					 <sect3 id="DDGSearchStructuring"> 
						  <title><indexterm> 
									 <primary>Search Structuring</primary> 
								</indexterm><indexterm> 
									 <primary>Structuring</primary> 
									 <secondary>Search Structuring</secondary> 
								</indexterm>Search Structuring</title> 
						  <para>The search structure builder constructs a search
								control, with search columns for every visible column in the result set that
								participates in a key or order of the result set. By default, the type of
								search column control constructed is a 
								<phrase role="code">SearchColumn</phrase>.</para> 
						  <para>The control type of the search control can be
								controlled using the 
								<phrase
								role="code">Frontend.Search.ElementType</phrase> tag specified on the
								derivation expression. The control type of each column within the search can be
								controlled using the 
								<phrase
								role="code">Frontend.Search.ElementType</phrase> tag specified on the
								column.</para> 
					 </sect3> 
					 <sect3 id="DDGBuildingtheControls"> 
						  <title><indexterm> 
									 <primary>Structuring</primary> 
									 <secondary>Building the Controls</secondary> 
								</indexterm>Building the Controls</title> 
						  <para>In addition to determining the visibility of a
								particular column, and the control type used to represent it, tags can be used
								to set all the properties of the control constructed. There are several common
								properties that are specifically looked for by the derivation engine, as well
								as extraction contexts that can be used to set properties directly. The
								following table lists the specific tags that are used to construct all
								controls: 
								<informaltable> 
									 <tgroup cols="3">
										  <colspec colname="col1" colnum="1" colwidth="*"/>
										  <colspec colname="col2" colnum="2" colwidth="*"/>
										  <colspec colname="col3" colnum="3" colwidth="2*"/> 
										  <thead> 
												<row> 
													 <entry colname="col1">Tag Name</entry> 
													 <entry colname="col2">Context</entry> 
													 <entry
													 colname="col3">Description</entry> 
												</row> 
										  </thead> 
										  <tbody> 
												<row> 
													 <entry colname="col1"><phrase
														  role="code">Title</phrase></entry> 
													 <entry colname="col2">Singular, Plural,
														  Search</entry> 
													 <entry colname="col3">Specifies the
														  title of the control. Note that in a table or search structure builder, the
														  title will be prepended with the title of the reference responsible for the
														  inclusion of the column, if any.</entry> 
												</row> 
												<row> 
													 <entry colname="col1"><phrase
														  role="code">Caption</phrase></entry> 
													 <entry colname="col2">Singular, Plural,
														  Search</entry> 
													 <entry colname="col3">Specifies the
														  caption of the control, allowing the reference title of the inclusion reference
														  to be overridden. If specified, the caption will be used unaffected.</entry> 
												</row> 
												<row> 
													 <entry colname="col1"><phrase
														  role="code">Hint</phrase></entry> 
													 <entry colname="col2">Singular, Plural,
														  Search</entry> 
													 <entry colname="col3">Specifies the
														  hint of the control. The hint provides a more detailed description of the
														  control for the user.</entry> 
												</row> 
												<row> 
													 <entry colname="col1"><phrase
														  role="code">Width</phrase></entry> 
													 <entry colname="col2">Singular, Plural,
														  Search</entry> 
													 <entry colname="col3">Specifies the
														  display width (in characters) of the control. The default value for this tag is
														  twenty (20) characters.</entry> 
												</row> 
												<row> 
													 <entry colname="col1"><phrase
														  role="code">ReadOnly</phrase></entry> 
													 <entry colname="col2">Singular</entry> 
													 <entry colname="col3">Specifies whether
														  or not the control should be read only. The default value for this tag is based
														  on whether the column in the result set is read only. This tag cannot be used
														  to specify that a read only column be marked editable, only that an editable
														  column be marked read only.</entry> 
												</row> 
										  </tbody> 
									 </tgroup> 
								</informaltable></para> 
						  <para>In addition to these common properties, the
								derivation engine will search for tags prefixed with the control type name, and
								pass these tags directly as properties to the control definition. For example,
								in order to set the 
								<phrase role="code">Height</phrase> property of a 
								<phrase role="code">TextBox</phrase> control, the tag 
								<phrase role="code">Frontend.TextBox.Height</phrase>
								can be used.</para> 
						  <para>For column controls in singular structure builders,
								the control type is used as the tag prefix for determining the extraction
								context. Note that the form type may still be used as a qualifier for these
								extraction contexts. For example, to specify that the height of a text box is
								different for an add form, the tag 
								<phrase
								role="code">Frontend.Add.TextBox.Height</phrase> can be used.</para> 
						  <para>For column controls in plural structure builders, the
								
								<phrase role="code">Grid</phrase> qualifier can be used
								to specify that a tag applies only to the control used to display the column
								within a grid. For example, to specify the width of a column within a grid, the
								tag 
								<phrase role="code">Frontend.Grid.Width</phrase> can be
								used. Properties can also be passed through these extraction contexts. For
								example, to specify that a check box column should not be read only, the tag 
								<phrase
								role="code">Frontend.Grid.CheckBoxColumn.ReadOnly</phrase> can be used.</para> 
						  <para>For column controls in search structure builders, the
								
								<phrase role="code">Search</phrase> qualifier can be
								used to specify that a tag applies only to the control used to display the
								column within a search control.</para> 
					 </sect3> 
					 <sect3 id="DDGBuildingtheGroups"> 
						  <title><indexterm> 
									 <primary>Structuring</primary> 
									 <secondary>Building the Groups</secondary> 
								</indexterm>Building the Groups</title> 
						  <para>In addition to constructing the control definitions
								for each visual component of the derived user-interface, structuring is
								responsible for building the group definitions, and determining which group
								each control belongs to. For the table and singular structure builders, this
								grouping only affects the ordering of the columns, but for the singular
								structure builder, the grouping affects the visual containership within the
								resulting form definition.</para> 
						  <para>The group for each column may be specified using the 
								<phrase role="code">Frontend.Group</phrase> tag. Note
								that the value of this tag is used as the default name of the group control
								constructed in the derived user-interface. Whenever a new group definition is
								encountered in a column, the structure builder constructs a new group control
								to represent it.</para> 
						  <para>The name of the group should conform to the same
								rules for identifiers in the D4 language, with the exception that the backslash
								character (<phrase role="code">\</phrase>) is allowed to specify group
								hierarchies. For example, the value 
								<phrase role="code">CustomerInfo\Address</phrase> would
								result in a group named 
								<phrase role="code">CustomerInfo.Address</phrase>
								contained within a group named 
								<phrase role="code">CustomerInfo</phrase>.</para> 
						  <para>As with other types of controls, the various
								properties of the group definition may be controlled using tags. For groups,
								these tags are specified on the derivation expression, and each tag is
								qualified by the name of the group, with backslashes (<phrase
								role="code">\</phrase>) replaced with qualifiers (<phrase
								role="code">.</phrase>).</para> 
					 </sect3> 
				</sect2> 
				<sect2 id="DDGTheAutomationofForms-GuidingDerivation-Layout"> 
					 <title><indexterm> 
								<primary>Layout</primary> 
						  </indexterm><indexterm> 
								<primary>Derivation</primary> 
								<secondary>Layout</secondary> 
						  </indexterm>Layout</title> 
					 <para>The layout step of the derivation process involves
						  determining the visual layout of the controls and groups built by the
						  structuring step. By default, singular derivation simply produces a top to
						  bottom display of all the columns in the result set. Apart from specifying
						  column ordering in the grid of a plural user-interface, layout only applies to
						  singular user-interfaces.</para> 
					 <para>The layout process is based on the notion of
						  <emphasis>flow</emphasis>. Controls flow either horizontally or vertically,
						  which translates directly to the container in which they are placed, 
						  <phrase role="code">Row</phrase> controls for horizontal
						  flow, and 
						  <phrase role="code">Column</phrase> controls for vertical
						  flow. By default, controls flow vertically.</para> 
					 <para>The following table lists the tags that affect the layout
						  process: 
						  <informaltable> 
								<tgroup cols="3">
									 <colspec colname="col1" colnum="1" colwidth="*"/>
									 <colspec colname="col2" colnum="2" colwidth="*"/>
									 <colspec colname="col3" colnum="3" colwidth="2*"/> 
									 <thead> 
										  <row> 
												<entry colname="col1">Tag</entry> 
												<entry colname="col2">Value</entry> 
												<entry colname="col3">Description</entry> 
										  </row> 
									 </thead> 
									 <tbody> 
										  <row> 
												<entry colname="col1"><phrase
													 role="code">Flow</phrase></entry> 
												<entry colname="col2"><phrase
													 role="code">Default | Vertical | Horizontal</phrase></entry> 
												<entry colname="col3">Sets the flow for the
													 layout of controls after this control. Defaults to 
													 <phrase
													 role="code">Default</phrase>.</entry> 
										  </row> 
										  <row> 
												<entry colname="col1"><phrase
													 role="code">FlowBreak</phrase></entry> 
												<entry colname="col2"><phrase
													 role="code">True | False</phrase></entry> 
												<entry colname="col3">Introduces a
													 temporary flow break, causing the next control to flow opposite to the current
													 flow. Defaults to 
													 <phrase
													 role="code">False</phrase>.</entry> 
										  </row> 
										  <row> 
												<entry colname="col1"><phrase
													 role="code">Break</phrase></entry> 
												<entry colname="col2"><phrase
													 role="code">True | False</phrase></entry> 
												<entry colname="col3">Begins a new
													 container based on the current flow, 
													 <phrase role="code">Column</phrase> for
													 vertical flow, 
													 <phrase role="code">Row</phrase> for
													 horizontal flow. Defaults to 
													 <phrase
													 role="code">False</phrase>.</entry> 
										  </row> 
										  <row> 
												<entry colname="col1"><phrase
													 role="code">Priority</phrase></entry> 
												<entry colname="col2"><phrase
													 role="code">&lt;integer&gt;</phrase></entry> 
												<entry colname="col3">Determines the visual
													 order of the control within the group. Note that this priority applies within
													 the group in which the control was placed during structuring. The default value
													 for this tag is 
													 <phrase role="code">0</phrase>.
													 Negative numbers indicate lower priority, meaning the item will appear in the
													 user-interface before items with higher priority.</entry> 
										  </row> 
									 </tbody> 
								</tgroup> 
						  </informaltable></para> 
				</sect2> 
				<sect2 id="DDGTheAutomationofForms-GuidingDerivation-Production"> 
					 <title><indexterm> 
								<primary>Production</primary> 
						  </indexterm><indexterm> 
								<primary>Derivation</primary> 
								<secondary>Production</secondary> 
						  </indexterm>Production</title> 
					 <para>The production step is concerned with actually producing
						  the form definition based on the output of the structuring and layout steps.
						  The actual output of this step is simply an XML document describing the
						  components of the form definition.</para> 
					 <sect3 id="DDGBuildingtheUser-Interface"> 
						  <title>Building the User-Interface</title> 
						  <para>The caption of the user-interface is constructed
								based on the following procedure:</para> 
						  <procedure> 
								<step> 
									 <para>If the 
										  <phrase role="code">Frontend.Caption</phrase>
										  tag is specified at the expression level, it is used directly.</para> 
								</step> 
								<step> 
									 <para>If the 
										  <phrase role="code">Frontend.Title</phrase> tag
										  is specified at the expression level, it is used to construct the caption using
										  the form type of the derivation seed. For example: 
										  <phrase role="code">Add
												Customer</phrase>.</para> 
								</step> 
								<step> 
									 <para>If the expression is a single table variable
										  reference, the unqualified name of the table variable is used to construct the
										  caption, along with the form type of the derivation seed.</para> 
								</step> 
								<step> 
									 <para>Otherwise, the expression itself is used to
										  construct the caption, along with the form type of the derivation seed.</para> 
								</step> 
						  </procedure> 
						  <para>In addition to the component definitions for the
								visual controls of the user-interface, the production step is responsible for
								describing the 
								<phrase role="code">Source</phrase> component that will
								be used to actually communicate with the Dataphor Server instance and retrieve
								and manipulate data. The expression for this source is set to the result of the
								elaboration process. The following tags are also available for setting various
								properties of the 
								<phrase role="code">Source</phrase> that is constructed
								in this step: 
								<informaltable> 
									 <tgroup cols="3">
										  <colspec colname="col1" colnum="1" colwidth="*"/>
										  <colspec colname="col2" colnum="2" colwidth="*"/>
										  <colspec colname="col3" colnum="3" colwidth="2*"/> 
										  <thead> 
												<row> 
													 <entry colname="col1">Tag</entry> 
													 <entry colname="col2">Value</entry> 
													 <entry
													 colname="col3">Description</entry> 
												</row> 
										  </thead> 
										  <tbody> 
												<row> 
													 <entry colname="col1"><phrase
														  role="code">UseBrowse</phrase></entry> 
													 <entry colname="col2"><phrase
														  role="code">True | False</phrase></entry> 
													 <entry colname="col3">Indicates whether
														  the source should use a 
														  <phrase role="code"><emphasis
																role="bold">browse</emphasis></phrase> or 
														  <phrase role="code"><emphasis
																role="bold">order</emphasis></phrase> clause in its cursor definition. Defaults
														  to 
														  <phrase
														  role="code">True</phrase>.</entry> 
												</row> 
												<row> 
													 <entry colname="col1"><phrase
														  role="code">UseApplicationTransactions</phrase></entry> 
													 <entry colname="col2"><phrase
														  role="code">True | False</phrase></entry> 
													 <entry colname="col3">Indicates whether
														  the source should participate in and coordinate application transactions.
														  Defaults to 
														  <phrase
														  role="code">True</phrase>.</entry> 
												</row> 
												<row> 
													 <entry colname="col1"><phrase
														  role="code">ShouldEnlist</phrase></entry> 
													 <entry colname="col2"><phrase
														  role="code">Default | True | False</phrase></entry> 
													 <entry colname="col3">Indicates whether
														  the source should enlist in application transactions begun by mastering
														  sources, recursively. Defaults to 
														  <phrase
														  role="code">Default</phrase></entry> 
												</row> 
												<row> 
													 <entry colname="col1"><phrase
														  role="code">ReadOnly</phrase></entry> 
													 <entry colname="col2"><phrase
														  role="code">True | False</phrase></entry> 
													 <entry colname="col3">Indicates that
														  the source should be read only, and an updatable cursor should not be
														  requested. Defaults to 
														  <phrase
														  role="code">False</phrase>.</entry> 
												</row> 
										  </tbody> 
									 </tgroup> 
								</informaltable></para> 
						  <para>Tags that are qualified with 
								<phrase role="code">Source</phrase> will also be used
								to set properties of the 
								<phrase role="code">Source</phrase> directly. For
								example, to set the 
								<phrase role="code">RequestedIsolation</phrase>
								property of the 
								<phrase role="code">Source</phrase> directly, the tag 
								<phrase
								role="code">Frontend.Source.RequestedIsolation</phrase> could be used.</para> 
					 </sect3> 
					 <sect3 id="DDGBuildingtheMenuandToolbarActions"> 
						  <title>Building the Menu and Toolbar Actions</title> 
						  <para>If elaboration is performed, the resulting
								user-interface will include not only the visual representation of the result
								set, but actions for navigating to related information within the database,
								based on the references involved. Depending on the type of reference being
								exposed, the actions will be placed on different menus, and possibly exposed on
								the tool bar as well. The following tags can be specified on the references in
								question to control this behavior: 
								<informaltable> 
									 <tgroup cols="3">
										  <colspec colname="col1" colnum="1" colwidth="*"/>
										  <colspec colname="col2" colnum="2" colwidth="*"/>
										  <colspec colname="col3" colnum="3" colwidth="2*"/> 
										  <thead> 
												<row> 
													 <entry colname="col1">Tag</entry> 
													 <entry colname="col2">Value</entry> 
													 <entry
													 colname="col3">Description</entry> 
												</row> 
										  </thead> 
										  <tbody> 
												<row> 
													 <entry colname="col1"><phrase
														  role="code">Visible</phrase></entry> 
													 <entry colname="col2"><phrase
														  role="code">True | False</phrase></entry> 
													 <entry colname="col3">Indicates whether
														  the action should appear on a menu within the derived user-interface. The
														  actual menu on which it appears is determined by the reference type. Defaults
														  to 
														  <phrase
														  role="code">True</phrase>.</entry> 
												</row> 
												<row> 
													 <entry colname="col1"><phrase
														  role="code">Exposed</phrase></entry> 
													 <entry colname="col2"><phrase
														  role="code">True | False</phrase></entry> 
													 <entry colname="col3">Indicates whether
														  the action will be exposed on the tool bar. Defaults to 
														  <phrase
														  role="code">False</phrase>.</entry> 
												</row> 
												<row> 
													 <entry colname="col1"><phrase
														  role="code">Secure</phrase></entry> 
													 <entry colname="col2"><phrase
														  role="code">Hidden | Disabled | Visible</phrase></entry> 
													 <entry colname="col3">Indicates how the
														  action should be exposed if the action cannot be performed due to security
														  restrictions. 
														  <phrase
														  role="code">Hidden</phrase>, the default, indicates that the action should not
														  be visible in the resulting user-interface. 
														  <phrase
														  role="code">Disabled</phrase> indicates that the action should be visible, but
														  disabled. 
														  <phrase
														  role="code">Visible</phrase> indicates that the action should appear normally,
														  allowing the user to receive a security error if the action is
														  executed.</entry> 
												</row> 
										  </tbody> 
									 </tgroup> 
								</informaltable></para> 
						  <para>The title for these actions is taken from the
								reference title.</para> 
					 </sect3> 
					 <sect3 id="DDGBuildingDocumentReferences"> 
						  <title><indexterm> 
									 <primary>Document References</primary> 
								</indexterm>Building Document References</title> 
						  <para>Throughout the derivation process, whenever a
								document expression is required, such as the document for a lookup table, or
								the add form for a browse, roughly the same process is used to determine what
								document should be used. The following steps outline this process:</para> 
						  <procedure> 
								<step> 
									 <para>If the document expression is producing a
										  plural form, the 
										  <phrase role="code">Frontend.UseList</phrase>
										  tag is used to indicate whether a 
										  <phrase role="code">Browse</phrase> or 
										  <phrase role="code">List</phrase> form should
										  be constructed. 
										  <phrase role="code">Browse</phrase> forms allow
										  editing, while 
										  <phrase role="code">List</phrase> forms are
										  read only. Although context-specific, the default form type is usually 
										  <phrase role="code">Browse</phrase>.</para> 
								</step> 
								<step> 
									 <para>If the 
										  <phrase role="code">Frontend.Document</phrase>
										  tag is specified, it is used as the document reference. The form type
										  determined above is used to search for this tag.</para> 
								</step> 
								<step> 
									 <para>The form type is then used to search for the
										  following tags: 
										  <itemizedlist> 
												<listitem> 
													 <para><phrase
														  role="code">Frontend.Query</phrase></para> 
												</listitem> 
												<listitem> 
													 <para><phrase
														  role="code">Frontend.MasterKeyNames</phrase></para> 
												</listitem> 
												<listitem> 
													 <para><phrase
														  role="code">Frontend.DetailKeyNames</phrase></para> 
												</listitem> 
												<listitem> 
													 <para><phrase
														  role="code">Frontend.Elaborate</phrase></para> 
												</listitem> 
										  </itemizedlist>The values of these tags are
										  then used to construct the document expression.</para> 
								</step> 
						  </procedure> 
						  <para>Note that if the document expression is being
								constructed as a result of a reference, the source or target table variable of
								the reference will be used to search for tags if they are not defined on the
								reference directly. For example, when constructing the document expression for
								a detail reference, if the 
								<phrase role="code">Frontend.Query</phrase> tag is not
								specified on the reference, the source table variable will be searched.</para> 
						  <para>Note also that for the special case of constructing
								Add, Edit, Delete, and View commands for the 
								<phrase role="code">Browse</phrase> user-interface, the
								
								<phrase role="code">Document</phrase> tag will only be
								used if it is explicitly qualified, i.e. 
								<phrase role="code">Frontend.Add.Document</phrase> will
								be used as the document reference for the 
								<phrase role="code">Add</phrase> action, but 
								<phrase role="code">Frontend.Document</phrase> would
								not be used.</para> 
					 </sect3> 
				</sect2> 
		  </sect1> 
	 </chapter> 
	 <chapter id="DDGTheSpaceBetweentheData"> 
		  <title>The Space Between the Data</title> 
		  <para>One of the most complex and time-consuming tasks in any
				application involves coordinating the interaction between the frontend
				applications and the database server. Because of the disconnected nature of the
				data entry forms in an application, and the transaction-oriented processing
				capabilities of traditional database management systems, large portions of
				application-specific code must be devoted to managing the potential concurrency
				and resource contention issues surrounding common user-interface and
				application logic processing tasks.</para> 
		  <para>In addition, because traditional database management systems
				typically provide little or no services for extending the business rules
				enforcement they provide to the client applications, many of these validations
				and processes must be duplicated in client-side code, giving rise to additional
				development and maintenance effort.</para> 
		  <para>One of the primary goals of the Dataphor product is the
				elimination of this disconnect, and provisions for a platform that exposes the
				business rules enforcement capabilities of the server to the frontend client.
				By exposing these services, and providing a data access layer that is aware of
				them, most, if not all, of this development effort can be eliminated, both in
				the development and maintenance cycles.</para> 
		  <para>This chapter discusses the three main services that the Dataphor
				Server Call-Level Interface exposes above and beyond traditional DBMSs:
				Navigational Access, Application Transactions, and Proposables. Navigational
				Access provides a mechanism for enabling what appears to be indexed-sequential
				access to relational data, while minimizing the performance and concurrency
				impact that such access would typically require. Application Transactions
				provide a mechanism for building batch data entry processes that enforce
				database level constraints, while simultaneously managing concurrency issues
				and minimizing resource contention. And finally, Proposables provide services
				for proposing data modifications without actually performing them, allowing
				client applications to actively participate in business rules enforcement, and
				eliminating the need to duplicate the logic already defined in the application
				schema on the server.</para> 
		  <sect1 id="DDGTheSpaceBetweentheData-NavigationalAccess"> 
				<title><indexterm> 
						  <primary>Navigational Access</primary> 
					 </indexterm>Navigational Access</title> 
				<para>Searching and navigation user-interfaces make up a large part
					 of any application. Almost every process will involve some kind of browse style
					 user-interface to allow the user to select information for data entry, or
					 manipulation. Moreover, for the vast majority of these interfaces, the most
					 intuitive approach from the user's perspective is simply to provide a
					 searchable list of the rows available.</para> 
				<para>However, this approach can cause problems when dealing a
					 relational data store. Traditional DBMSs are typically optimized to produce the
					 entire query result as quickly as possible. This results in queries such as
					 "Show me the list of all customers" being evaluated in their entirety to avoid
					 resource contention. Of course, in a browse style interface, the query is more
					 precisely stated "Show me the first few customers, and let me retrieve more if
					 desired." 
					 <footnote> 
						  <para>Resource contention in this scenario is eliminated by
								requesting the cursor in <emphasis>browse</emphasis> isolation, meaning that
								the cursor will not take locks on data that it reads. Because the data is only
								being read, there is no danger of inconsistency.</para> 
					 </footnote></para> 
				<para>This is precisely what the 
					 <phrase role="code"><emphasis
						  role="bold">browse</emphasis></phrase> clause of a cursor definition in D4
					 does. Rather than assume that all the rows of a given query will be retrieved,
					 the Dataphor Server assumes that only those rows that have actually been
					 requested will be retrieved. If the client application never requests more
					 rows, the Dataphor Server simply closes the cursor without requesting any
					 additional information from the target system.</para> 
				<para>When the 
					 <phrase role="code"><emphasis
						  role="bold">browse</emphasis></phrase> clause is used to specify the desired
					 ordering of a result set, the Dataphor Server actually transforms the query
					 internally to retrieve only the rows that are necessary. For example, if the
					 user searches for the value 
					 <phrase role="code">"Smi"</phrase> in the 
					 <phrase role="code">Name</phrase> column of the 
					 <phrase role="code">Employee</phrase> table, the Dataphor
					 Server retrieves the first few rows that are greater than or equal to the given
					 value, and the first few rows that are less than the value. These rows are
					 returned to the client application for display.</para> 
				<para>The resulting user-interface displays the result set as
					 though all the rows were present at all times, when in reality, only those rows
					 required to maintain that illusion are retrieved. The grid displaying the
					 result set becomes a kind of "sliding window" ranging over the rows in the
					 result set.</para> 
				<para>Be aware that by default, the 
					 <phrase role="code"><emphasis
						  role="bold">browse</emphasis></phrase> clause functions not only as an order
					 specification, but as a quasi-restriction, excluding rows that do not have
					 values for the columns of the order. This behavior is provided as an
					 optimization, because many systems perform better if rows containing nulls are
					 not included in the result set. If a cursor with a 
					 <phrase role="code"><emphasis
						  role="bold">browse</emphasis></phrase> clause results in an unexpected empty
					 set, this is likely the cause. This behavior can be specified explicitly using
					 the 
					 <phrase role="code"><emphasis role="bold">include
						  nil</emphasis></phrase> clause of the order specification.</para> 
				<para>In addition, the 
					 <phrase role="code"><emphasis
						  role="bold">browse</emphasis></phrase> clause requires that the order
					 specification be a superset of some key of the result set. This requirement is
					 enforced to ensure that the searchable capabilities of the result set are
					 always available, and any given row can always be guaranteed to be addressable.
					 The compiler will ensure that the order specification meets this requirement by
					 automatically appending columns as necessary.</para> 
				<para>There is a caveat with this behavior, however, in that if the
					 compiler appends a key column on to the order specification, the target system
					 may not select the index if it does not include the additional column or
					 columns. For example, when searching by 
					 <phrase role="code">Name</phrase> in the 
					 <phrase role="code">Employee</phrase> table, the compiler will
					 append the 
					 <phrase role="code">ID</phrase> column to ensure addressability
					 of rows within the result set. If the 
					 <phrase role="code">Employee</phrase> table in the target
					 system has a non-unique index on 
					 <phrase role="code">Name</phrase> only, it may not be used to
					 satisfy the queries given by the Dataphor Server, depending on how the target
					 system decides to perform the query 
					 <footnote> 
						  <para>This usually only happens when the table in question
								has an extremely large number of rows (over 1,000,000), and the target system
								decides that, based on the distribution of values within the index pages, a
								table scan would be more efficient than a ranged index scan.</para> 
					 </footnote>. In cases such as this, defining the index on the
					 target system to include both 
					 <phrase role="code">Name</phrase> and 
					 <phrase role="code">ID</phrase> will eliminate the
					 problem.</para> 
		  </sect1> 
		  <sect1 id="DDGTheSpaceBetweentheData-ApplicationTransactions"> 
				<title><indexterm> 
						  <primary>Application Transactions</primary> 
					 </indexterm>Application Transactions</title> 
				<para>A constant problem encountered in developing applications
					 involves building data entry forms for structures which participate in database
					 level integrity constraints. The simplest example of the problem is that of a
					 master/detail relationship, where in order for a row to exist in a detail
					 table, such as 
					 <phrase role="code">EmployeePhone</phrase>, a row must exist in
					 the master table first, such as 
					 <phrase role="code">Employee</phrase>.</para> 
				<para>A typical user-interface for entering an 
					 <phrase role="code">Employee</phrase> row involves an edit for
					 the columns of the 
					 <phrase role="code">Employee</phrase> row itself, with an
					 embedded browse for the 
					 <phrase role="code">EmployeePhone</phrase> rows associated with
					 the employee. The problem arises as soon as the user attempts to post the first
					 
					 <phrase role="code">EmployeePhone</phrase> row while still in
					 the process of entering the 
					 <phrase role="code">Employee</phrase> row. Because of the
					 reference constraint defined between 
					 <phrase role="code">EmployeePhone</phrase> and 
					 <phrase role="code">Employee</phrase>, the database server will
					 reject the modification.</para> 
				<para>Application Transactions provide a generic and transparent
					 solution to this problem. By performing the data entry in an isolated scratch
					 pad, the Dataphor Server allows all the pertinent information about the
					 employee to be entered. The batch is then posted to the database as a single
					 transaction once the main data entry form has been accepted.</para> 
				<para>In effect, application transactions are long-running,
					 optimistically concurrent transactions. The Dataphor Server manages the scratch
					 pad buffers that are used to enter the data, and manages posting the
					 application transaction back to the actual database. By using the Data Access
					 Layer, this is all done transparently.</para> 
				<para>This section discusses application transactions, how the CLI
					 exposes them, and how the actual implementation manages process participation
					 in them.</para> 
				<sect2
				 id="DDGTheSpaceBetweentheData-ApplicationTransactions-Management"> 
					 <title><indexterm> 
								<primary>Application Transactions</primary> 
								<secondary>Management</secondary> 
						  </indexterm>Management</title> 
					 <para>Application transaction management is accomplished by
						  exposing several calls through the CLI. These calls are: 
						  <itemizedlist> 
								<listitem> 
									 <para><phrase
										  role="code">BeginApplicationTransaction</phrase></para> 
								</listitem> 
								<listitem> 
									 <para><phrase
										  role="code">JoinApplicationTransaction</phrase></para> 
								</listitem> 
								<listitem> 
									 <para><phrase
										  role="code">LeaveApplicationTransaction</phrase></para> 
								</listitem> 
								<listitem> 
									 <para><phrase
										  role="code">PrepareApplicationTransaction</phrase></para> 
								</listitem> 
								<listitem> 
									 <para><phrase
										  role="code">CommitApplicationTransaction</phrase></para> 
								</listitem> 
								<listitem> 
									 <para><phrase
										  role="code">RollbackApplicationTransaction</phrase></para> 
								</listitem> 
						  </itemizedlist></para> 
					 <para>Application transactions are managed by the session level
						  of the CLI. Any number of processes may participate in a given application
						  transaction, but all those processes must be on the same session. Closing a
						  session implicitly rolls back any active application transactions.</para> 
					 <para>Calling 
						  <phrase role="code">BeginApplicationTransaction</phrase>
						  starts a new application transaction in the current session, and optionally
						  joins the current process to the application transaction. The result of this
						  call is the application transaction <emphasis>id</emphasis>, which is a GUID
						  generated by the Dataphor Server to identify the application transaction. All
						  subsequent management calls must use this id to refer to the application
						  transaction.</para> 
					 <para>Calling 
						  <phrase role="code">JoinApplicationTransaction</phrase>
						  joins the current process to the specified application transaction. A process
						  may only participate in one application transaction at any given time. The
						  process can join the application transaction in <emphasis>insert</emphasis>
						  mode, which controls whether or not data from referenced table variables is
						  copied into the application transaction.</para> 
					 <para>Calling 
						  <phrase role="code">LeaveApplicationTransaction</phrase>
						  causes the current process to leave the application transaction in which it is
						  participating. Leaving an application transaction does not end the application
						  transaction.</para> 
					 <para>Calling 
						  <phrase role="code">PrepareApplicationTransaction</phrase>
						  posts the effects of the application transaction to the actual database, but
						  does not commit the application transaction. This call is exposed to allow the
						  application transaction to participate in a two-phase commit protocol with a
						  standard database transaction.</para> 
					 <para>Calling 
						  <phrase role="code">CommitApplicationTransaction</phrase>
						  prepares the application transaction if necessary, and ends the application
						  transaction, freeing up the resources allocated to the application
						  transaction.</para> 
					 <para>Calling 
						  <phrase role="code">RollbackApplicationTransaction</phrase>
						  undoes the effects of the application transaction on the global database if it
						  has been prepared, and ends the application transaction, freeing up the
						  resources allocated to the application transaction.</para> 
					 <para>All these management functions are handled transparently
						  by the Data Access layer of the Dataphor platform. By setting the 
						  <phrase role="code">UseApplicationTransactions</phrase>
						  property of the 
						  <phrase role="code">Source</phrase> component, all data
						  modifications performed by the 
						  <phrase role="code">Source</phrase> are protected within an
						  application transaction.</para> 
					 <para>The default value for this property is true, and its
						  value can also be controlled using the 
						  <phrase
							role="code">Frontend.UseApplicationTransactions</phrase> tag.</para> 
				</sect2> 
				<sect2
				 id="DDGTheSpaceBetweentheData-ApplicationTransactions-Translation"> 
					 <title><indexterm> 
								<primary>Translation</primary> 
						  </indexterm><indexterm> 
								<primary>Application Transactions</primary> 
								<secondary>Translation</secondary> 
						  </indexterm>Translation</title> 
					 <para>When a process is joined to an application transaction,
						  all calls on that process are <emphasis>translated</emphasis> into the
						  application transaction space. This means that statements referencing table
						  variables, and possibly other schema objects, in the database are actually
						  executed against the scratch pad tables and objects created in the application
						  transaction space.</para> 
					 <para>As table variables and other schema objects are
						  encountered within statements on the joined process, replicas of the referenced
						  schema objects are created in a temporary buffer space set aside for the
						  application transaction. If the application transaction was joined in insert
						  mode, no data is copied into these temporary buffers from the actual database.
						  Otherwise, the data from the database that is referenced by the statement being
						  translated is copied into the application transaction as well.</para> 
					 <para>All subsequent references to objects that have been
						  translated are executed against the scratch pad replicas, rather than the
						  actual database. As data modifications are performed against these tables, they
						  are logged by the application transaction. When the application transaction is
						  posted, this log is replayed against the actual tables in the database.
						  Optimistic concurrency checks are performed during this replay to guarantee
						  that updates from other users are not lost.</para> 
					 <para>The result is a transparent batch update process that
						  allows database level constraints to be temporarily violated during the data
						  entry process, without requiring long-running pessimistic transactions.</para> 
					 <para>There are three types of schema objects that will be
						  translated into an application transaction space as they are encountered: table
						  variables, operators, and event handlers.</para> 
					 <sect3 id="DDGTableVariables"> 
						  <title><indexterm> 
									 <primary>Tables</primary> 
									 <secondary>Application Transactions And</secondary>
									 
								</indexterm><indexterm> 
									 <primary>Views</primary> 
									 <secondary>Application Transactions And</secondary>
									 
								</indexterm><indexterm> 
									 <primary>Table Variables</primary> 
									 <secondary>Application Transactions And</secondary>
									 
								</indexterm><indexterm> 
									 <primary>Translation</primary> 
									 <secondary>Table Variables</secondary> 
								</indexterm>Tables And Views</title> 
						  <para>Whenever table variables are referenced within
								application transactions, the table variable is translated into the application
								transaction context. This translation occurs transparently, and the resulting
								copy is an exact replica of the source table variable, except that no
								database-level constraints are created on the copy, and only event handlers
								that should be translated are attached.</para> 
						  <para>If the process joined the application transaction in
								insert mode, no data is copied into the application transaction replica.
								Otherwise, any data that is visible within the expression referencing the table
								variable is copied into the application transaction.</para> 
						  <para>In addition, if the table variable is encountered
								within the right side of a 
								<phrase role="code"><emphasis role="bold">left
									 lookup</emphasis></phrase> operator, or some other scenario in which the update
								semantics will not cause a propagation to the table variable in question, then
								the table variable will not be translated into the application transaction
								space. This avoids unnecessarily creating application transaction copies of
								table variables and data that could not be updated by the process.</para> 
						  <para>One important exception to this is called a
								<emphasis>detail lookup</emphasis>, and occurs whenever a reference to another
								table involves some portion of the key of the source table variable. By
								default, a 
								<phrase role="code"><emphasis role="bold">left
									 lookup</emphasis></phrase> operator is considered a detail lookup if the
								columns over which the join is performed form a proper superset of any
								non-empty key of the left input to the operator. This behavior can be changed
								using the 
								<phrase role="code">IsDetailLookup</phrase>
								modifier.</para> 
						  <para>The translation of a table variable into an
								application transaction context can be prevented by setting the 
								<phrase role="code">DAE.ShouldTranslate</phrase> tag to
								false. Note that session-specific table variables may be translated as well as
								global table variables.</para> 
					 </sect3> 
					 <sect3 id="DDGOperators"> 
						  <title><indexterm> 
									 <primary>Operators</primary> 
									 <secondary>Application Transactions And</secondary>
									 
								</indexterm><indexterm> 
									 <primary>Translation</primary> 
									 <secondary>Operators</secondary> 
								</indexterm>Operators</title> 
						  <para>Whenever operators are encountered within an
								application transaction, the operator is translated into the application
								transaction context. This translation occurs transparently, and the resulting
								copy is an exact replica of the source operator. Table variables and operators
								encountered within the translated operator are also translated into the
								application transaction context, recursively.</para> 
						  <para>By default, operators that are encountered are
								translated if they are not host-implemented, and they update table variables in
								the database. To change this behavior, use the 
								<phrase role="code">DAE.ShouldTranslate</phrase> tag.
								Note that session-specific operators may be translated as well as global
								operators.</para> 
						  <para>The translation of an operator into an application
								transaction context can be prevented by setting the 
								<phrase role="code">DAE.ShouldTranslate</phrase> tag to
								false.</para> 
					 </sect3> 
					 <sect3 id="DDGEventHandlers"> 
						  <title><indexterm> 
									 <primary>Event Handlers</primary> 
									 <secondary>Application Transactions And</secondary>
									 
								</indexterm><indexterm> 
									 <primary>Translation</primary> 
									 <secondary>Event Handlers</secondary> 
								</indexterm>Event Handlers</title> 
						  <para>Event handlers are translated into an application
								transaction context as a result of being attached to table variables that are
								being translated. If an event handler is to be translated, the operator being
								attached may or may not be translated into the application transaction context
								as well, depending on the characteristics of the operator.</para> 
						  <para>If a given event handler is invoked within an
								application transaction, it will not be invoked during playback of the
								application transaction. For example, if an audit event handler is attached to
								the 
								<phrase role="code">Customer</phrase> table, and an
								application transaction involving that table causes the event handler to be
								invoked, the event handler will not be invoked when the application transaction
								is committed and the actual 
								<phrase role="code">Customer</phrase> table is
								updated.</para> 
						  <para>By default, all event handlers except
								<emphasis>after</emphasis> table event handlers are translated into the
								application transaction context. To change this behavior, use the 
								<phrase role="code">DAE.ShouldTranslate</phrase> tag.
								If an event handler is translated, but the operator to be invoked is not, the
								invocation will essentially occur outside the application transaction 
								<footnote> 
									 <para>Unless the operator performs some dynamic
										  execution that subsequently re-enters the application transaction at
										  run-time.</para> 
								</footnote>.</para> 
						  <para>It is important to note in connection with event
								handlers that recording and playback of the application transaction is
								occurring at the base table variable level. This means that even though a
								particular insert may have occurred against a derived table variable within the
								application transaction, only the effects on the base table variables involved
								in the derived table variable definition are being recorded. As a result, any
								event handlers that are attached to derived table variables that were affected
								during the application transaction will not be invoked during the commit
								phase.</para> 
					 </sect3> 
				</sect2> 
				<sect2
				 id="DDGTheSpaceBetweentheData-ApplicationTransactions-Enlistment"> 
					 <title>Enlistment</title> 
					 <para>Enlistment is a Data Access Layer function that involves
						  determining if and when a given 
						  <phrase role="code">Source</phrase> should participate in
						  an application transaction. This determination follows the master/detail
						  relationships between sources. When a 
						  <phrase role="code">Source</phrase> begins an application
						  transaction as a result of entering insert or edit state, it is considered an
						  <emphasis>application transaction server</emphasis>. Detail 
						  <phrase role="code">Source</phrase>s of a 
						  <phrase role="code">Source</phrase> acting as an
						  application transaction server are considered <emphasis>application transaction
						  clients</emphasis> if they enlist in the application transaction managed by the
						  server.</para> 
					 <para>For a given 
						  <phrase role="code">Source</phrase>, the application
						  transaction server is determined by following the master/detail relationships
						  to their root 
						  <phrase role="code">Source</phrase>. By default, a detail 
						  <phrase role="code">Source</phrase> will enlist only if the
						  intersection of the columns of the master/detail relationship with some key of
						  the master 
						  <phrase role="code">Source</phrase> is non-empty. In other
						  words, if the detail relationship involves some key of the master 
						  <phrase role="code">Source</phrase>. This behavior can be
						  changed using the 
						  <phrase role="code">ShouldEnlist</phrase> property of the
						  detail 
						  <phrase role="code">Source</phrase>.</para> 
				</sect2> 
				<sect2
				 id="DDGTheSpaceBetweentheData-ApplicationTransactions-Committing"> 
					 <title>Committing</title> 
					 <para>Committing an application transaction involves playing
						  back all the recorded operations that occurred from any process involved in the
						  application transaction, in the order in which they occurred. When an
						  application transaction is committed from the Frontend by a Source component
						  acting as an application transaction server, this process is done using a
						  two-phase commit to coordinate the commit of the application transaction with
						  the commit of the transaction posting the contents of the Source.</para> 
					 <para>The prepare phase of the commit is where the play back of
						  the application transaction actually occurs. Each operation is performed
						  against the global database exactly as it was against the application
						  transaction context, with the exception that any event handlers that were
						  invoked within the application transaction context are not invoked during play
						  back.</para> 
					 <para>Because the play back is occurring within a database
						  transaction, any database level constraints present on the actual database
						  table variables will be checked only when the database transaction commits. If
						  any validation checks fail here, the play back transaction is rolled back, and
						  the application transaction is left open. The user can then take any necessary
						  steps to correct the problem, and try the commit again.</para> 
					 <para>Because other users may have modified the data in the
						  global database during the application transaction, the play back is done using
						  optimistic concurrency checks. When an update from the application transaction
						  is played back into the global database, the original data from the updated row
						  is compared with the current values of the row in the global database. If any
						  values are different, an error is raised indicated that an optimistic
						  concurrency check has failed.</para> 
				</sect2> 
		  </sect1> 
		  <sect1 id="DDGTheSpaceBetweentheData-Proposables"> 
				<title><indexterm> 
						  <primary>Proposables</primary> 
					 </indexterm>Proposables</title> 
				<para>Proposables provide client applications with the ability to
					 actively participate in the business-rules enforcement of the Dataphor Server,
					 without the need for any client-specific logic. This capability completely
					 eliminates the need to duplicate validation logic in the client
					 application.</para> 
				<para>The Dataphor Server allows complex business-rules to be
					 expressed and enforced declaratively, and the proposables interfaces allow this
					 enforcement to be distributed to client applications without developer
					 intervention. Once a business-rule is declared in the application schema, the
					 client applications work in conjunction with the Dataphor Server to ensure that
					 it is enforced.</para> 
				<para>There are three different proposable interfaces: 
					 <phrase role="code">Validate</phrase>, 
					 <phrase role="code">Default</phrase>, 
					 <phrase role="code">Change</phrase>. All of the interfaces are
					 performed as row-level calls, with an optional column name specifying a single
					 column within the row that has been affected.</para> 
				<para>The result of each call is a boolean value indicating whether
					 or not the values of any column within 
					 <phrase role="code">ARow</phrase> have been changed. This
					 return value is used by the Dataphor Server as an optimization to avoid
					 recopying the row values if no changes have been made.</para> 
				<para>The proposable calls propagate through table expressions in
					 the same way that modification statements do, with each operator managing how
					 the propagation should occur. For a detailed description of how this
					 propagation occurs, refer to the view updatability discussion in the Derived
					 Table Variables section of the 
					 <ulink type="olinka"
					  url="DDGRepresentingDataWithTablesandViews.html"><citetitle>Representing Data
								With Tables and Views</citetitle></ulink> chapter of the Logical Application
					 Design part of this guide.</para> 
				<para>Note that even though the logic for proposables is defined in
					 the application schema and housed in the Dataphor Server, the proposable call
					 may actually occur completely client-side. This is accomplished transparently
					 by taking advantage of the compiler determined <emphasis>remotable</emphasis>
					 characteristic. Remotable operators and expressions are evaluable in isolation,
					 meaning that they make no reference to table variables in the global database.
					 Because of this, all the logic can be downloaded to the client as part of the
					 structural description of the result set, allowing the proposable calls to be
					 executed without the need for a network round-trip.</para> 
				<sect2 id="DDGTheSpaceBetweentheData-Proposables-Validate"> 
					 <title><indexterm> 
								<primary>Validate Proposable</primary> 
						  </indexterm><indexterm> 
								<primary>Proposables</primary> 
								<secondary>Validate</secondary> 
						  </indexterm>Validate</title> 
					 <para>The 
						  <phrase role="code">Validate</phrase> proposable allows
						  proposed changes to a given row to be validated. If the values of the proposed
						  row violate any business-rule defined by the application schema, the same error
						  message that would be displayed by actually attempting the modification is
						  returned.</para> 
					 <para>The syntax of the 
						  <phrase role="code">Validate</phrase> CLI call is: 
						  <programlisting>bool Validate(Row AOldRow, Row ANewRow, string AColumnName);</programlisting></para> 
					 <para>The 
						  <phrase role="code">Validate</phrase> proposable call
						  evaluates all column and data type level constraints and all validate event
						  handlers. It does not evaluate row level constraints, transition constraints,
						  or database level constraints. The evaluations take place in the following
						  order:</para> 
					 <procedure> 
						  <step> 
								<para>Table level validate event handlers are
									 evaluated.</para> 
						  </step> 
						  <step> 
								<para>Column level validate event handlers are
									 evaluated.</para> 
						  </step> 
						  <step> 
								<para>Column level constraints are evaluated.</para> 
						  </step> 
						  <step> 
								<para>Scalar type level validate event handlers are
									 evaluated.</para> 
						  </step> 
						  <step> 
								<para>Scalar type level constraints are
									 evaluated.</para> 
						  </step> 
					 </procedure> 
					 <para>Any violation encountered immediately stops processing of
						  the 
						  <phrase role="code">Validate</phrase> proposable call and
						  raises an error. The error message is constructed based on the constraint that
						  has been violated, using the 
						  <phrase role="code">DAE.Message</phrase> and 
						  <phrase role="code">DAE.SimpleMessage</phrase> tags when
						  specified.</para> 
					 <para>The result of the 
						  <phrase role="code">Validate</phrase> call will be true if
						  any event handler modified the actual values of any columns in the row. Note
						  that this result indicates that the value of some column has changed, not
						  necessarily the column specified by 
						  <phrase role="code">AColumnName</phrase>.</para> 
				</sect2> 
				<sect2 id="DDGTheSpaceBetweentheData-Proposables-Default"> 
					 <title><indexterm> 
								<primary>Default Proposable</primary> 
						  </indexterm><indexterm> 
								<primary>Proposables</primary> 
								<secondary>Default</secondary> 
						  </indexterm>Default</title> 
					 <para>The 
						  <phrase role="code">Default</phrase> proposable allows the
						  default values for a given row to be requested. After the call, the resulting
						  row is populated with the default values for each column, or for the specific
						  column given by 
						  <phrase role="code">AColumnName</phrase>.</para> 
					 <para>The syntax of the 
						  <phrase role="code">Default</phrase> CLI call is: 
						  <programlisting>bool Default(Row ARow, string AColumnName);</programlisting></para> 
					 <para>The 
						  <phrase role="code">Default</phrase> proposable call
						  evaluates all column and data type level defaults and all default event
						  handlers. The evaluations take place in the following order:</para> 
					 <procedure> 
						  <step> 
								<para>Table level default event handlers are
									 evaluated.</para> 
						  </step> 
						  <step> 
								<para>Column level default event handlers are
									 evaluated.</para> 
						  </step> 
						  <step> 
								<para>Column level defaults are evaluated.</para> 
						  </step> 
						  <step> 
								<para>Scalar type level default event handlers are
									 evaluated.</para> 
						  </step> 
						  <step> 
								<para>Scalar type level defaults are evaluated.</para> 
						  </step> 
					 </procedure> 
					 <para>Once a default value has been determined for a particular
						  column, processing stops for that column.</para> 
					 <para>The result of the 
						  <phrase role="code">Default</phrase> call will be true if
						  the value of any column within the row has been changed. As with the 
						  <phrase role="code">Validate</phrase> call, this result
						  indicates that the value of some column has changed, not necessarily the column
						  specified by 
						  <phrase role="code">AColumnName</phrase>.</para> 
				</sect2> 
				<sect2 id="DDGTheSpaceBetweentheData-Proposables-Change"> 
					 <title><indexterm> 
								<primary>Change Proposable</primary> 
						  </indexterm><indexterm> 
								<primary>Proposables</primary> 
								<secondary>Change</secondary> 
						  </indexterm>Change</title> 
					 <para>The 
						  <phrase role="code">Change</phrase> proposable is somewhat
						  different in kind from the 
						  <phrase role="code">Validate</phrase> and 
						  <phrase role="code">Default</phrase> proposables in that
						  the 
						  <phrase role="code">Change</phrase> will only be called
						  through the CLI. The 
						  <phrase role="code">Default</phrase> proposable is used to
						  determine the default values for newly inserted rows, and the 
						  <phrase role="code">Validate</phrase> proposable is used to
						  validate constraints for inserted and updated rows.</para> 
					 <para>Because of this difference, the 
						  <phrase role="code">Change</phrase> proposable is uniquely
						  suited for handling change logic that should occur during data entry. For
						  example, if the value of the 
						  <phrase role="code">ZipCode</phrase> column is set, the 
						  <phrase role="code">City</phrase> and 
						  <phrase role="code">State_ID</phrase> columns could be set
						  based on the 
						  <phrase role="code">ZipCode</phrase> table using the 
						  <phrase role="code">Change</phrase> proposable.</para> 
					 <para>The 
						  <phrase role="code">Change</phrase> proposable is also
						  responsible for looking up the values of the columns of the right side of a
						  join operator when the values of the left join key columns are changed.</para> 
					 <para>The syntax of the 
						  <phrase role="code">Change</phrase> CLI call is: 
						  <programlisting>bool Change(Row AOldRow, Row ANewRow, string AColumnName);</programlisting></para> 
					 <para>The 
						  <phrase role="code">Change</phrase> proposable call
						  evaluates all change event handlers. The evaluations take place in the
						  following order:</para> 
					 <procedure> 
						  <step> 
								<para>Table level change event handlers are
									 evaluated.</para> 
						  </step> 
						  <step> 
								<para>Column level change event handlers are
									 evaluated.</para> 
						  </step> 
						  <step> 
								<para>Scalar type level change event handlers are
									 evaluated.</para> 
						  </step> 
					 </procedure> 
					 <para>Only an error will stop the processing of a 
						  <phrase role="code">Change</phrase> proposable call. Once
						  an event handler has indicated that a change has occurred, the result of the
						  overall call will be true, regardless of the results of processing subsequent
						  event handlers.</para> 
					 <para>As with the other proposable calls, a result of true
						  indicates that the value of some column has changed, not necessarily the column
						  specified by 
						  <phrase role="code">AColumnName</phrase>.</para> 
				</sect2> 
		  </sect1> 
	 </chapter>

  <!--<chapter> 
		  <title>Applications</title> 
		  <para></para> 
		  <sect1> 
				<title>Frontend Sessions</title> 
				<para></para> 
		  </sect1> 
		  <sect1> 
				<title>Common User-Interface Patterns</title> 
				<para>Many applications contain similar structural patterns that
					 arise as a natural consequence of good database design. These patterns serve as
					 a starting point for the automation of user-interfaces by the Dataphor
					 platform. All the patterns are built from the four basic types of references:
					 parent, extension, lookup, and detail, and are essentially just different
					 combinations of these basic building blocks.</para> 
				<para>This section considers many of these data manipulation
					 patterns, and provides examples of each. This is certainly not an exhaustive
					 list, but it does provide a core set of structural patterns that provide the
					 basis for building more complex applications.</para><sect2> 
					 <title>Parent / Extension</title> 
					 <para><?xm-replace_text {Paragraph}?></para> 
				</sect2> 
				<sect2> 
					 <title>Lookup / Detail</title> 
					 <para><?xm-replace_text {Paragraph}?></para> 
				</sect2> 
				<sect2> 
					 <title>Recursive</title> 
					 <para><?xm-replace_text {Paragraph}?></para> 
				</sect2> 
				<sect2> 
					 <title>Generalized Recursive</title> 
					 <para><?xm-replace_text {Paragraph}?></para> 
				</sect2> 
				<sect2> 
					 <title>Association</title> 
					 <para><?xm-replace_text {Paragraph}?></para> 
				</sect2> 
				<sect2> 
					 <title>Specialized Association</title> 
					 <para><?xm-replace_text {Paragraph}?></para> 
				</sect2> 
				<sect2> 
					 <title>Detail Lookup</title> 
					 <para><?xm-replace_text {Paragraph}?></para> 
				</sect2> 
				<sect2> 
					 <title>Generalized Detail Lookup</title> 
					 <para><?xm-replace_text {Paragraph}?></para> 
				</sect2> 
		  </sect1> 
		  <sect1> 
				<title>Deployment Considerations</title> 
				<para><?xm-replace_text {Section Introductory Paragraph}?></para> 
		  </sect1> 
	 </chapter>-->
</part>
