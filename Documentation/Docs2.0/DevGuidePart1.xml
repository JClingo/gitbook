<?xml version="1.0"?>
<part id="DDGIntroduction"> 
	 <partinfo><date role="LastMod">Tuesday, September 05, 2006 3:15:08
				PM</date> 
	 </partinfo> 
	 <title>Introduction</title> 
	 <partintro> 
		  <para>This part of the Dataphor Developer's Guide provides an
				introduction to the Dataphor product from the perspective of an application
				developer. It introduces all the terms, concepts, and technologies necessary to
				utilize the Dataphor product, and lays the groundwork for the declarative
				approach. The part is organized as follows: 
				<itemizedlist> 
					 <listitem> 
						  <para><citetitle>Application Development
									 Considerations</citetitle></para> 
						  <para>Discusses application development in general, the
								technical difficulties associated with building applications, and the
								declarative approach to application development as a solution to these
								problems.</para> 
					 </listitem> 
					 <listitem> 
						  <para><citetitle>Database Management
									 Concepts</citetitle></para> 
						  <para>Provides a survey of database theory and database
								management systems in general.</para> 
					 </listitem> 
					 <listitem> 
						  <para><citetitle>Application Development
									 Concepts</citetitle></para> 
						  <para>Discusses application development concepts in general
								and describes how the declarative approach can be applied to automate the
								development process.</para> 
					 </listitem> 
					 <listitem> 
						  <para><citetitle>Dataphor Product
									 Anatomy</citetitle></para> 
						  <para>Provides a brief description of Dataphor product
								anatomy, and how it enables the declarative approach.</para> 
					 </listitem> 
				</itemizedlist></para> 
	 </partintro> 
	 <chapter id="DDGApplicationDevelopmentConsiderations"> 
		  <title><indexterm><primary>Application
						  Development</primary></indexterm>Application Development Considerations</title>
		  
		  <para>This chapter examines many of the issues associated with
				application development and considers the declarative approach as a solution to
				these problems.</para> 
		  <sect1
		  id="DDGApplicationDevelopmentConsiderations-WhatisanApplication"> 
				<title><indexterm><primary>Application</primary><secondary>Definition</secondary></indexterm>What
					 is an Application?</title> 
				<para>In the most general terms, an application is simply a
					 computer-based model of some aspect of the real world designed to solve a
					 specific set of problems. Computing technology has given rise to an
					 ever-increasing number of applications in almost every aspect of life, from the
					 most mundane address books, to the information systems required to track the
					 business processes of an entire enterprise. Regardless of the size or
					 complexity of applications, they all have a common purpose: the manipulation,
					 analysis, and persistence of data.</para> 
		  </sect1> 
		  <sect1
		  id="DDGApplicationDevelopmentConsiderations-IdentifyingtheIssues"> 
				<title><indexterm><primary>Application
								Development</primary><secondary>Issues</secondary></indexterm>Identifying the
					 Issues</title> 
				<para>Given this general definition of an application, it is clear
					 that data management plays a large role in any application. As such, every
					 application must address at least some of the following issues: 
					 <itemizedlist> 
						  <listitem> 
								<indexterm><primary>Persistence</primary></indexterm> 
								<para>Persistence - The data must be stored for an
									 extended period of time.</para> 
						  </listitem> 
						  <listitem> 
								<indexterm><primary>Integrity</primary></indexterm> 
								<para>Integrity - The data must be correct, according
									 to some defined set of rules.</para> 
						  </listitem> 
						  <listitem> 
								<indexterm><primary>Concurrency</primary></indexterm> 
								<para>Concurrency - Coordinating read and change
									 requests from multiple users.</para> 
						  </listitem> 
						  <listitem> 
								<indexterm><primary>Scalability</primary></indexterm> 
								<para>Scalability - The application must scale in terms
									 of number of users, volume of data, and data complexity.</para> 
						  </listitem> 
						  <listitem> 
								<indexterm><primary>Performance</primary></indexterm> 
								<para>Performance - Providing efficient access to the
									 application data.</para> 
						  </listitem> 
						  <listitem> 
								<indexterm><primary>Recovery</primary></indexterm> 
								<para>Recovery - Ensuring that the data can survive
									 application and system failures.</para> 
						  </listitem> 
						  <listitem> 
								<indexterm><primary>Security</primary></indexterm> 
								<para>Security - Preventing unauthorized access or
									 manipulation of the application data.</para> 
						  </listitem> 
						  <listitem> 
								<indexterm><primary>Reporting</primary></indexterm> 
								<para>Reporting - Providing general analysis and
									 presentation of the application data to support decision making within the
									 organization.</para> 
						  </listitem> 
						  <listitem> 
								<indexterm><primary>Integration</primary></indexterm> 
								<para>Integration - Allowing the application to
									 interact with other software systems.</para> 
						  </listitem> 
						  <listitem> 
								<indexterm><primary>Presentation</primary></indexterm> 
								<para>Presentation - Providing a user-interface for
									 entry and manipulation of the application data.</para> 
						  </listitem> 
					 </itemizedlist></para> 
				<para>In addition to these problems, the application will
					 inevitably encounter change of some form: 
					 <itemizedlist> 
						  <listitem> 
								<para>Requirements Change - Modifying the application
									 to fit new or changing business needs.</para> 
						  </listitem> 
						  <listitem> 
								<para>Environment Change - Reacting to changes in the
									 hardware or software environment.</para> 
						  </listitem> 
					 </itemizedlist></para> 
				<para>In building applications that handle all these issues, we
					 also encounter development process issues that must be addressed: 
					 <itemizedlist> 
						  <listitem> 
								<para>Developer Productivity - Ensuring maximum
									 productivity of application team members.</para> 
						  </listitem> 
						  <listitem> 
								<para>Developer Training - Training team members on the
									 platforms and technologies to be used.</para> 
						  </listitem> 
						  <listitem> 
								<para>Application Quality - Ensuring the application
									 meets requirements and functionality.</para> 
						  </listitem> 
						  <listitem> 
								<para>Deployment - Providing installation and
									 deployment for the application.</para> 
						  </listitem> 
						  <listitem> 
								<para>Maintenance - Providing a maintenance path for
									 deployed applications.</para> 
						  </listitem> 
					 </itemizedlist></para> 
				<para>Clearly, application development in general is an extremely
					 complex problem. The more complex the application, the more difficult the
					 solution to these problems becomes. Fortunately, these solutions can, for the
					 most part, be generally implemented in systems-level software that all
					 applications can utilize. Many of these issues, such as persistence,
					 concurrency, scalability, and others, are already addressed to varying degrees
					 by existing systems; however, there are still many issues that arise when
					 developing applications against these systems: 
					 <itemizedlist> 
						  <listitem> 
								<indexterm><primary>Schema
										  Duplication</primary></indexterm> 
								<para>Schema Duplication - Presentation layers often
									 duplicate the structures and logic already present in the database
									 schema.</para> 
						  </listitem> 
						  <listitem> 
								<para>Complex Business Rules - Existing systems often
									 do not provide effective support for complex business rules.</para> 
						  </listitem> 
						  <listitem> 
								<para>Client-Side Enforcement of Business Rules -
									 Presentation layers must provide initial enforcement of business rules.</para> 
						  </listitem> 
						  <listitem> 
								<para>Client-Side Buffering - Presentation layers must
									 provide a mechanism for data retrieval, display, entry and translation.</para> 
						  </listitem> 
					 </itemizedlist></para> 
				<para>Traditionally, these problems have been resolved on a
					 case-by-case basis within each application. The result is large amounts of
					 application-specific code that is difficult to produce and maintain. If a
					 general purpose solution to these issues can be found, it can be
					 <emphasis>automated</emphasis>, just as many of the issues relating to data
					 management have been automated by Database Management Systems (DBMSs).</para> 
		  </sect1> 
		  <sect1 id="DDGApplicationDevelopmentConsiderations-WhatistheSolution"> 
				<title><indexterm><primary>Application
								Development</primary><secondary>Solutions</secondary></indexterm>What is the
					 Solution?</title> 
				<indexterm><primary>Abstraction</primary></indexterm><indexterm><primary>3GL</primary></indexterm>
				
				<para>Historically, application development has evolved over time
					 by increasing the level of abstraction at which applications are built. For
					 example, the very earliest programs were built with machine languages
					 (First-Generation Languages or 1GLs). Application logic was developed directly
					 in the language of the hardware. This was replaced by assembly languages
					 (2GLs), and then again by compiled languages such as C and Pascal (3GLs), and
					 so on. Each successive generation of languages hides the details and complexity
					 of the levels below it. In this way, application development has become more
					 and more <emphasis>declarative</emphasis>, meaning that we state simply
					 <emphasis>what</emphasis> is to be done, not <emphasis>how</emphasis> it should
					 be accomplished.</para> 
				<para>Another example of this trend towards the declarative, rather
					 than procedural approach is the evolution of database management technologies.
					 The earliest systems dealt principally with sequential files. These were later
					 replaced by indexed access (ISAM systems), then again by network and hierarchic
					 systems, and eventually SQL-based systems. Each of these steps represents a
					 higher level of abstraction. Rather than dealing with pointers and file I/O,
					 application developers simply describe the structure of the data involved. The
					 system, not the application, is responsible for performing the various data
					 management tasks required.</para> 
				<para>These examples illustrate the value of the declarative
					 approach. By simply describing what is to be accomplished, the system is able
					 to realize the implementation. This automation is enabled by framing the
					 solution in general terms. For example, a compiler is able to translate
					 programs into machine language because the programs are expressed in a formal
					 system that the compiler understands. The database system is able to automate
					 data management tasks because the data to be stored is described in a model
					 that can capture the essence of the problem. In other words, if the solution to
					 a given problem can be formalized, it can be automated: formalization enables
					 automation.</para> 
				<para>So what is the next step in this evolution towards
					 declarative development? What mechanisms will enable further automation of
					 application development? Clearly, the answer lies in the formalization of the
					 concepts used in application development: an approach that allows applications
					 to be expressed <emphasis>declaratively</emphasis>. This model must allow for
					 the definition of any data, it must allow for arbitrary manipulation of that
					 data, and it must allow rules about that data to be expressed. Ideally, this
					 model would also be as simple as possible.</para> 
				<para>A brief survey of the current computing landscape reveals a
					 myriad of different technologies for automating various aspects of the
					 application development process. From object-oriented programming techniques to
					 SQL-based database design methodologies and everything in between. The more
					 declarative of these approaches is found in current database systems. This is
					 due to the model on which these systems are based, the Relational Model. Simply
					 put, the Relational Model is mathematics applied to database management. The
					 result is a simple and complete mechanism for describing and manipulating any
					 data, as well as an excellent environment for declaratively enforcing rules
					 about that data. It also provides various kinds of independence, such as
					 logical and physical data independence. This independence is what enables the
					 automation and declarativeness provided by these systems. If this same
					 independence can be utilized to enable the declarative approach to application
					 development, the resulting paradigm would provide a development platform that
					 addressed many, if not all of the issues raised in the previous section.</para>
				
				<para>So the ideal solution is the declarative approach to
					 application development. Specifically, that solution should be based on The
					 Relational Model. In this way, the platform begins with a solid foundation for
					 data management, and then builds on that foundation to provide various
					 application development services such as the presentation layer. Throughout
					 this manual, the resulting paradigm is called <emphasis>automated application
					 development</emphasis> and represents the next step in the evolution of
					 application development technology beyond current <emphasis>rapid application
					 development</emphasis> or RAD. The next chapter discusses the data management
					 foundation of the solution. The 
					 <citetitle>Application Development Concepts</citetitle> chapter
					 then illustrates how a declarative solution based on the relational model
					 addresses each of the issues discussed in this chapter.</para> 
		  </sect1> 
	 </chapter> 
	 <chapter id="DDGDatabaseManagementConcepts"> 
		  <title><indexterm><primary>Database
						  Management</primary></indexterm>Database Management Concepts</title> 
		  <para>This chapter provides an overview of the database management
				principles and techniques which form the foundation for the solution to many of
				the issues raised in the previous chapter. Understanding these principles is
				essential to understanding how a database system can help enable the
				declarative approach.</para> 
		  <para>Note: the material in this chapter is largely a summary of 
				<citetitle>An Introduction to Database Systems</citetitle> by C. J.
				Date [1]. Readers are encouraged to study this work, as it covers the topics
				much more thoroughly. Even readers with some background in database theory
				should review the material in this chapter to be certain that the concepts are
				well understood.</para> 
		  <sect1 id="DDGP1DatabaseManagementSystems"> 
				<title><indexterm><primary>Database Management
								Systems</primary></indexterm>Database Management Systems</title> 
				<para>A Database Management System (DBMS) is a software system
					 specifically designed to handle the class of problems that arise when software
					 applications need to store and manipulate data. Any application that uses data
					 inevitably encounters issues such as efficiently accessing and changing the
					 data, dealing with concurrency, and ensuring the correctness, or integrity, of
					 the data. This section describes the basic functionality that is desirable in
					 database management systems in general.</para> 
				<sect2 id="DDGP1Databases"> 
					 <title><indexterm><primary>Databases</primary></indexterm>Databases</title>
					 
					 <para>A database is an organized collection of facts. A
						  database can be as simple as the list of settings for a particular application,
						  or as complex as all the data for an entire enterprise including payroll,
						  sales, accounting, human resources, and other information.</para> 
					 <para>Regardless of the size or usage requirements of a given
						  database, some fundamental characteristics emerge that are vital to the
						  functionality of the application consuming the data. These include: 
						  <itemizedlist> 
								<listitem> 
									 <indexterm><primary>Persistence</primary></indexterm>
									 
									 <para>Persistence: The application must be able to
										  ensure that the data in the database is available, or 'saved' to long-term
										  storage.</para> 
								</listitem> 
								<listitem> 
									 <indexterm><primary>Efficiency</primary></indexterm>
									 
									 <para>Efficiency: The application must be able to
										  provide efficient access to the data.</para> 
								</listitem> 
								<listitem> 
									 <indexterm><primary>Concurrency</primary></indexterm>
									 
									 <para>Concurrency: If multiple requests are made to
										  the same data, the application must be able to ensure that the results of each
										  operation are correct.</para> 
								</listitem> 
								<listitem> 
									 <indexterm><primary>Recovery</primary></indexterm> 
									 <para>Recovery: If the application crashes, or the
										  environment becomes unstable, the application must be able to guarantee that
										  the database can be recovered.</para> 
								</listitem> 
								<listitem> 
									 <indexterm><primary>Integrity</primary></indexterm>
									 
									 <para>Integrity: The application must always be
										  able to guarantee that the data in the database is correct, or conforms to all
										  the business rules described by the application.</para> 
								</listitem> 
						  </itemizedlist></para> 
					 <para>Rather than solving these issues specifically within each
						  application, it makes sense to build a software system that can solve these
						  issues generically, and then make use of that system as needed. In the next
						  section, we examine the benefits of using such a system.</para> 
				</sect2> 
				<sect2 id="DDGP1DatabaseSystems"> 
					 <title>Database Systems</title> 
					 <para>Clearly we can gain numerous advantages by implementing a
						  system which handles these issues generically. Among these are: 
						  <itemizedlist> 
								<listitem> 
									 <para>Reusability: The solutions to data management
										  issues are often quite complex. By providing a generic solution one time, we
										  are able to leverage development time and stability from a system designed
										  specifically to handle these issues.</para> 
								</listitem> 
								<listitem> 
									 <para>Sharing: Different applications can access
										  the same database. For example, the human resources application and the payroll
										  application may both share the same list of employees.</para> 
								</listitem> 
								<listitem> 
									 <para>Centralization: By maintaining all the data
										  for a particular enterprise in a single system, an enterprise can gain greater
										  control over the data. </para> 
								</listitem> 
								<listitem> 
									 <para>Control: Because all the data is in a central
										  location, the database management system can manage issues like security and
										  policy or business rules enforcement.</para> 
								</listitem> 
								<listitem> 
									 <indexterm><primary>Physical Data
												Independence</primary></indexterm> 
									 <para>Data Independence: Ideally, the database
										  system will be capable of changing physical details about the database without
										  affecting the applications that use it. This is known as Physical Data
										  Independence (PDI) and is of critical importance in a database system.</para> 
								</listitem> 
						  </itemizedlist></para> 
				</sect2> 
				<sect2 id="DDGP1LevelsinaDatabaseSystem"> 
					 <title><indexterm><primary>Database Management
									 Systems</primary><secondary>Levels</secondary></indexterm>Levels in a Database
						  System</title> 
					 <para>In order to realize the objectives of a database
						  management system, the architecture is layered to isolate the details of the
						  system from the users of the system. This layering can loosely be categorized
						  into three views of the system: 
						  <itemizedlist> 
								<listitem> 
									 <indexterm><primary>Internal
												Level</primary></indexterm> 
									 <para>The <emphasis>internal level</emphasis> (also
										  called the physical level) is concerned with the physical storage of the
										  data.</para> 
								</listitem> 
								<listitem> 
									 <indexterm><primary>External
												Level</primary></indexterm> 
									 <para>The <emphasis>external level</emphasis> is
										  concerned with the user's perception of the data.</para> 
								</listitem> 
								<listitem> 
									 <indexterm><primary>Conceptual
												Level</primary></indexterm> 
									 <para>The <emphasis>conceptual level</emphasis>
										  (also called the logical level) provides a level of indirection between the
										  two.</para> 
								</listitem> 
						  </itemizedlist></para> 
					 <para>These three categories serve as a conceptual foundation
						  for the architecture of a database system. In order to provide a basis for the
						  design of these levels we make use of a data model, as described in the next
						  section.</para> 
				</sect2> 
				<sect2 id="DDGP1DataModels"> 
					 <title><indexterm><primary>Data
									 Models</primary></indexterm>Data Models</title> 
					 <para>Firstly, we note that the term <emphasis>data
						  model</emphasis> has two distinct meanings. First, as a description of an
						  abstraction for dealing with all data, and second, as a model of the particular
						  data of interest to some organization. In this section we discuss the first of
						  these definitions.</para> 
					 <para>"A data model is an abstract, self-contained, logical
						  definition of the objects, operators, and so forth, that together constitute
						  the abstract machine with which users interact. The objects allow us to model
						  the structure of the data. The operators allow us to model its behavior."
						  [1]</para> 
					 <para>The data model then allows us to describe the behavior of
						  the system at the conceptual level. A user who understands the data model will
						  understand how to interact with the system. The conceptual level is then
						  concerned with mapping between the implementation of the model on the internal
						  level, and the perception of the model on the external level.</para> 
					 <para>As an example, take a simple calculator. The external
						  level is the keypad and numeric display, allowing the user to enter data, and
						  view the results. The internal level is the actual electronic components which
						  perform the processing. The conceptual level is basic arithmetic, which allows
						  the user to communicate with the system to perform some task.</para> 
					 <para>Loosely speaking, a logical model can be viewed as a
						  simulated or actual environment of rules. Rules (or axioms) can be combined to
						  form other rules (or theorems) based on the established principles of the
						  formal system. Computer software is a set of rules built within the formal
						  system defined by the capabilities of the hardware. In this case, the hardware
						  provides the physical implementation, while the software executes within the
						  resulting logical model.</para> 
					 <para>Developing software that directly utilizes the logical
						  model provided by the hardware is arduous and is prone to human error; so over
						  the years, software engineers have built up layers of software to provide
						  higher levels of abstraction. Today's high-level drawing programs, modeling
						  tools, and programming languages provide highly abstracted, logical models
						  aimed at enabling the user to accomplish more work with less effort. The
						  hardware and software system that create an environment for a particular
						  logical model is often called the physical implementation (or layer), because
						  it directly or indirectly utilizes the hardware for its intended purposes. If
						  the implementation is successful, i.e. it correctly abstracts the user from the
						  physical implementation, the result is Physical Data Independence.</para> 
					 <para>Physical Data Independence (PDI) is a term that describes
						  the degree to which the user of a logical model is insulated from the physical
						  implementation and its accompanying limitations. It should be noted that
						  because computers are finite, PDI will always be a matter of degree, rather
						  than an absolute. On the other hand, if the user of a particular logical model
						  encounters a physical limitation, the ideal logical design will have to be
						  compromised.</para> 
					 <para>An important practical benefit of physical data
						  independence is the idea of a <emphasis>single-level store</emphasis>. Because
						  the physical location of the data being stored is transparent in the logical
						  model, it does not matter to the user of the database whether the data resides
						  on disk, in memory, or some other location. These details are handled by the
						  system.</para> 
				</sect2> 
		  </sect1> 
		  <sect1 id="DDGP1TheRelationalModelofData"> 
				<title><indexterm><primary>Relational Model of
								Data</primary></indexterm>The Relational Model of Data</title> 
				<para>Because a database management system should be able to solve
					 the data management issues for a broad class of applications (ideally all
					 applications), it should be capable of representing all data. Additionally,
					 this should be accomplished as simply as possible.</para> 
				<para>The relational model, introduced by E. F. Codd in reference
					 [2], provides a data model which is perfectly suited to realizing these goals.
					 It provides a simple, yet powerful framework within which all data can be
					 described and manipulated. Loosely speaking, the relational model is a model in
					 which data is represented as rows in tables, and operators are provided for
					 manipulating these tables which also return tables. [1]</para> 
				<para>Informally, the relational model can be described from three
					 main viewpoints: 
					 <itemizedlist> 
						  <listitem> 
								<para>Structural Aspect</para> 
						  </listitem> 
						  <listitem> 
								<para>Manipulative Aspect</para> 
						  </listitem> 
						  <listitem> 
								<para>Integrity Aspect</para> 
						  </listitem> 
					 </itemizedlist></para> 
				<para>Each of these aspects will be covered in detail in the
					 following sections.</para> 
				<sect2 id="DDGP1StructuralAspect"> 
					 <title><indexterm><primary>Relational Model of
									 Data</primary><secondary>Structural Aspect</secondary></indexterm>Structural
						  Aspect</title> 
					 <para>The structural aspect of the relational model describes
						  how data is represented, namely as relations (which are usually depicted as
						  tables). The term <emphasis>relation</emphasis> is basically the mathematical
						  name for a table (speaking very loosely), and is the reason for the name
						  <emphasis>relational model</emphasis> (as an aside, the relational model is
						  very definitely <emphasis>not</emphasis> named for the idea of relationships
						  between tables). Data in a relational database is represented by tables, and
						  nothing but tables. This idea is known as <emphasis>The Information
						  Principle</emphasis> and is one reason for the simplicity and power of the
						  relational model.</para> 
					 <para>A <emphasis>relation</emphasis> can be defined informally
						  as consisting of a heading and a body:</para> 
					 <para> 
						  <itemizedlist> 
								<listitem> 
									 <para>The <emphasis>heading</emphasis> of a
										  relation is a set of <emphasis>attributes</emphasis>, or
										  <emphasis>columns</emphasis>, each of which has a unique name and a
										  <emphasis>data type</emphasis>.</para> 
								</listitem> 
								<listitem> 
									 <para>The <emphasis>body</emphasis> of a relation
										  is a <emphasis>set</emphasis> of <emphasis>tuples</emphasis>, or
										  <emphasis>rows</emphasis>, each with the same heading as the relation and
										  containing a value for each attribute of that heading.</para> 
								</listitem> 
						  </itemizedlist></para> 
					 <para>There are several key observations which should be made
						  in connection with this definition which are of critical importance in adhering
						  to the relational model and have been largely ignored by existing
						  products.</para> 
					 <para>Firstly, the body of a relation is a
						  <emphasis>set</emphasis> of tuples which, by definition, has no order and no
						  duplicates. These two facts have important consequences for the relational
						  algebra, which will be discussed in the next section.</para> 
					 <para>Secondly, the heading of a relation is a
						  <emphasis>set</emphasis> of attributes. Again, no order is assumed in the
						  heading, and no duplicates are allowed. Additionally, no attribute is allowed
						  to go unnamed, another fact which will turn out to be of crucial importance in
						  the relational algebra.</para> 
					 <para>Thirdly, note that the attributes of a relation are
						  defined on a type. This type is allowed to be any type whatsoever, including
						  relation and tuple types.</para> 
					 <para>Lastly, the tuples of a relation contain a
						  <emphasis>value</emphasis> for each attribute of the heading.</para> 
					 <para>A relational database is then a database in which all the
						  data is <emphasis>perceived</emphasis> as relations (relation variables more
						  precisely), and nothing but relations. Relations may be base or derived. A
						  <emphasis>base relation</emphasis> is a relation that is defined in terms of
						  its attributes. A <emphasis>derived relation</emphasis> (also called a
						  <emphasis>view</emphasis>) is a relation that is defined in terms of a
						  relation-valued expression that is allowed to reference other relations.
						  Regardless of whether a relation is base or derived, it should appear the same
						  to a user of the database. In other words, the user should not have to be aware
						  of how a given relation is defined, only that it exists. This concept is known
						  as <emphasis>logical data independence</emphasis> and is one of the main
						  factors in the ability of a data model to be transformed without affecting the
						  applications which use it.</para> 
					 <para>Perhaps the most important idea in the relational model
						  is that databases are a collection of facts. Each relation has a meaning or
						  <emphasis>predicate</emphasis> and the tuples in the relation correspond to
						  true <emphasis>propositions</emphasis>. For example, the predicate of an
						  employee relation might be: There is an employee identified by employee number
						  <emphasis>ID</emphasis> with name <emphasis>Name</emphasis>. The attributes of
						  the relation correspond to <emphasis>placeholders</emphasis> in the predicate.
						  Each tuple in the relation then supplies values for the placeholders in the
						  predicate, forming a true proposition. For example, the tuple &lt;E100, 'John
						  Smith'&gt; in the employee relation forms the proposition: There is an employee
						  identified by employee number <emphasis>E100</emphasis> with name
						  <emphasis>John Smith</emphasis>.</para> 
					 <para>The meaning, or predicate, of a given relation is not
						  just an attribute of base relations. The predicate for a derived relation is
						  inferred from the predicates of the relations involved in the defining
						  expression. In this way, meaning is ascribed not only to the base relation
						  variables in a given database, but also to the results of any query issued
						  against the database.</para> 
					 <formalpara> 
						  <title>A Note About Terminology:</title> 
						  <para>This section has introduced what appear to be
								duplicate terms for the familiar notions of tables, columns, and rows. The
								reason for this is that the relational model is a mathematical model, and the
								terms relation, attribute, and tuple are formal notions with very precise
								definitions. They are the formal <emphasis>counterparts</emphasis> of the
								informal notions of tables, columns, and rows, respectively, and allow for
								clear and unambiguous usage within formal contexts. In an informal discussion
								such as this one, the various terms are often used interchangeably.</para> 
					 </formalpara> 
				</sect2> 
				<sect2 id="DDGP1ManipulativeAspect"> 
					 <title><indexterm><primary>Relational Model of
									 Data</primary><secondary>Manipulative
									 Aspect</secondary></indexterm><indexterm><primary>Relational
									 Algebra</primary></indexterm>Manipulative Aspect</title> 
					 <para>The manipulative aspect of the relational model describes
						  how operators can be applied to relations to produce new relations. The
						  operators of the relational algebra provide the means to perform these
						  manipulations. It should be noted that the result of any relational operator is
						  itself a relation. Because of this, the results of any operation can in turn be
						  used as the arguments to some other operator. This concept is known as
						  <emphasis>closure</emphasis> and gives the relational algebra its expressive
						  power. If a relational operator returns a value that does not fit the
						  definition of a relation, closure is lost. The result is a decrease in
						  expressive power, and a corresponding increase in complexity.</para> 
					 <para>The basic operators of the relational algebra are:</para>
					 
					 <para> 
						  <itemizedlist> 
								<listitem> 
									 <para><emphasis>project</emphasis></para> 
								</listitem> 
								<listitem> 
									 <para><emphasis>restrict</emphasis></para> 
								</listitem> 
								<listitem> 
									 <para><emphasis>union</emphasis></para> 
								</listitem> 
								<listitem> 
									 <para><emphasis>difference</emphasis></para> 
								</listitem> 
								<listitem> 
									 <para><emphasis>join</emphasis></para> 
								</listitem> 
						  </itemizedlist></para> 
					 <para>Three other operators (<emphasis>intersection</emphasis>,
						  <emphasis>product</emphasis>, and <emphasis>divide</emphasis>) are usually
						  considered as basic operators as well, but they are not primitive, and so will
						  be discussed in the context of the other operators. The following discussion
						  briefly describes each operator. For a full discussion of the operators of the
						  relational algebra, refer to the D4 Language Guide in this manual.</para> 
					 <para>The <emphasis>project</emphasis> operator takes as input
						  a single relation, and removes a given set of columns. The result is a relation
						  with a heading which is a subset of the heading of the input relation. Note
						  that projection will eliminate duplicates, if necessary.</para> 
					 <para>The <emphasis>restrict</emphasis> operator takes as input
						  a single relation, and applies a condition, or filter, to the body of the
						  relation. The result is a relation with the same heading, and the set of rows
						  for which the condition evaluates to true.</para> 
					 <para>The <emphasis>union</emphasis> operator takes as input
						  two relations, both with the same heading, and returns a relation with the same
						  heading as the input relations, and a body that includes the rows from both
						  input relations, with duplicates eliminated.</para> 
					 <para>The <emphasis>difference</emphasis> operator takes as
						  input two relations, both with the same heading, and returns a relation with
						  the same heading as the input relations, and a body that includes a row for
						  each row that is in the first relation, but not the second.</para> 
					 <para>The <emphasis>join</emphasis> operator takes as input two
						  relations, not necessarily with the same heading, and returns a relation with a
						  heading that is the union (with duplicates eliminated) of the headings of the
						  input relations, and a body that contains a row for each combination of rows in
						  the input relations where the given rows have the same value for the common
						  columns of the input relations, if any. The <emphasis>intersection</emphasis>
						  and <emphasis>product</emphasis> operators are both special cases of this
						  operator. The <emphasis>intersection</emphasis> is the case where the headings
						  of the input relations have all columns in common, and the
						  <emphasis>product</emphasis> is the case where the headings of the input
						  relations have no columns in common. This operator is also called the
						  <emphasis>natural join</emphasis> operator because it relies on the names of
						  the columns in the headings to determine the join condition. Other forms of
						  this operator exist, but are not important for present purposes.</para> 
					 <para>These five operators make up the core of the relational
						  algebra. Together they constitute a complete system for deriving relation
						  values. This notion is known as <emphasis>relational completeness</emphasis>. A
						  language is said to be <emphasis>relationally complete</emphasis> if it is at
						  least as powerful as the algebra.</para> 
					 <para>These manipulative aspects of the relational model
						  provide the basis for the power and simplicity of relational systems. The
						  purpose of the relational algebra is to allow the writing of relational
						  expressions [1]. These expressions can then be used in a variety of important
						  tasks including data retrieval, data manipulation, integrity constraint
						  definition, view definition, and so on. </para> 
				</sect2> 
				<sect2 id="DDGP1IntegrityAspect"> 
					 <title><indexterm><primary>Relational Model of
									 Data</primary><secondary>Integrity
									 Aspect</secondary></indexterm><indexterm><primary>Integrity</primary></indexterm>Integrity
						  Aspect</title> 
					 <para>The integrity aspect of the relational model is concerned
						  with what the data in a database means. <emphasis>Integrity</emphasis> refers
						  to the accuracy or correctness of data in the database [1]. A
						  <emphasis>constraint</emphasis> is a truth-valued expression which must
						  evaluate to true for the data in the database. There are two types of
						  constraints in a database, <emphasis>type constraints</emphasis> and
						  <emphasis>database constraints</emphasis>. Type constraints are discussed as
						  part of the Scalar Types topic later in this part. In this section we will be
						  concerned with database constraints specifically.</para> 
					 <para>Integrity constraints, also called <emphasis>business
						  rules</emphasis> are used in a database to inform the system what conditions
						  must be satisfied. For example, an employees database might have the constraint
						  that all salaries must be in the range $15,000 to $150,000. Such a constraint
						  is expressed as a truth-valued relational expression. For example: 
						  <programlisting><emphasis role="bold">not exists</emphasis> Employees <emphasis role="bold">where</emphasis> Salary &lt; $15000 <emphasis role="bold">or</emphasis> Salary &gt; $150000</programlisting> Once the constraint has been declared, the system is
						  responsible for enforcing it. Any modification statement which would cause this
						  constraint to evaluate to false (or <emphasis>violates</emphasis> the
						  constraint) is rejected.</para> 
					 <para>It is important to note that the expression for a given
						  constraint is allowed to be arbitrarily complex. For example: 
						  <programlisting><emphasis role="bold">not exists</emphasis> ((Employees <emphasis role="bold">over</emphasis> { ID }) <emphasis role="bold">join</emphasis> (Users <emphasis role="bold">over</emphasis> { ID }))</programlisting>This constraint references multiple table variables in the
						  system, and enforces the constraint that no employee is allowed to be a user,
						  and vice-versa. Two types of integrity constraints are of such importance that
						  they have their own declarative specification in most systems, including the
						  Dataphor Server. They are <emphasis>key</emphasis> constraints and
						  <emphasis>reference</emphasis> constraints.</para> 
					 <para>A key constraint enforces that some subset, not
						  necessarily proper and possibly empty, of the columns of a given table variable
						  must be unique for all rows in the table variable. For example, the 
						  <phrase role="code">Employees</phrase> table could have an 
						  <phrase role="code">ID</phrase> column that serves as the
						  unique identifier for each employee. It is important to note that this is just
						  a special case of a database wide integrity constraint. For example: 
						  <programlisting>Count(Employees) = Count(Employees <emphasis role="bold">over</emphasis> { ID })</programlisting>is an equivalent formulation of the constraint.</para> 
					 <para>A reference constraint (also called a <emphasis>foreign
						  key</emphasis>) enforces that all the values of some set of columns in one
						  table exist as values for some set of columns in another table. For example,
						  the 
						  <phrase role="code">Employees</phrase> table could have a 
						  <phrase role="code">Dept_ID</phrase> column that is
						  required to be a department in the 
						  <phrase role="code">Departments</phrase> table. This type
						  of constraint enforces what is known as <emphasis>referential
						  integrity</emphasis>, a very common special case of integrity in general. This
						  constraint is equivalent to the expression: 
						  <programlisting><emphasis role="bold">not exists</emphasis> ((Employees <emphasis role="bold">over</emphasis> { Dept_ID }) <emphasis role="bold">minus</emphasis> 
	(Departments <emphasis role="bold">over</emphasis> { ID } <emphasis role="bold">rename</emphasis> { ID Dept_ID }))</programlisting></para> 
				</sect2> 
		  </sect1> 
		  <sect1 id="DDGP1TransactionManagement"> 
				<title><indexterm><primary>Transaction
								Management</primary></indexterm>Transaction Management</title> 
				<para><emphasis>Transaction management</emphasis> is concerned with
					 ensuring that users of a system can perform the operations they request as
					 though they were the only user of the system, and without fear of system
					 failure. A <emphasis>transaction</emphasis> is the basic unit of work used in
					 transaction management to accomplish these goals. Every transaction has the
					 following fundamental properties, also known as the <emphasis>ACID</emphasis>
					 properties: 
					 <itemizedlist> 
						  <listitem> 
								<para>Atomicity: The transaction is a single unit of
									 work, so it is either completed, or rolled back as a whole.</para> 
						  </listitem> 
						  <listitem> 
								<para>Consistency: The transaction is guaranteed to
									 transform the database from one consistent state to another.</para> 
						  </listitem> 
						  <listitem> 
								<para>Isolation: The transaction is guaranteed to
									 perform as though it was the only transaction running.</para> 
						  </listitem> 
						  <listitem> 
								<para>Durability: The effects of a committed
									 transaction are guaranteed to be permanent, even in the event of a system
									 failure.</para> 
						  </listitem> 
					 </itemizedlist></para> 
				<para>Ensuring that a transaction meets these requirements is a
					 highly non-trivial undertaking. Any database application would ideally meet
					 these requirements, but one written without the benefit of a DBMS with
					 transaction support would be unlikely to do so. There are many complex and
					 difficult issues to be addressed in transaction management. Thankfully, they
					 can all be isolated and made transparent by the DBMS. Furthermore, because of
					 The Information Principle, the relational model provides an ideal platform for
					 implementing transaction support.</para> 
				<sect2 id="DDGP1Atomicity"> 
					 <title><indexterm><primary>Atomicity</primary></indexterm>Atomicity</title>
					 
					 <para>Atomicity means that the transaction is perceived as a
						  single unit of work. The classic example is that of a bank transaction where
						  one account is credited and another is debited. Clearly, both these updates
						  must take place in order for the correct transformation to occur. By wrapping
						  both updates inside a database transaction, the DBMS ensures that this is the
						  case.</para> 
				</sect2> 
				<sect2 id="DDGP1Consistency"> 
					 <title><indexterm><primary>Consistency</primary></indexterm>Consistency</title>
					 
					 <para>Consistency means that the transaction is guaranteed to
						  transform the database from one consistent state to another. The DBMS ensures
						  that the transaction does not violate any integrity constraints at commit time.
						  If a violation is detected, the transaction is rolled back as a whole.</para> 
				</sect2> 
				<sect2 id="DDGP1Isolation"> 
					 <title><indexterm><primary>Isolation</primary></indexterm>Isolation</title>
					 
					 <para>Isolation guarantees that the transaction runs as though
						  it was the only transaction running on the system. This concept is also known
						  as <emphasis>concurrency</emphasis> and comes in two general flavors,
						  <emphasis>optimistic</emphasis> and <emphasis>pessimistic</emphasis>.
						  Pessimistic concurrency ensures that a transaction is isolated by protecting
						  all the resources involved in the transaction with <emphasis>locks</emphasis>.
						  Optimistic concurrency does not take locks on transaction resources, rather it
						  ensures that the data has not been changed by another transaction before it is
						  modified. The vast majority of existing systems use pessimistic concurrency.
						  Optimistic concurrency is used mainly by client applications to ensure
						  concurrency without involving the DBMS 
						  <footnote> 
								<para>Of course, there are many different approaches to
									 concurrency implementation. For simplicity, we do not discuss the various
									 flavors and variations of optimistic and pessimistic concurrency control
									 mechanisms in use today. These two categories are sufficient for our
									 purposes.</para> 
						  </footnote>. In this section, we discuss pessimistic
						  concurrency.</para> 
					 <para>Isolation is usually achieved in transaction managers
						  through the use of locking. The protocol a transaction uses to protect the
						  resources it consumes determines the degree of isolation which is achieved by
						  that transaction. There are three general kinds of problems which can occur as
						  a result of transactions running concurrently: 
						  <itemizedlist> 
								<listitem> 
									 <para><emphasis>Lost update</emphasis></para> 
									 <para>A transaction T1 changes the salary for an
										  employee E1 to $15000. Another transaction T2 changes the salary for the same
										  employee E1 to $20000. If there is no control on updates, one or the other of
										  these updates will be lost.</para> 
								</listitem> 
								<listitem> 
									 <para><emphasis>Dirty read</emphasis></para> 
									 <para>A transaction T1 changes the salary for an
										  employee E1 to $15000. Another transaction T2 then reads the salary value for
										  employee E1. If T1 subsequently rolls back, then any work done by T2 based on
										  the salary value for the employee could be wrong. Transaction T2's read of the
										  salary value was a dirty read.</para> 
								</listitem> 
								<listitem> 
									 <para><emphasis>Non-repeatable
										  read</emphasis></para> 
									 <para>A transaction T1 reads the salary for an
										  employee E1. Another transaction T2 then updates the salary value for that same
										  employee, and then transaction T1 attempts to read the salary value again.
										  Transaction T1's read is a non-repeatable read, because it receives different
										  values for subsequent reads.</para> 
								</listitem> 
						  </itemizedlist></para> 
					 <para>Clearly these behaviors will cause problems if not
						  prevented. In order to prevent these problems, there are four degrees of
						  isolation: 
						  <itemizedlist> 
								<listitem> 
									 <para>Degree 0, or chaos. This isolation level is
										  reserved for certain system level processes such as recovery.</para> 
								</listitem> 
								<listitem> 
									 <para>Degree 1, or browse. This isolation level
										  prevents lost updates.</para> 
								</listitem> 
								<listitem> 
									 <para>Degree 2, or cursor stability. This isolation
										  level prevents lost updates and no dirty reads.</para> 
								</listitem> 
								<listitem> 
									 <para>Degree 3, or isolated. This isolation level
										  prevents lost updates and ensures repeatable reads, which implies no dirty
										  reads. This is the highest degree of isolation and provides complete
										  isolation.</para> 
								</listitem> 
						  </itemizedlist></para> 
					 <para>These isolation levels allow users of the system to
						  control what level of concurrency a given transaction should use. Isolation is
						  achieved at the cost of concurrency, in other words, a completely isolated
						  transaction takes locks on every resource it consumes, and therefore causes
						  more contention. It has been shown that if all transactions run at least degree
						  1 isolation, then no transaction will violate the isolation of another. In
						  other words, as long as all transactions run at browse or higher, each
						  transaction is guaranteed to run at the isolation level it has selected
						  [12].</para> 
				</sect2> 
				<sect2 id="DDGP1Durability"> 
					 <title><indexterm><primary>Durability</primary></indexterm>Durability</title>
					 
					 <para>Durability guarantees that if a transaction commits, its
						  changes are made permanent. In the event of system or hardware failure, a
						  database system must ensure that the data is correct, and that committed
						  changes to the database are still available on system recovery.</para> 
				</sect2> 
		  </sect1> 
		  <sect1 id="DDGP1Conclusion"> 
				<title>Conclusion</title> 
				<para>We have reviewed the fundamentals of database systems and the
					 relational model. We have illustrated some of the benefits of using database
					 systems in general, and relational systems in particular. Throughout the rest
					 of this part, we will refer to the concepts covered in this chapter without
					 explanation.</para> 
		  </sect1> 
	 </chapter> 
	 <chapter id="DDGApplicationDevelopmentConcepts"> 
		  <title><indexterm><primary>Application Development
						  Concepts</primary></indexterm>Application Development Concepts</title> 
		  <para>This chapter discusses how the declarative approach can be
				applied to application development by utilizing the logical model exposed by a
				relational database management system. It describes how this approach addresses
				the issues discussed in the 
				<ulink url="DDGApplicationDevelopmentConsiderations.html"
				type="xref"><citetitle>Application Development
						  Considerations</citetitle></ulink> chapter of this part, and how a declarative
				platform provides a foundation for Automated Application Development
				(AAD).</para> 
		  <sect1 id="DDGApplicationDevelopmentConcepts-Schema"> 
				<title><indexterm><primary>Application
								Schema</primary></indexterm><indexterm><primary>Application Development
								Concepts</primary><secondary>Application
								Schema</secondary></indexterm>Application Schema</title> 
				<para>The logical model presented by a relational database
					 management system allows for the complete definition of the structural
					 components of any application. It allows for the definition of data types,
					 operators, tables, views, and business-rules that together constitute the
					 schema (or business model) of the application, and completely model the
					 structure of the data, the integrity constraints to be enforced, as well as any
					 process logic specific to the application. Collectively, this declarative
					 definition of the application is called the <emphasis>application
					 schema</emphasis>.</para> 
				<sect2 id="DDGApplicationDevelopmentConcepts-Schema-DataTypes"> 
					 <title><indexterm><primary>Data Types</primary><secondary>As
									 Application Schema</secondary></indexterm><indexterm><primary>Application
									 Schema</primary><secondary>Data Types</secondary></indexterm>Data Types</title>
					 
					 <para>Data types provide the fundamental unit of data
						  representation within the logical model. They allow the developer to describe
						  the types of data of interest to the application. Of course, the database
						  system provides some basic data types such as strings and integers, but it
						  should also allow for the definition of new data types of arbitrary complexity.
						  For example, if the application must deal with spatial data, a coordinate type
						  could be introduced to model geographic coordinates.</para> 
					 <para>Conceptually, a data type is a set of values. These
						  values have various kinds of representations such as the physical
						  representation of the value that is internal to the system, and the logical
						  representation of the value that is exposed in the application schema. This
						  distinction allows the implementation, or physical representation, of values to
						  be changed without affecting the usage of the value in the application schema.
						  An ideal platform would allow not only for the definition of data types, but
						  the description of the various representations of values of those types as
						  well.</para> 
					 <para>Once a data type is available in the schema of an
						  application, that data type can be used anywhere within the application. It can
						  serve as the type of a column in a table or view, it can be used within the
						  definition of an operator as the declared type of a local variable, and it can
						  also be used as the declared type of a parameter to an operator. By defining a
						  data type, the application developer allows the system to model values of the
						  type in question.</para> 
				</sect2> 
				<sect2 id="DDGApplicationDevelopmentConcepts-Schema-Operators"> 
					 <title><indexterm><primary>Operators</primary><secondary>As
									 Application Schema</secondary></indexterm><indexterm><primary>Application
									 Schema</primary><secondary>Operators</secondary></indexterm>Operators</title> 
					 <para>Operators allow the developer to define and reuse the
						  behavior of the application. Conceptually, an operator is just a predefined set
						  of steps to be taken. Once defined, an operator can be invoked from anywhere
						  within the application. From an imperative programming standpoint, operators
						  provide an abstraction over statements and expressions of the language, meaning
						  that anywhere statements and expressions can appear, operator invocations can
						  appear in their place.</para> 
					 <para>For example, a distance operator could be defined to
						  determine the distance between two coordinates. The entire application can then
						  make use of the distance calculation, simply by invoking the operator. Whether
						  in a restriction clause in a view definition, or deep within the processing
						  logic of the application, the same operator can be used.</para> 
					 <para>Operators generally come in two varieties, those that
						  return values, and those that do not. Some languages make the distinction
						  explicit by defining functions as operators that return values, and procedures
						  as operators that do not. Others simply introduce a special
						  <emphasis>void</emphasis> type to indicate that a given operator does not
						  return a value. In either case, the concept is the same.</para> 
					 <para>Operators are also allowed to take parameters, and can
						  optionally update the values of those parameters (if the parameter is a
						  variable, of course). Operators can take any number of parameters, including
						  none, and those parameters are allowed to be of any type. The result of an
						  operator, if any, is also allowed to be of any type.</para> 
					 <para>Some operators are generally considered part of the
						  language definition. These are generally called <emphasis>built-in</emphasis>
						  operators and include such functions as 
						  <phrase role="code">+</phrase> and 
						  <phrase role="code">-</phrase>.</para> 
					 <para>Because operators can appear anywhere statements and
						  expressions can appear, they can be used to define other elements of the
						  application schema. For example, operators can reference other operators,
						  constraint and view definitions can invoke operators, and so on. Using
						  operators, the developer can completely describe the required behavior of any
						  application.</para> 
				</sect2> 
				<sect2
				id="DDGApplicationDevelopmentConcepts-Schema-TablesAndViews"> 
					 <title><indexterm><primary>Tables</primary><secondary>As
									 Application
									 Schema</secondary></indexterm><indexterm><primary>Views</primary><secondary>As
									 Application Schema</secondary></indexterm><indexterm><primary>Application
									 Schema</primary><secondary>Tables And Views</secondary></indexterm>Tables And
						  Views</title> 
					 <para>Tables and views (or derived tables) provide the
						  fundamental unit of structure within the logical model. Tables and views are
						  both <emphasis>relation variables</emphasis>, differing only in how they are
						  defined. A table is defined in terms of the columns it contains, while a view
						  is defined in terms of some relational expression. Once defined, tables and
						  views behave the same. They are interchangeable, meaning that anywhere a
						  reference to a table can appear, a reference to a view can appear. In
						  particular, this is true of data modification statements. </para> 
					 <para>This feature of a relational system is called
						  <emphasis>logical data independence</emphasis> and is one of the key enabling
						  factors in automated application development. In particular, it means that the
						  client portions of the application can always deal with data in the database in
						  the same way. Whether that data is defined in terms of a base table, or an
						  arbitrarily complex view, the application will always see a relation. This
						  uniformity of data access allows much of the presentation layer to be
						  completely automated.</para> 
					 <para>As an example of logical data independence, consider a
						  simple contact management application. Suppose the applications contains a
						  customer table with a column for the associated region such as <emphasis>East
						  Coast</emphasis> or <emphasis>West Coast</emphasis>. A view of east coast
						  customers can be created using a simple restriction. The resulting view behaves
						  exactly the same as the actual customer table, except that only east coast
						  customers are available.</para> 
				</sect2> 
				<sect2 id="DDGApplicationDevelopmentConcepts-Schema-BusinessRules">
					 
					 <title><indexterm><primary>Business
									 Rules</primary><secondary>As Application
									 Schema</secondary></indexterm><indexterm><primary>Application
									 Schema</primary><secondary>Business Rules</secondary></indexterm>Business
						  Rules</title> 
					 <para>Business rules allow the developer to declaratively
						  specify the meaning of the data in the model. Once the system knows what
						  business-rules must be enforced, it is responsible for rejecting any
						  modifications that would violate those rules.</para> 
					 <para>Business-rules generally come in two varieties:
						  constraints, and stimulus-response rules. Constraints specify some condition
						  that must always hold, while stimulus-response rules allow the system to take
						  action in response to some event such as a data modification.</para> 
					 <sect3 id="DDGConstraints"> 
						  <title><indexterm><primary>Constraints</primary><secondary>As
										  Application Schema</secondary></indexterm>Constraints</title> 
						  <para>Constraints generally take the form of some
								expression that must evaluate to true. Constraints can be placed on data types,
								as well as on the database as a whole. For practical reasons, database
								constraints can be declared at many different levels. The following list
								illustrates these possibilities: 
								<itemizedlist> 
									 <listitem> 
										  <indexterm><primary>Type
													 Constraints</primary><secondary>As Application Schema</secondary></indexterm> 
										  <para>Type Constraints</para> 
									 </listitem> 
									 <listitem> 
										  <indexterm><primary>Column
													 Constraints</primary><secondary>As Application Schema</secondary></indexterm> 
										  <para>Column Constraints</para> 
									 </listitem> 
									 <listitem> 
										  <indexterm><primary>Row
													 Constraints</primary><secondary>As Application Schema</secondary></indexterm> 
										  <para>Row Constraints</para> 
									 </listitem> 
									 <listitem> 
										  <indexterm><primary>Table
													 Constraints</primary><secondary>As Application Schema</secondary></indexterm> 
										  <para>Table Constraints</para> 
									 </listitem> 
									 <listitem> 
										  <indexterm><primary>Transition
													 Constraints</primary><secondary>As Application Schema</secondary></indexterm> 
										  <para>Transition Constraints</para> 
									 </listitem> 
									 <listitem> 
										  <indexterm><primary>Database
													 Constraints</primary><secondary>As Application Schema</secondary></indexterm> 
										  <para>Database Constraints</para> 
									 </listitem> 
								</itemizedlist></para> 
						  <para>Type constraints are concerned with defining the set
								of valid values of a given data type. For example, the SSN type could ensure
								that values of type SSN have 9 digits, with dashes in the appropriate
								places.</para> 
						  <para>Column constraints are concerned with defining the
								set of valid values for a given column. Of course, this constraint is in
								addition to the implicit constraint defined by the data type of the
								column.</para> 
						  <para>Row constraints allow the developer to specify
								constraints that are concerned with multiple columns in a single row. For
								example, the ToDate must be greater than the FromDate.</para> 
						  <para>Table constraints define the valid values for a
								particular table. A common example of a table constraint is a
								<emphasis>key</emphasis> constraint, indicating that no two rows in the same
								table may have the same values for the columns in the key.</para> 
						  <para>Transition constraints define the valid
								<emphasis>transitions</emphasis> for data in the database. For example, a
								person's marital status may change from <emphasis>married</emphasis> to
								<emphasis>divorced</emphasis>, but not from <emphasis>married</emphasis> to
								<emphasis>single</emphasis>.</para> 
						  <para>Database constraints allow rules to be enforced that
								involve multiple tables in the database. A common example of a database
								constraint is a <emphasis>referential integrity</emphasis> constraint,
								indicating that every row in one table must have a corresponding row in another
								table.</para> 
						  <para>The majority of business-rules are constraints, and a
								system which allowed for the declarative enforcement of all these types of
								constraints would eliminate a significant amount of development effort. Rather
								than enforcing these rules on a case-by-case basis within the presentation
								layer, the system would simply ensure that no modification is allowed that
								would violate any declared rule. The result is that the presentation layer can
								be developed without regard for enforcing integrity.</para> 
					 </sect3> 
					 <sect3 id="DDGStimulus-ResponseRules"> 
						  <title><indexterm><primary>Stimulus-Response
										  Rules</primary><secondary>As Application
										  Schema</secondary></indexterm>Stimulus-Response Rules</title> 
						  <para>Stimulus-Response rules allow the developer to
								participate in the decisions to be made when modifications occur in the system.
								For example, an inventory control system could automatically place an order
								whenever the in-stock quantity of an item falls below a certain level.</para> 
					 </sect3> 
				</sect2> 
				<sect2 id="DDGApplicationDevelopmentConcepts-Schema-Metadata"> 
					 <title><indexterm><primary>Metadata</primary><secondary>As
									 Application Schema</secondary></indexterm><indexterm><primary>Application
									 Schema</primary><secondary>Metadata</secondary></indexterm>Metadata</title> 
					 <para>In addition to these elements of the logical model, the
						  schema of a given application could be extended with additional data about the
						  data or <emphasis>metadata</emphasis>. These attributes (or
						  <emphasis>tags</emphasis>) would allow application-specific information to be
						  associated with any level of the application schema. For example, a phone
						  number data type could include a metadata tag indicating that the display title
						  for columns of this type is <emphasis>Phone #</emphasis>.</para> 
					 <para>By associating this metadata directly with the
						  application schema it becomes available anywhere within the application, rather
						  than tucked away in the definition of various forms in the presentation layer.
						  This centralization improves the maintenance cycle as well. For example, if the
						  title is supposed to be <emphasis>Phone #/Ext</emphasis>, the change can be
						  made one time in the application schema, and the presentation layer would react
						  to the change appropriately.</para> 
					 <para>This association with the application schema would also
						  allow the relational system's type inference mechanism to be extended to
						  include metadata inference. For example, the metadata associated with a column
						  definition in a table could be inferred through any view that involved that
						  column.</para> 
				</sect2> 
		  </sect1> 
		  <sect1 id="DDGApplicationDevelopmentConcepts-Presentation"> 
				<title><indexterm><primary>Presentation</primary></indexterm><indexterm><primary>Application
								Development
								Concepts</primary><secondary>Presentation</secondary></indexterm>Presentation</title>
				
				<para>The presentation layer of any application is responsible for
					 interaction with the users. It must provide services to allow users to enter,
					 retrieve and maintain data, and perform the processes involved in the
					 application. In short, it must provide a consistent and intuitive interface to
					 the schema of the application.</para> 
				<para>Many of the most difficult and tedious issues in application
					 development arise in this layer. The presentation layer is responsible for
					 retrieving the data from the database, presenting it to the user, allowing the
					 user to interact with the data, and then updating the data in the database. In
					 general, this process presents many difficult challenges. However, by layering
					 the solution on top of the relational model and building on existing rapid
					 application development techniques, a highly automated solution can be
					 achieved.</para> 
				<sect2
				id="DDGApplicationDevelopmentConcepts-Presentation-DataAccessLayer"> 
					 <title><indexterm><primary>Data Access
									 Layer</primary></indexterm><indexterm><primary>Presentation</primary><secondary>Data
									 Access Layer</secondary></indexterm>Data Access Layer</title> 
					 <para>The first layer that must be automated is the data access
						  layer. This is often called push/pull code, because it involves pulling data
						  out of the database, changing or presenting it in some way, and then pushing it
						  back into the database. This process necessarily involves the transformation of
						  data from the values that the system understands, into a format suitable for
						  presentation purposes, and back again. It also involves buffering the data in
						  the client while it is being presented to or manipulated by users, and
						  maintaining various state such as whether or not the data is being edited, the
						  position within the result set, and so on.</para> 
					 <sect3 id="DDGRepresentations"> 
						  <title><indexterm><primary>Representations</primary><secondary>Data
										  Access Layer and</secondary></indexterm><indexterm><primary>Data Access
										  Layer</primary><secondary>Representations</secondary></indexterm>Representations</title>
						  
						  <para>Recall that the logical model provides for the
								definition of representations of types. This mechanism provides an excellent
								solution for the presentation layer, in that the display representation of a
								particular type of value can be defined in the application schema. If the
								client consuming the data is aware of the concept of a representation, an
								appropriate representation can be selected for use in the presentation layer.
								It could even download the code to translate values to and from the display
								representation to the client so that the development could remain on the
								server, while the transformation actually takes place on the client.</para> 
						  <para>For example, suppose the coordinate type exposes a
								string representation suitable for presentation layer usage. The logic required
								to transform a string to and from a coordinate value is contained within the
								definition of the representation. The client could simply access this
								definition and use it to perform the required translation. The user sees a
								presentation layer representation of the coordinate value such as <emphasis>100
								10' 5.4"</emphasis>, and is allowed to enter a coordinate value using the same
								format.</para> 
						  <para>Because the implementation for the representation is
								housed centrally with the application schema, changing the presentation layer
								format is simply a matter of updating the definition of the representation. The
								automated presentation layer reacts to the change appropriately.</para> 
					 </sect3> 
					 <sect3 id="DDGTable-LevelAccess"> 
						  <title><indexterm><primary>Table-Level
										  Access</primary></indexterm><indexterm><primary>Data Access
										  Layer</primary><secondary>Table-Level Access</secondary></indexterm>Table-Level
								Access</title> 
						  <para>Because the logical model exposes data as tables, all
								presentation and manipulation can be accomplished through a table-level access
								mechanism. One possible mechanism for this interaction is known as a
								<emphasis>cursor</emphasis>. A cursor provides a row-level interface for
								accessing the data from an arbitrary result set. Cursors expose navigational
								functionality such as moving to the next row, and support retrieving the
								currently selected row. In addition, a cursor could expose functionality for
								searching and updating data.</para> 
						  <para>One distinct advantage of using cursors over other
								potential data access mechanisms is that they provide a
								<emphasis>relative</emphasis>, rather than an <emphasis>absolute</emphasis>
								positioning mechanism. This allows the client to deal with result sets of
								arbitrary size, and enables more general searching and buffering mechanisms.
								These in turn allow more of the data access layer to be automated within the
								client framework.</para> 
					 </sect3> 
					 <sect3 id="DDGClient-ServerInteraction"> 
						  <title><indexterm><primary>Client-Server
										  Interaction</primary></indexterm><indexterm><primary>Data Access
										  Layer</primary><secondary>Client-Server
										  Interaction</secondary></indexterm>Client-Server Interaction</title> 
						  <para>In addition to these basic services, the data access
								layer of a declarative platform could provide extensive mechanisms for
								interaction between the client and the server. The application schema exposes a
								tremendous amount of detail about the data. What it should look like, how it
								should be displayed, what other data is related, default values,
								business-rules, and so on. Clearly, any application that deals with such a
								model should, as much as possible, be based on the structures of the
								application schema.</para> 
						  <para>In order to enable more automation in the clients,
								the data access layer could expose services for server participation in client
								interfaces. For example, when inserting a new row, the client could ask the
								server to provide default values for any columns in the table. Validation rules
								could also be checked in this way, enabling a much more sophisticated
								user-interface, without additional developer effort. The data access layer
								could automatically invoke these services when necessary.</para> 
					 </sect3> 
				</sect2> 
				<sect2
				id="DDGApplicationDevelopmentConcepts-Presentation-EnforcingBusiness-Rules"> 
					 <title><indexterm><primary>Enforcing
									 Business-Rules</primary></indexterm><indexterm><primary>Presentation</primary><secondary>Enforcing
									 Business-Rules</secondary></indexterm>Enforcing Business-Rules</title> 
					 <para>Even a moderately complex application will likely include
						  business-rules that span table variables in the database. For example, an
						  employee cannot belong to a department that does not exist, and so on. However,
						  these types of constraints necessarily involve some mechanism for deferred
						  constraint checking, usually transactions. The constraints are allowed to be
						  violated within the transaction, and then checked at transaction commit. If the
						  constraint is violated, the transaction is rolled-back, and an error is
						  raised.</para> 
					 <para>While this approach to enforcement works when developing
						  server-side logic, the data entry patterns produced by the natural navigation
						  of the relationships in the database tend to violate these types of
						  constraints. For example, when entering an employee, an item in the list of
						  phone numbers for the employee is "posted" through the data access layer while
						  the employee itself is still being "inserted" in the client interface. This
						  leads to a constraint violation, and the developer is usually left to resolve
						  the problem in client-side code.</para> 
					 <para>In a declarative system, the system could determine which
						  constraints would be violated by such a transaction, and provide an
						  optimistically concurrent transaction to buffer the input of the data until all
						  data is present, then utilize a standard transaction to post the entire batch.
						  If the data access layer then exposed these services, the clients could
						  automatically take advantage of them, all without developer
						  intervention.</para> 
				</sect2> 
				<sect2
				id="DDGApplicationDevelopmentConcepts-Presentation-SearchInterfaces"> 
					 <title><indexterm><primary>Search
									 Interfaces</primary></indexterm><indexterm><primary>Presentation</primary><secondary>Search
									 Interfaces</secondary></indexterm>Search Interfaces</title> 
					 <para>One of the most difficult interfaces in any application
						  is the generic search. For example, provide the user with the ability to locate
						  an arbitrary contact by name or SSN within the entire organization. If the
						  contact table contains millions of rows, this becomes a non-trivial task,
						  usually resolved by filtering on a case-by-case basis within the presentation
						  layer.</para> 
					 <para>If the data access layer provided a mechanisms for
						  relative positioning of the cursor, and sufficient services for searching
						  within the result set, then the clients could provide a "sliding window" over a
						  given result set, ordered by some criteria. The client and server could work
						  together to ensure that only the data the client actually requested was
						  retrieved (not the whole table). This solution not only provides the end-user
						  with an intuitive incremental search, but utilizes network and database
						  resources efficiently and scales well both in terms of users and data volume,
						  all without developer intervention.</para> 
				</sect2> 
				<sect2
				id="DDGApplicationDevelopmentConcepts-Presentation-User-InterfaceDerivation"> 
					 <title><indexterm><primary>User-Interface
									 Derivation</primary></indexterm><indexterm><primary>Presentation</primary><secondary>User-Interface
									 Derivation</secondary></indexterm>User-Interface Derivation</title> 
					 <para>If all these services could be provided generically for
						  arbitrary perspectives of the application schema, then the benefits of logical
						  data independence can be applied not only to expressions and statements within
						  the server-side process logic, but to the user-interfaces produced in the
						  presentation layer consuming the application schema. In other words, the
						  declarative approach, if properly realized, enables the automation of
						  user-interfaces based on the definitions contained within the application
						  schema.</para> 
					 <para>In it's simplest form, user-interface derivation involves
						  analyzing the structure and metadata of a given result set, and producing a
						  user-interface based on that structure. Note that due to the type and metadata
						  inference mechanisms of the relational system, this process will work for
						  <emphasis>arbitrary</emphasis> expressions, not just base tables.</para> 
					 <para>In addition to these basic elements, the system could
						  analyze the relationship of a given result set with the structures in the
						  application schema, and provide appropriate user-interface elements for
						  navigating the relationships of the application schema. For example, because
						  the employee types table is referenced by the type column of the employee
						  table, the resulting user-interface could provide a lookup into the employee
						  types table, simply based on the existence of the reference constraint. Again,
						  because of type inference, this process will work for arbitrary expressions,
						  not just base tables. A view of the employees table will still be aware of the
						  lookup to the employee types table.</para> 
					 <para>Ideally, this process will produce a complete and
						  intuitive user-interface for manipulating the application schema. However,
						  there may be cases where the resulting user-interfaces will not meet the
						  requirements of the application. In order to address this issue, the
						  declarative system must provide mechanisms for steering this process. Such
						  mechanisms may include the use of metadata in the appropriate places in the
						  application schema, customizing the appearance of the resulting interfaces, or,
						  in the most extreme cases, departing from the process entirely and reverting to
						  manually building user-interfaces. If the platform is layered properly, then
						  the services enabled by the data access layer will still be available when
						  customizing derived user-interfaces or building user-interfaces
						  manually.</para> 
					 <para>Additionally, as new user-interface patterns are
						  encountered, the system could be extended to handle them in future
						  applications, resulting in continual improvement of user-interface automation
						  as the system evolves.</para> 
				</sect2> 
		  </sect1> 
		  <sect1 id="DDGApplicationDevelopmentConcepts-PhysicalRealization"> 
				<title><indexterm><primary>Physical
								Realization</primary></indexterm><indexterm><primary>Application Development
								Concepts</primary><secondary>Physical
								Realization</secondary></indexterm>Physical Realization</title> 
				<para>In addition to the application schema and presentation
					 layers, any application must ultimately run in some production environment.
					 These environments often change rapidly, forcing changes in the applications.
					 By utilizing a platform based on the declarative approach, the application can
					 be defined one time. Changes in the software environments can be handled by the
					 system, rather than the application. To redeploy the application onto a new
					 platform, only the system must change, not each application built on that
					 system.</para> 
				<para>Physical realization also involves potential integration
					 problems. Data required by the application may already be housed in existing
					 external sources, and the costs of migrating the data and associated logic may
					 be prohibitive. The platform must provide the ability to treat data in the same
					 way regardless of where it is located, or what type of system it is housed
					 within. This would result in a high degree of physical data independence, which
					 would allow data from any source to be consumed by clients of the system. This
					 physical data independence would also allow an existing application to be
					 redeployed onto a completely different storage system with little or no
					 modification.</para> 
		  </sect1> 
		  <sect1 id="DDGApplicationDevelopmentConcepts-Development"> 
				<title><indexterm><primary>Development</primary></indexterm><indexterm><primary>Application
								Development
								Concepts</primary><secondary>Development</secondary></indexterm>Development</title>
				
				<para>In addition to the benefits already discussed in the previous
					 sections, the declarative approach provides several benefits related to the
					 development process itself. These benefits are chiefly due to the high degree
					 of physical and logical data independence that are achieved by such a system.
					 Some of these benefits include: 
					 <itemizedlist> 
						  <listitem> 
								<para>Productivity</para> 
								<para>Because the system can automate large portions of
									 the development process, the obvious initial benefit is development time. Both
									 development time and maintenance time are dramatically reduced. Developers can
									 spend more time solving the actual problems presented by the application,
									 rather than wrestling with the details of the implementation.</para> 
						  </listitem> 
						  <listitem> 
								<para>Deployment</para> 
								<para>Deployment of an application based on a
									 declarative platform is simply a matter of deploying the definition of the
									 application to the system.</para> 
						  </listitem> 
						  <listitem> 
								<para>Maintenance</para> 
								<para>The centralized schema and automated
									 user-interface derivation features of the system allow changes to the
									 application schema to be made without necessarily having to make the
									 corresponding changes to the presentation layer. The applications simply react
									 to the change. These changes could be automatically coordinated with the
									 physical layer as well.</para> 
						  </listitem> 
						  <listitem> 
								<para>Training</para> 
								<para>Due to platform independence, the software
									 environment of the application can change without the need to re-train
									 developers on the new software environment. They still utilize the same
									 conceptual environment exposed by the system.</para> 
						  </listitem> 
					 </itemizedlist></para> 
				<para>It is worth pointing out that the declarative approach is by
					 no means a panacea. It is not a "silver bullet" that will automatically develop
					 applications. It is a layer of abstraction over existing development
					 methodologies that allows applications to be implemented at a higher conceptual
					 level. In other words, there is no substitute for good architecture, and care
					 must be taken to express the model completely and accurately within a given
					 declarative framework. The goal of the declarative approach is to simplify the
					 implementation of a given architecture by encapsulating whenever possible the
					 details of that implementation within the system.</para> 
		  </sect1> 
		  <sect1 id="DDGApplicationDevelopmentConcepts-Conclusions"> 
				<title>Conclusions</title> 
				<para>This chapter has focused on how the declarative approach to
					 application development can be utilized to solve many of the issues faced in
					 software development. As with any large systems software, the ideal declarative
					 platform is a moving target. However, the evolution of application development
					 depends on taking steps towards a more declarative paradigm. Once the platform
					 exists, it will continue to improve as optimizations are made, and new
					 application development patterns are formalized and automated. In other words,
					 it is a platform that evolves to handle new situations, rather than
					 re-inventing solutions to problems that have already been solved.</para> 
		  </sect1> 
	 </chapter> 
	 <chapter id="DDGDataphorProductAnatomy"> 
		  <title><indexterm><primary>Dataphor Product
						  Anatomy</primary></indexterm>Dataphor Product Anatomy</title> 
		  <para>This chapter introduces the Dataphor product, and discusses how
				it enables automated application development.</para> 
		  <sect1 id="DDGDataphorProductAnatomy-Overview"> 
				<title><indexterm><primary>Overview</primary></indexterm><indexterm><primary>Dataphor
								Product
								Anatomy</primary><secondary>Overview</secondary></indexterm>Overview</title> 
				<para>The Dataphor product is an application development platform
					 based on the declarative approach using the relational model. It consists of
					 the following major components: 
					 <itemizedlist> 
						  <listitem> 
								<para>Dataphor Server - The core of the Dataphor
									 product that exposes all the services and capabilities required to enable
									 automated application development.</para> 
						  </listitem> 
						  <listitem> 
								<para>Frontend Server - A set of services exposed as a
									 library in the Dataphor Server that the Frontend Clients can utilize to enable
									 automated application development.</para> 
						  </listitem> 
						  <listitem> 
								<para>Frontend Clients - A set of "thin" clients
									 designed to consume Dataphor applications.</para> 
						  </listitem> 
						  <listitem> 
								<para>Dataphoria - An Integrated Development
									 Environment (IDE) for building, administering and maintaining Dataphor
									 applications.</para> 
						  </listitem> 
					 </itemizedlist></para> 
		  </sect1> 
		  <sect1 id="DDGDataphorProductAnatomy-DataphorServer"> 
				<title><indexterm><primary>Dataphor
								Server</primary></indexterm><indexterm><primary>Dataphor Product
								Anatomy</primary><secondary>Dataphor Server</secondary></indexterm>Dataphor
					 Server</title> 
				<para>The Dataphor Server is designed to enable automated
					 application development. In order to achieve this goal, the Dataphor Server
					 plays two major roles. Firstly, it acts as an insulating layer between the
					 application and the data storage systems it uses. Secondly, it acts as an
					 environment for declarative application development by providing the services
					 and capabilities discussed in the previous chapters. In both of these roles,
					 the Dataphor Server is used by the application in much the same way that a
					 traditional DBMS is used.</para> 
				<para>The Dataphor Server functions as a DBMS in that it must
					 coordinate requests from multiple users to access the same data. Ensuring that
					 each user request is fulfilled efficiently and correctly is a highly
					 non-trivial task. In order to accomplish the process, the functionality of the
					 Dataphor Server is divided into subsystems: 
					 <itemizedlist> 
						  <listitem> 
								<para>Manager</para> 
						  </listitem> 
						  <listitem> 
								<para>Catalog</para> 
						  </listitem> 
						  <listitem> 
								<para>Compiler</para> 
						  </listitem> 
						  <listitem> 
								<para>Query Processor</para> 
						  </listitem> 
						  <listitem> 
								<para>Storage Integrator</para> 
						  </listitem> 
					 </itemizedlist></para> 
				<para>Each subsystem is responsible for a specific set of tasks in
					 the overall system. The Manager coordinates the interaction between the
					 different subsystems. The Catalog is the repository for the data structures
					 which the Dataphor Server can access. The Compiler is responsible for
					 translating user requests into efficient executable plans, which the Query
					 Processor is then responsible for executing. The Storage Integrator provides
					 the abstraction layer through which all data in the Dataphor Server is
					 accessed.</para> 
				<para>Collectively, these subsystems reside in a .NET Framework
					 application domain hosted within an operating system process. This is known as
					 a Dataphor Server <emphasis>instance</emphasis> and represents a single
					 Dataphor Server providing data management services for a single database. Note
					 that, like a traditional DBMS, the Dataphor Server can host multiple
					 applications within a single instance.</para> 
				<para>A Dataphor Server instance can be hosted within any .NET
					 Framework application, or within a Windows Service. For more information on
					 configuring the Dataphor Server as a Windows Service, see the Dataphor User's
					 Guide.</para> 
				<sect2 id="DDGDataphorProductAnatomy-DataphorServer-Manager"> 
					 <title><indexterm><primary>Manager</primary></indexterm><indexterm><primary>Dataphor
									 Server</primary><secondary>Manager</secondary></indexterm>Manager</title> 
					 <para>The Manager controls the interaction between all the
						  subsystems of the Dataphor Server. It manages running processes, routes user
						  requests, and coordinates the actions of the different storage systems with
						  which the Dataphor Server communicates. The tasks of the manager are divided
						  into layers as follows: 
						  <itemizedlist> 
								<listitem> 
									 <para>Server</para> 
								</listitem> 
								<listitem> 
									 <para>Session</para> 
								</listitem> 
								<listitem> 
									 <para>Process</para> 
								</listitem> 
								<listitem> 
									 <para>Plan</para> 
								</listitem> 
								<listitem> 
									 <para>Cursor</para> 
								</listitem> 
						  </itemizedlist></para> 
					 <para>The manager exposes the functionality of the Dataphor
						  Server at these different layers through the Call-Level Interface (CLI), an
						  Application Programming Interface (API) designed specifically for use with the
						  Dataphor Server. The CLI is a set of .NET Framework interfaces which allow
						  programmatic access to the functionality of the Dataphor Server. Each layer of
						  the manager architecture has a corresponding level in the CLI which exposes the
						  functionality associated at that level.</para> 
					 <para>All the functionality and capabilities of the Dataphor
						  Server are exposed through a data access language called D4. This language
						  provides the interface to the logical model of the system, and is the main
						  application development language for Dataphor applications. It is an imperative
						  language in the syntactic style of Pascal, extended to include all the
						  functionality of a database management language. In particular, it is a
						  relationally complete language based on the relational algebra. For a complete
						  discussion of the D4 language, see the D4 Language Guide in this manual.</para>
					 
					 <para>The CLI is the lowest level of access to the Dataphor
						  Server. On top of the CLI, higher-level access mechanisms are available such as
						  the Dataphor Data Access Components (DAC). For complete references for the CLI
						  and the DAC, refer to the Dataphor Reference.</para> 
					 <para>Briefly, the server level controls all the global tasks
						  such as system configuration and startup. The session manages the tasks
						  associated with each user such as user configuration and starting and stopping
						  processes. The process is the basic level of execution in the Dataphor Server,
						  and coordinates the actions of the compiler and query processor to fulfill
						  requests from the user. The plan manages tasks associated with prepared
						  statements such as structural and metadata description and cursor requests. And
						  finally, the cursor level manages tasks associated with the retrieval of
						  results. Each of these levels are discussed in detail in the CLI discussion in
						  the Presentation Layer part of this manual.</para> 
				</sect2> 
				<sect2 id="DDGDataphorProductAnatomy-DataphorServer-Catalog"> 
					 <title><indexterm><primary>Dataphor
									 Server</primary><secondary>Catalog</secondary></indexterm><indexterm><primary>Catalog</primary></indexterm>Catalog</title>
					 
					 <para>The catalog of the Dataphor Server is the central
						  repository for the application schema, or the description of the structure of
						  the database. The catalog also contains such items as compiled operators,
						  storage device descriptions, and security information. All this information is
						  used by the various subsystems to provide the functionality exposed by the
						  Dataphor Server. For example, the manager uses the catalog to ensure that a
						  given connection request is made by a valid user of the system; the compiler
						  uses the catalog to ensure that a given statement references valid objects in
						  the database; and so on.</para> 
					 <para>The catalog is exposed through D4 as a set of tables
						  containing rows which describe the current contents of the catalog. For
						  example, there is a table variable called 
						  <phrase role="code">System.Operators</phrase> which has a
						  row for every operator in the system. For a complete description of the system
						  catalog, refer to the System Library Reference in the Dataphor
						  Reference.</para> 
					 <para>Catalog objects can be created, altered, and dropped
						  through the use of Data Definition Language (DDL) statements of the D4
						  language. For a complete description of each of these statements, refer to the
						  D4 Language Guide in this manual.</para> 
					 <para>Each object in the catalog can have
						  <emphasis>metadata</emphasis> associated with it, which is additional
						  information that is ignored by the logical model. Metadata is used by specific
						  applications to provide extra information about each object. For example, the
						  Frontend uses a tag called 
						  <phrase role="code">Frontend.Title</phrase> to determine
						  the presentation layer description for a corresponding user-interface
						  element.</para> 
					 <para>The entire catalog is divided into units called
						  libraries. Every catalog object is contained within some library. Libraries
						  provide the fundamental deployment unit for Dataphor applications. They also
						  form a unit of dependency tracking, in that the objects contained within a
						  library cannot reference objects in other libraries unless the library they are
						  in depends on the library containing the object being referenced.</para> 
					 <para>The Dataphor Server catalog contains the following types
						  of objects: 
						  <itemizedlist> 
								<listitem> 
									 <para>Libraries</para> 
								</listitem> 
								<listitem> 
									 <para>Scalar Types</para> 
								</listitem> 
								<listitem> 
									 <para>Tables</para> 
								</listitem> 
								<listitem> 
									 <para>Views</para> 
								</listitem> 
								<listitem> 
									 <para>Constraints</para> 
								</listitem> 
								<listitem> 
									 <para>References</para> 
								</listitem> 
								<listitem> 
									 <para>Operators</para> 
								</listitem> 
								<listitem> 
									 <para>Devices</para> 
								</listitem> 
								<listitem> 
									 <para>Users</para> 
								</listitem> 
								<listitem> 
									 <para>Roles</para> 
								</listitem> 
								<listitem> 
									 <para>Rights</para> 
								</listitem> 
								<listitem> 
									 <para>Event Handlers</para> 
								</listitem> 
								<listitem> 
									 <para>Conversions</para> 
								</listitem> 
								<listitem> 
									 <para>Sorts</para> 
								</listitem> 
						  </itemizedlist></para> 
					 <para>For more information on each of these types of objects,
						  see the 
						  <ulink url="D4LGCatalogElements.html"><citetitle>Catalog
									 Elements</citetitle></ulink> section of the D4 Language Guide in this
						  manual.</para> 
					 <para>For more information on using these elements to construct
						  a Dataphor Application, refer to the 
						  <ulink url="DDGLogicalApplicationDesign.html">Logical
								Application Design</ulink> part of this manual.</para> 
					 <para>For more information on the security system of the
						  Dataphor Server, refer to the 
						  <ulink
						  url="DUGP3Security.html"><citetitle>Security</citetitle></ulink> chapter of the
						  Dataphor User's Guide.</para> 
				</sect2> 
				<sect2 id="DDGDataphorProductAnatomy-DataphorServer-Compiler"> 
					 <title><indexterm><primary>Dataphor
									 Server</primary><secondary>Compiler</secondary></indexterm>Compiler</title> 
					 <para>The compiler subsystem is responsible for ensuring the
						  syntactic and semantic correctness of a given user request, and for producing
						  an executable plan to fulfill that request. User requests are made in terms of
						  D4, the native language of the Dataphor Server</para> 
					 <para>The compilation process is divided up into the following
						  phases: 
						  <itemizedlist> 
								<listitem> 
									 <para>Lexical Analysis</para> 
								</listitem> 
								<listitem> 
									 <para>Syntactic Analysis</para> 
								</listitem> 
								<listitem> 
									 <para>Semantic Analysis</para> 
								</listitem> 
								<listitem> 
									 <para>Optimization</para> 
								</listitem> 
								<listitem> 
									 <para>Binding</para> 
								</listitem> 
						  </itemizedlist></para> 
					 <para>The output from one phase functions as the input to the
						  next phase of the process. The input to the lexical analysis phase is the user
						  request as a string of characters, and the output from the binding phase is a
						  compiled plan ready for execution in the query processor.</para> 
					 <para>The lexical analysis phase is concerned with transforming
						  a given string of characters into a sequence of tokens. This phase is also
						  responsible for removing comments and whitespace from the input stream.</para> 
					 <para>The syntactic analysis phase is concerned with ensuring
						  that a given stream of tokens forms a correct statement of the language. This
						  process is handled by the parser. The output of this phase is a syntactically
						  correct representation of the user request.</para> 
					 <para>The semantic analysis phase is concerned with ensuring
						  that a given user request is meaningful. This phase involves resolving
						  identifiers and operator invocations, and performing type checking. During this
						  phase, the compiler makes use of the catalog to perform identifier and operator
						  resolution. The output of this phase is a direct translation of the user
						  request into instructions for use in the query processor. This is a preliminary
						  version of the plan that has not been bound to actual storage locations yet,
						  but it is guaranteed to be semantically correct. Once the compiler reaches this
						  phase, the user request is known to be a correct program of D4.</para> 
					 <para>The optimization phase is concerned with high-level
						  transformations to the user request in an attempt to produce a more efficient
						  execution plan. For example, if a user request contains a restrict followed
						  immediately by a restrict, the two restricts can be combined into one without
						  changing the semantics of the statement, and yielding better
						  performance.</para> 
					 <para>The binding phase is concerned with access-path
						  determination, and device selection. Device selection is done through a process
						  called query chunking, in which the processor instructions are considered from
						  the retrieval steps up. At each step of the query, the devices involved are
						  asked to prepare an equivalent execution. If a device is capable of performing
						  a particular step of the query, it is assigned to do so. Otherwise, the
						  Dataphor Server must process the query. Access-path determination is concerned
						  with finding an efficient method to access the actual data. This involves such
						  tactics as using an index to process a given restriction or recognizing that a
						  join could be done more efficiently by sorting both sides prior to performing
						  the join.</para> 
					 <para>Once all these phases of the compilation process have
						  occurred, the plan is ready for actual execution within the query processor.
						  The type of the result, if any, is known, and the request is known to be a
						  semantically valid program of D4 instructions. Of course, this does not mean
						  that run-time errors cannot occur, only that the system understands the request
						  and is ready to attempt to perform it.</para> 
					 <para>The various inference mechanisms of the Dataphor Server
						  are all implemented in the compiler. Type inference is the most basic form of
						  inference, and involves determining the result type of an expression. In
						  addition, if the expression is table-valued, the compiler must infer structural
						  information about the result such as keys, orders, constraints, defaults,
						  references, metadata, and so on. The compiler also determines the various
						  characteristics of the statement or expression, which determines whether or not
						  it is valid in a given context. For a more complete discussion of the inference
						  mechanisms of the D4 language, see the D4 Language Guide in this manual.</para>
					 
				</sect2> 
				<sect2
				id="DDGDataphorProductAnatomy-DataphorServer-QueryProcessor"> 
					 <title><indexterm><primary>Dataphor
									 Server</primary><secondary>Query
									 Processor</secondary></indexterm><indexterm><primary>Query
									 Processor</primary></indexterm>Query Processor</title> 
					 <para>The query processor is responsible for actually
						  performing the operations requested by users. A compiled plan in the Dataphor
						  Server consists of a hierarchical representation of the action to be performed.
						  Each operation is a node in the tree, and the children of any given node are
						  the operands to the operation. For a typical query, this means that the leaves
						  of the tree end in retrieval from devices, and the root of the tree is the
						  result. For table operations, each node in this tree is actually a cursor which
						  performs the requested operation. In this way, results are only materialized as
						  they are requested. This approach to query processing is called
						  <emphasis>pipelining</emphasis> and means that if the results of a query are
						  never requested, i.e., the cursor is never stepped through, the results may
						  never be materialized (of course, they will be materialized if required, for
						  example if an operation requires sorted input and no index exists to satisfy
						  the required order, but the Dataphor Server will only materialize intermediate
						  results when necessary).</para> 
					 <para>Query updatability is also implemented using this
						  approach. When a data modification request is made on the cursor, it is
						  propagated through each node of the plan.</para> 
				</sect2> 
				<sect2
				id="DDGDataphorProductAnatomy-DataphorServer-StorageIntegrator"> 
					 <title><indexterm><primary>Dataphor
									 Server</primary><secondary>Storage
									 Integrator</secondary></indexterm><indexterm><primary>Storage Integration
									 Architecture</primary></indexterm>Storage Integrator</title> 
					 <para>The Storage Integrator (SI) utilizes an architecture
						  called Storage Integration Architecture (SIA) and is concerned with providing
						  an abstraction layer through which all data can be retrieved and manipulated.
						  Data from this layer is presented to the Dataphor Server in the form of
						  cursors, so the SI can take over the execution of a node in the tree of a query
						  plan at any point. This replacement forms the basis of the query distribution
						  capabilities of the Dataphor Server, resulting in seamless access and
						  manipulation capabilities to disparate sources.</para> 
					 <para>Because the SIA is abstracting other DBMSs, the division
						  of tasks in the architecture closely mirrors that of a typical DBMS. Like the
						  Dataphor Server itself, the functionality is layered into a hierarchy as
						  follows: 
						  <itemizedlist> 
								<listitem> 
									 <para>Device</para> 
								</listitem> 
								<listitem> 
									 <para>Device Session</para> 
								</listitem> 
								<listitem> 
									 <para>Device Plan</para> 
								</listitem> 
								<listitem> 
									 <para>Device Cursor</para> 
								</listitem> 
						  </itemizedlist></para> 
					 <para>The central abstraction mechanism of the SIA is the
						  <emphasis>device</emphasis>. A device manages the instance level configuration
						  and settings of a storage system with which the Dataphor Server can
						  communicate. A device is also responsible for providing translation services
						  between instructions of D4 and the appropriate instructions for the target
						  system.</para> 
					 <para>Each process in the Dataphor Server can communicate with
						  any number of devices, and each device can support multiple requests from
						  different processes. This relationship is managed by the process using a
						  <emphasis>device session</emphasis>. Each process will have one device session
						  for each device with which it must communicate. This device session coordinates
						  transaction management between the Dataphor Server and the target system, and
						  allows for requests coming in from the process to be prepared against the
						  device.</para> 
					 <para>Preparing a request from the Dataphor Server results in a
						  <emphasis>device plan</emphasis>. Just as in the Dataphor Server, a device plan
						  is ready for execution within the device. For SQL devices, this means that the
						  requested instructions of D4 have been translated into an equivalent statement
						  of SQL. If the device does not support the requested operation, the compiler
						  binds that step of the query to the Dataphor Server, rather than to the
						  device.</para> 
					 <para>Once a request has been prepared, it can be executed
						  against the device. If the request is a statement, the action is executed.
						  Otherwise the operation opens a <emphasis>device cursor</emphasis> ranging over
						  the result set produced by the device. This can either be returned directly to
						  the CLI if the device was capable of performing the entire query, or it can be
						  used as an argument to the next operation in the query processor. In either
						  case, a cursor is used, so the pipelined approach is still maintained, at least
						  by the Dataphor Server.</para> 
					 <para>Manipulation is also propagated to devices where
						  possible. Note that the chunking of a query for retrieval may be done at a
						  different level than for update. For example, a device may be able to process a
						  join, but not be able to update through it.</para> 
					 <para>The translation process that occurs is specific to each
						  device, however there are certain common facilities which can be provided to
						  ease the task. For instance, every device must be capable of producing data in
						  a format compatible with the types of the Dataphor Server. This gives rise to a
						  mapping layer between the device and the data types in the catalog. For each
						  scalar type that the device supports, a <emphasis>scalar type map</emphasis> is
						  specified on the device. This scalar type map implements the translation of
						  values of a given type to and from the device representation of the value and
						  the host representation of the value within the Dataphor Server.</para> 
					 <para>In addition, each device may be capable of performing
						  many of the operators in the Dataphor Server. Again, this is facilitated by a
						  mapping layer between the device and the operators in the catalog. For each
						  operator which the device supports, an <emphasis>operator map</emphasis> is
						  provided which handles the task of translating a given statement of D4 into the
						  appropriate commands for the target system. Note that the existence of an
						  operator map does not alone constitute support for a query containing the
						  operator. The decision to support a particular query is based on several
						  factors, of which supporting the operators and types referenced by the
						  expression are only two.</para> 
					 <para>Each device may also provide a mapping between users of
						  D4 and users of the target system. This is accomplished using a
						  <emphasis>device user</emphasis>. Device users can be created and manipulated
						  using system provided operators in the Dataphor Server, or the visual security
						  management interfaces exposed by Dataphoria. If no device user is specified,
						  the Dataphor Server will use the credentials specified on the device itself. If
						  no configuration is specified on the device, the Dataphor Server will use the
						  credentials of the D4 user.</para> 
					 <para>The result of this process is that both data access and
						  data manipulation across devices is made completely transparent to users of the
						  Dataphor Server. True logical data independence is achieved, as the results of
						  any query, and hence any view, can be retrieved and updated without regard to
						  the actual location of the data. A view can be defined which joins the data
						  from a Microsoft SQL Server and an Oracle Server, and the view still behaves as
						  if it were a single base table.</para> 
					 <para>In addition, because the Dataphor Server itself is
						  capable of processing the results of any expression of the relational algebra,
						  any given query will always execute. This is true regardless of the level of
						  relational support provided by the devices involved.</para> 
					 <para>For more information on creating and manipulating
						  devices, refer to the 
						  <ulink url="D4LGCatalogElements.html"><citetitle>Catalog
									 Elements</citetitle></ulink> chapter of the D4 Language Guide in this
						  manual.</para> 
				</sect2> 
				<sect2
				id="DDGDataphorProductAnatomy-DataphorServer-AutomatedApplicationDevelopmentServices">
					 
					 <title><indexterm><primary>Automated Application Development
									 Services</primary></indexterm><indexterm><primary>Dataphor
									 Server</primary><secondary>Automated Application Development
									 Services</secondary></indexterm>Automated Application Development
						  Services</title> 
					 <para>In addition to the services and capabilities of a
						  traditional database management system, the Dataphor Server exposes various
						  services aimed at enabling automated application development. These include: 
						  <itemizedlist> 
								<listitem> 
									 <para>Query and View Updatability</para> 
								</listitem> 
								<listitem> 
									 <para>Advanced Business-Rule Enforcement</para> 
								</listitem> 
								<listitem> 
									 <para>Metadata Services</para> 
								</listitem> 
								<listitem> 
									 <para>Application Transactions</para> 
								</listitem> 
								<listitem> 
									 <para>Navigational Access</para> 
								</listitem> 
								<listitem> 
									 <para>Proposable Interfaces</para> 
								</listitem> 
						  </itemizedlist></para> 
					 <sect3 id="DDGQueryandViewUpdatability"> 
						  <title><indexterm><primary>Query and View
										  Updatability</primary></indexterm><indexterm><primary>Automated Application
										  Development Services</primary><secondary>Query and View
										  Updatability</secondary></indexterm>Query and View Updatability</title> 
						  <para>The Dataphor Server allows for updates against
								arbitrarily complex expressions (queries and views). The golden rule for
								updatability within the Dataphor Server is as follows:</para> 
						  <para>"No update operation must ever be allowed to leave
								any [table] in a state that violates its own predicate." [3]</para> 
						  <para>This updatability is possible because of the type
								inference mechanism. The result of this updatability is that the data consumer
								does not need to know the details of a given view. To a consumer, the Dataphor
								Server appears as a set of table variables, which all behave the same way
								whether they are declared as tables or views. This achieves a high degree of
								logical data independence, and allows the developer of the application schema
								to rearrange the logical model internally, without affecting the consumer's
								external view of that model.</para> 
					 </sect3> 
					 <sect3 id="DDGAdvancedBusiness-RuleEnforcement"> 
						  <title><indexterm><primary>Advanced Business-Rule
										  Enforcement</primary></indexterm><indexterm><primary>Automated Application
										  Development Services</primary><secondary>Advanced Business-Rule
										  Enforcement</secondary></indexterm>Advanced Business-Rule Enforcement</title> 
						  <para>Integrity constraints constitute the "business rules"
								of an application, and are an essential part of the application schema. The
								Dataphor Server provides the ability to easily declare such constraints at
								different levels of the schema. Constraints can be declared that enforce rules
								for the entire database, down to rules that affect only a single column or data
								type. Declarative database-wide integrity constraints allow advanced rules to
								be easily expressed that would ordinarily require multiple "triggers" to be
								written, if they could be enforced at all.</para> 
					 </sect3> 
					 <sect3 id="DDGMetadataServices"> 
						  <title><indexterm><primary>Metadata
										  Services</primary></indexterm><indexterm><primary>Automated Application
										  Development Services</primary><secondary>Metadata
										  Services</secondary></indexterm>Metadata Services</title> 
						  <para>The schema of a Dataphor application can be adorned
								with additional application-specific information called metadata. These
								additional attributes are then made available with the structure of the result
								set of any query and can be used by the application for whatever purpose
								desired.</para> 
						  <para>The Frontend Services utilize this metadata, along
								with other structural information exposed by the application schema to enable
								the process of user-interface derivation. The metadata can be used to provide
								hints to the derivation process such as what the title of a given column should
								be, or whether or not to include a reference as an embedded detail on a
								particular user-interface.</para> 
						  <para>Metadata is also inferred by the compiler through
								expressions of the D4 language. The type inference mechanisms of the D4
								compiler have been extended to include metadata inference, as well as other
								structural information such as defaults, constraints, orders and so on.</para> 
					 </sect3> 
					 <sect3 id="DDGApplicationTransactions"> 
						  <title><indexterm><primary>Application
										  Transactions</primary></indexterm><indexterm><primary>Automated Application
										  Development Services</primary><secondary>Application
										  Transactions</secondary></indexterm>Application Transactions</title> 
						  <para>In addition to typical pessimistic transaction
								support, the Dataphor Server features Application Transactions, which are a
								type of optimistically concurrent transaction where concurrency control is not
								required, and consistency is checked at the time of commit. Application
								transactions are managed at the session level and can be joined by multiple
								processes within the same Dataphor Server.</para> 
						  <para>A common problem encountered when writing
								applications is dealing with data entry and modification in a database
								containing complex rules. For example, a master/detail relationship
								(one-to-many) between tables enforced by a referential integrity constraint is
								common in application schemas. In many cases, a master row may not be
								"complete" until the appropriate detail rows are in place. Because of the
								integrity constraint, the master row must be present in the database before the
								detail rows.</para> 
						  <para>Typical transaction support allows the rows to be
								entered simultaneously (although it should be noted that not all SQL-based DBMS
								products support this), but because transaction concurrency is handled
								pessimistically (i.e. by locking resources), transactions must be kept as short
								as possible to minimize resource contention.</para> 
						  <para>For this reason, most applications do not solve this
								user-interface problem using transaction support. Rather, it is typically
								handled by the developer within the presentation layer. Even with the aid of
								development tools that help developers accomplish the tasks of caching, this
								caching is an unnecessary burden, and is not a general solution. Hard-coded
								caching only works for the manipulation patterns anticipated by the developer.
								Application Transactions handle these problems in a general way, without
								requiring additional effort by the developer.</para> 
						  <para>An application transaction is a managed buffer that
								mirrors exactly the application schema, with the exception of the constraints
								that would cause problems in the user-interfaces, namely any constraint that
								involves more than one table. All the structural information available in the
								application schema is visible as part of the application transaction. And
								because the management of application transactions is automatically handled by
								the data access layer of the Dataphor clients, the entire process is
								transparent.</para> 
					 </sect3> 
					 <sect3 id="DDGNavigationalAccess"> 
						  <title><indexterm><primary>Navigational
										  Access</primary></indexterm><indexterm><primary>Automated Application
										  Development Services</primary><secondary>Navigational
										  Access</secondary></indexterm>Navigational Access</title> 
						  <para>One of the most difficult problems in any database
								application is the presentation of a natural and intuitive search. The Dataphor
								Server solves this problem by providing navigational access to data using its
								<emphasis>browse</emphasis> capability. Using 
								<phrase role="code"><emphasis
									 role="bold">browse</emphasis></phrase> instead of 
								<phrase role="code"><emphasis
									 role="bold">order</emphasis></phrase> as part of the cursor definition provides
								this navigational access.</para> 
						  <para>Cursor operations such as backwards navigation and
								searching can be performed efficiently against relational and indexed-access
								data sources when using a browse based cursor. As the browse cursor is
								navigated and searched, the query processor opens cursors internally based on
								appropriately transformed expressions. For example, when the user searches for
								the name "Karl", the underlying expression is modified to return all rows
								greater than or equal to the search criteria. This type of access is enabled
								against expressions of arbitrary complexity, not just simple table
								expressions.</para> 
						  <para>Because of the this navigational access, user
								interfaces can be built based on browse cursors that are easy and efficient to
								search and navigate. The developer is not concerned with fetching data subsets,
								and the end user can see what they perceive as the entire table. In reality,
								only the data actually being presented is retrieved from the Dataphor
								Server.</para> 
					 </sect3> 
					 <sect3 id="DDGProposableInterfaces"> 
						  <title><indexterm><primary>Proposable
										  Interfaces</primary></indexterm><indexterm><primary>Automated Application
										  Development Services</primary><secondary>Proposable
										  Interfaces</secondary></indexterm>Proposable Interfaces</title> 
						  <para>The Dataphor Server is capable of answering questions
								about modification operations that are about to be performed. During data entry
								processes, rows are built a column at a time as the user enters data. The
								Dataphor Server provides a set of <emphasis>proposable</emphasis> interfaces
								that allow the application to perform intermediate processing while this data
								entry is occurring. There are three types of proposable questions.</para> 
						  <para> 
								<itemizedlist mark="bullet"> 
									 <listitem> 
										  <para><emphasis
												role="strong">Default</emphasis> is designed to provide the initial state for a
												newly inserted row. When applications begin the process of data entry, this
												interface can be used to determine the default values for the columns of the
												table such as a new surrogate identifier for the row.</para> 
									 </listitem> 
									 <listitem> 
										  <para><emphasis
												role="strong">Validate</emphasis> is designed to provide a mechanism for
												immediate value validation on a column level. As values are entered, this
												interface can be used to determine whether they would violate any constraint of
												the column or data type.</para> 
									 </listitem> 
									 <listitem> 
										  <para><emphasis role="strong">Change</emphasis>
												is designed to provide a mechanism for displaying the predicted results of an
												operation. After a value has been entered, this interface can be used to
												request the affects of the change on the rest of the row, such as a calculated
												column.</para> 
									 </listitem> 
								</itemizedlist> </para> 
					 </sect3> 
				</sect2> 
		  </sect1> 
		  <sect1 id="DDGDataphorProductAnatomy-FrontendServer"> 
				<title><indexterm><primary>Frontend
								Server</primary></indexterm><indexterm><primary>Dataphor Product
								Anatomy</primary><secondary>Frontend Server</secondary></indexterm>Frontend
					 Server</title> 
				<para>The Frontend Server is a set of services built as a library
					 in D4 and housed within the Dataphor Server. These services are primarily
					 concerned with the presentation layer of a Dataphor application. The Frontend
					 Server provides <emphasis>document</emphasis> support, query elaboration
					 capabilities, user-interface derivation services, and application entry
					 points.</para> 
				<sect2
				id="DDGDataphorProductAnatomy-FrontendServer-FrontendLibraryExtensions"> 
					 <title><indexterm><primary>Frontend Library
									 Extensions</primary></indexterm><indexterm><primary>Frontend
									 Server</primary><secondary>Frontend Library
									 Extensions</secondary></indexterm>Frontend Library Extensions</title> 
					 <para>The Frontend Server extends the concept of a library in
						  the Dataphor Server to include the notion of a <emphasis>document</emphasis>. A
						  document is the logical manifestation of an operating system file. Each
						  document resides within a specific library, and has a name, which must be
						  unique within that library. Documents are of some specific document type, and
						  that type governs how the various Frontend services will deal with the
						  document.</para> 
					 <para>The Frontend Server exposes an API for dealing with
						  documents. Standard I/O functionality is available for loading and saving
						  documents, as well as other, more specialized functionality.</para> 
				</sect2> 
				<sect2 id="DDGDataphorProductAnatomy-FrontendServer-FrontendForms">
					 
					 <title><indexterm><primary>Frontend
									 Forms</primary></indexterm><indexterm><primary>Frontend
									 Server</primary><secondary>Frontend Forms</secondary></indexterm>Frontend
						  Forms</title> 
					 <para>One important type of document is a Dataphor Form
						  Document. These documents contain the complete description of a presentation
						  layer user-interface. These documents can be built manually, or the Frontend
						  Server can be used to derive them automatically. In either case, the Frontend
						  Server provides the ability to customize these forms through the use of
						  <emphasis>visual form inheritance</emphasis>.</para> 
					 <para>This process allows forms to be based on existing forms,
						  and then modified for a specific use. These modifications can include the
						  rearrangement of controls on the form, the modification of properties of the
						  various elements on the form, and even the addition of new elements to the
						  form. These modifications are then saved in a Customized Dataphor Form
						  Document, which saves only the difference between the original form and the
						  customization. When a customization is based on a derived user-interface, this
						  allows the customization to be made without impacting the dynamic nature of the
						  application.</para> 
				</sect2> 
				<sect2
				id="DDGDataphorProductAnatomy-FrontendServer-User-InterfaceDerivation"> 
					 <title><indexterm><primary>User-Interface
									 Derivation</primary></indexterm><indexterm><primary>Frontend
									 Server</primary><secondary>User-Interface
									 Derivation</secondary></indexterm>User-Interface Derivation</title> 
					 <para>The Frontend Server also exposes an API for automatically
						  producing Dataphor Form Documents based on the application schema. Various
						  types of interfaces can be produced, for example, a <emphasis>Browse</emphasis>
						  interface for a given table can be produced, which will provide a table-level
						  user-interface to the data in the table. Row-level user-interfaces can also be
						  produced.</para> 
					 <para>The user-interface derivation process by default also
						  includes references to other tables and views in the database. These references
						  are exposed appropriately on the derived user-interface. For example, when
						  browsing the employees table, the employee phones table could appear as an item
						  on the <emphasis>Details</emphasis> menu of the resulting
						  user-interface.</para> 
					 <para>In addition to the default behavior provided by the
						  Frontend Server, the derivation can be controlled through the use of metadata
						  in the application schema. For example, the
						  <emphasis>Frontend.Embedded</emphasis> tag can be used to indicate that a given
						  reference should be embedded into the user-interface for a given table. This
						  allows the user-interfaces to be tailored to an application's specific
						  requirements, while still allowing those user-interfaces to be derived.</para> 
				</sect2> 
		  </sect1> 
		  <sect1 id="DDGDataphorProductAnatomy-FrontendClients"> 
				<title><indexterm><primary>Frontend
								Clients</primary></indexterm><indexterm><primary>Dataphor Product
								Anatomy</primary><secondary>Frontend Clients</secondary></indexterm>Frontend
					 Clients</title> 
				<para>The Dataphor platform utilizes a generic user-interface
					 description language to allow clients based on different platforms to consume
					 the same application. In this way, Dataphor applications can be defined one
					 time, and deployed on multiple platforms.</para> 
				<para>Both clients expose use the concept of an
					 <emphasis>alias</emphasis> to manage connection information with a specific
					 Dataphor Server instance. The alias specifies the server instance, manages
					 authentication information, and contains session-specific settings required to
					 connect to a Dataphor Server. Each client exposes a set of interfaces for
					 visually managing these aliases.</para> 
				<para>Once a connection is established, the clients then provide an
					 interface to select an application from the list of applications deployed on
					 that Dataphor Server instance. This process can be bypassed, if desired.</para>
				
				<para>Each client communicates with the Dataphor Server using the
					 Data Access Layer, requests the user-interfaces described by the application,
					 and manages the interaction with the user. Because of the services and
					 capabilities exposed by the Dataphor Server, these processes can be completely
					 automated. The resulting clients provide a rich user-interface experience that
					 is defined entirely within the centralized application schema.</para> 
				<para>The Dataphor product ships with a Windows and Web Client, but
					 the architecture is designed to be extensible, and other clients could be
					 easily developed for environments like PDA's and cell phones.</para> 
		  </sect1> 
		  <sect1 id="DDGDataphorProductAnatomy-Dataphoria"> 
				<title><indexterm><primary>Dataphoria</primary></indexterm><indexterm><primary>Dataphor
								Product
								Anatomy</primary><secondary>Dataphoria</secondary></indexterm>Dataphoria</title>
				
				<para>Dataphoria is an Integrated Development Environment for
					 building Dataphor Applications. It provides a visual interface to perform
					 various administrative functions in the Dataphor Server, as well as a
					 hierarchical representation of the catalog, visual forms designer, and
					 integrated ad-hoc query support.</para> 
				<para>For more information on using Dataphoria, refer to the
					 Dataphor User's Guide.</para> 
		  </sect1> 
		  <sect1 id="DDGDataphorProductAnatomy-Conclusions"> 
				<title>Conclusions</title> 
				<para>Application development is an extremely complex and
					 multi-faceted problem. Software developers today are faced with the challenge
					 of building applications faster, better, and cheaper, all at the same time.
					 While there is no "Silver Bullet", raising the level of abstraction at which
					 applications are built will dramatically reduce the complexity of the problems,
					 and allow developers to focus on the core issues of an application, rather than
					 the tedious and mundane issues of day-to-day development.</para> 
				<para>The Dataphor product provides an extremely flexible platform
					 for application development. The features of the product are exposed as layers
					 of enabling technologies that can each be used to achieve higher and higher
					 levels of automated application development. The product was built from the
					 ground up with extensibility in mind, so that even if the platform does not
					 immediately support a desired capability, that support could be provided by
					 systems developers extending the platform. The result is a truly revolutionary
					 next-generation development platform that will continue to evolve with the
					 ever-increasing complexity of application development.</para> 
				<para>The remainder of this manual is devoted to explaining how to
					 take advantage of the features exposed by the Dataphor product in order to
					 realize the full potential of automated application development.</para> 
		  </sect1> 
	 </chapter>
</part>
