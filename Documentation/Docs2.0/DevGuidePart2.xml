<?xml version="1.0" encoding="UTF-8"?>
<part id="DDGLogicalApplicationDesign"> 
	 <partinfo> 
		  <date role="LastMod">Saturday, November 18, 2006 12:46:45 AM</date> 
	 </partinfo> 
	 <title><indexterm> 
				<primary>Logical Application Design</primary> 
		  </indexterm>Logical Application Design</title> 
	 <partintro> 
		  <para>This part approaches the problem of declarative application
				development from the logical perspective. It discusses modeling the core
				structures and processes of an application as a database schema. It also
				introduces the running example, a hypothetical shipping application which will
				be used as a vehicle for the concepts and techniques discussed throughout this
				part, as well as the next two parts of the manual. This part builds on the
				concepts introduced in Part I of this manual, and will refer to them
				extensively without explanation.</para> 
		  <para>This part, together with Parts III and IV, will discuss
				declarative development from three main perspectives, the logical model, the
				presentation layer, and the physical realization. Not coincidentally, these
				three layers correspond roughly with the three main layers of a Database
				Management System, the conceptual level, the external level, and the internal,
				or physical level. In addition, the breakdown corresponds with the order in
				which a Dataphor application will typically be built, beginning with the
				logical model, building the presentation layer, and finally, mapping the model
				to a physical implementation.</para> 
		  <para>The discussion begins with designing the application and
				implementing the resulting design in terms of the logical model. Part III then
				considers how the logical model is presented to the user, and Part IV discusses
				how the logical model is mapped onto the physical layer to achieve
				persistence.</para> 
		  <para>This part is organized as follows: 
				<itemizedlist> 
					 <listitem> 
						  <para><citetitle>Preliminaries</citetitle></para> 
						  <para>This chapter discusses the Dataphor development
								environment, as well as some basic concepts and techniques for developing
								Dataphor applications. It also introduces the Shipping application, and a
								simplified database design to begin the implementation.</para> 
					 </listitem> 
					 <listitem> 
						  <para><citetitle>Implementing Data Types</citetitle></para>
						  
						  <para>This chapter begins the implementation of the
								shipping application by selecting and building the set of data types that will
								be used to represent the data.</para> 
					 </listitem> 
					 <listitem> 
						  <para><citetitle>Representing Data With Tables and
									 Views</citetitle></para> 
						  <para>This chapter uses the types constructed in 
								<citetitle>Implementing Data Types</citetitle> to
								create the tables and views necessary to implement the database design for the
								running example introduced in 
								<citetitle>Preliminaries</citetitle>.</para> 
					 </listitem> 
					 <listitem> 
						  <para><citetitle>Enforcing Business Rules
									 Declaratively</citetitle></para> 
						  <para>This chapter uses the various integrity enforcement
								features of the D4 language to ensure that the data represented within the
								application conforms to the requirements of the application.</para> 
					 </listitem> 
					 <listitem> 
						  <para><citetitle>Modeling Process Logic</citetitle></para> 
						  <para>This chapter uses the imperative features of the D4
								language to model the process logic required to carry out the operations of the
								shipping application.</para> 
					 </listitem> 
					 <listitem> 
						  <para><citetitle>Enforcing Stimulus-Response
									 Rules</citetitle></para> 
						  <para>This chapter discusses the use of event handlers to
								enforce business rules that require some action to be taken on the part of the
								application, or <emphasis>stimulus-response</emphasis> rules.</para> 
					 </listitem> 
					 <listitem> 
						  <para><citetitle>Enforcing Security</citetitle></para> 
						  <para>This chapter utilizes the security features of the
								Dataphor product to enforce the administrative requirements of the shipping
								application.</para> 
					 </listitem> 
					 <listitem> 
						  <para><citetitle>Working With Libraries</citetitle></para> 
						  <para>This chapter discusses how libraries and dependency
								tracking are used to permit large scale organization of the application schema,
								as well as facilitate deployment and maintenance of the application.</para> 
					 </listitem> 
					 <listitem> 
						  <para><citetitle>Database Design
									 Techniques</citetitle></para> 
						  <para>This chapter discusses database design techniques and
								methodologies that can be used to model applications, and introduces a simple
								notation for expressing these designs visually.</para> 
					 </listitem> 
				</itemizedlist></para> 
	 </partintro> 
	 <chapter id="DDGPreliminaries"> 
		  <title>Preliminaries</title> 
		  <para>This chapter introduces the process of designing and building
				applications using Dataphor. It begins by providing a brief overview of the
				development environment, including common facilities that will be used
				throughout the development process, as well as discussing common development
				scenarios.</para> 
		  <sect1 id="DDGPreliminaries-DataphorApplications"> 
				<title><indexterm> 
						  <primary>Dataphor Applications</primary> 
					 </indexterm><indexterm> 
						  <primary>Preliminaries</primary> 
						  <secondary>Dataphor Applications</secondary> 
					 </indexterm>Dataphor Applications</title> 
				<para>Fundamentally, a Dataphor Application is simply a set of
					 libraries residing in a Dataphor Server. These libraries contain various
					 elements of the application schema, and serve as a high-level logical grouping
					 of the components of the application. The application is exposed to the user
					 starting with a main form that serves as an entry point into the various
					 processes of the application.</para> 
				<para>Generally, one library will serve as the core of the
					 application, providing the basic schema elements that are used by all parts of
					 the application. This library will typically include at least one storage
					 device definition, which provides the persistent store for the application
					 data. For simplicity during the development process, this device can be a
					 temporary device that allows the application to be easily re-created at any
					 time. Once the structures are relatively stable, the device can be switched to
					 one that allows for persistent storage.</para> 
				<para>Each library has a status that indicates whether the library
					 is <emphasis>available</emphasis>, <emphasis>registered</emphasis>, or
					 <emphasis>suspect</emphasis>. Registering a library registers any extensions
					 implemented by the library, and creates the schema that the library contains by
					 running the 
					 <phrase role="code">Register</phrase> script for the
					 library.</para> 
				<para>The persistent storage devices use a process called
					 <emphasis>schema reconciliation</emphasis> to ensure that the Dataphor catalog
					 is synchronized with the catalog of the target system. Each device has
					 reconciliation settings of <emphasis>mode</emphasis> and
					 <emphasis>master</emphasis> that determine when and how the process
					 occurs.</para> 
				<para>Libraries also form the basis for project management in the
					 Dataphor platform by acting as a repository for documents such as database
					 creation scripts and form definitions. Note that when a document is stored in a
					 library, it is physically located with the library in the Dataphor Server, not
					 necessarily on the local computer. This is the primary difference between a
					 document and a file in the Dataphor environment. Files can be opened and saved
					 in the same way that documents can, but files will be saved by the Dataphoria
					 IDE, whereas documents will be saved centrally by the Dataphor Server.</para> 
				<para>Because Dataphor is a declarative development environment,
					 much of the application will be defined in terms of declarative constructs like
					 tables, views, and constraints. The Dataphor Frontend Clients take advantage of
					 these constructs and attempt to automate as much of the work of building
					 user-interfaces as possible. For this reason, the resulting applications are
					 extremely dynamic and react instantly to changes in the application schema.
					 This flexibility allows the application to evolve as it is being developed, and
					 even extends into the maintenance phase of the application.</para> 
				<para>Overall, Dataphor application development typically consists
					 of: 
					 <itemizedlist> 
						  <listitem> 
								<para>Designing a database to meet the data
									 requirements of the application.</para> 
						  </listitem> 
						  <listitem> 
								<para>Identifying the main entry points into the
									 application and refining the derived user-interfaces.</para> 
						  </listitem> 
						  <listitem> 
								<para>Development of the process logic required to
									 provide a working solution.</para> 
						  </listitem> 
					 </itemizedlist> The rest of this manual focuses on providing
					 the developer with the information necessary to take advantage of the
					 flexibility provided by the Dataphor platform during development and
					 maintenance of an application.</para> 
		  </sect1> 
		  <sect1 id="DDGPreliminaries-DevelopmentEnvironment"> 
				<title><indexterm> 
						  <primary>Development Environment</primary> 
					 </indexterm><indexterm> 
						  <primary>Dataphor Applications</primary> 
						  <secondary>Development Environment</secondary> 
					 </indexterm>Development Environment</title> 
				<para>Dataphoria is the Integrated Development Environment (IDE)
					 used to develop Dataphor applications. It is essentially a Dataphor Frontend
					 Client itself, and many of the user-interfaces it exposes are derived from the
					 system catalog of the Dataphor Server. One of the most important aspects of the
					 Dataphoria IDE is designer support, and several designers are provided for
					 opening and manipulating documents within libraries.</para> 
				<para>The primary result of Dataphor development is a set of
					 libraries. The Dataphor platform is designed so that these logical libraries
					 correspond directly with physical directories on disk, allowing libraries to
					 function as a deployment unit for applications. On disk, these libraries
					 consist of files which are exposed as documents within the Dataphoria IDE. Each
					 document type can be associated with various designers that can be used to view
					 and manipulate documents of that type.</para> 
				<para>One of the most important of these designers is the D4 Script
					 Editor. This designer is a full-featured text editor for viewing, building, and
					 executing D4 scripts. Scripts can be executed in their entirety, or portions of
					 a script can be selected and executed individually. Note that the Dataphor
					 Server will compile and run each top-level statement in isolation. This allows
					 for statements to reference catalog objects created in previous
					 statements.</para> 
				<para>The results of executing a script are displayed in the
					 results window attached to the bottom of the D4 Script Editor. Any errors that
					 were encountered during compilation or execution of the script are displayed in
					 the Warnings window of the IDE. Note that there is only one Warnings window,
					 even though each instance of the D4 Script Editor has a separate results
					 window. This can be confusing when switching between designers, as the errors
					 displayed in the Warnings window are not specific to the current editor.</para>
				
				<para>The D4 Script Editor also allows scripts to be
					 <emphasis>prepared</emphasis>, or compiled but not executed. This is useful for
					 checking the syntax of a particular statement, or for checking for warnings
					 from the compiler. When a statement is prepared, any errors or warnings
					 encountered are displayed in the Warnings window. The compiler will issue
					 warnings when a situation is encountered that is not necessarily an error, but
					 could lead to problems. For example, the compiler will issue a warning when an
					 expression attempts to extract a row from a result set that may contain
					 multiple rows.</para> 
				<para>Another important element of the Dataphoria IDE is the
					 Dataphor Explorer. This window provides a tree-based representation of the
					 current catalog of the Dataphor Server. Each library is depicted as a node in
					 this tree, with the schema and documents of that library displayed beneath it.
					 Context menus are available on each node of the tree for performing actions
					 such as browsing tables, or opening documents.</para> 
		  </sect1> 
		  <sect1 id="DDGPreliminaries-DevelopmentPhases"> 
				<title><indexterm> 
						  <primary>Development Phases</primary> 
					 </indexterm><indexterm> 
						  <primary>Dataphor Applications</primary> 
						  <secondary>Development Phases</secondary> 
					 </indexterm>Development Phases</title> 
				<para>Managing the development lifecycle is a complex problem
					 ranging in scope from market analysis, requirements gathering, and risk
					 management to database design, application architecture, and change management.
					 The Dataphor product focuses on the implementation side of the development
					 lifecycle including application development and maintenance. The platform is
					 designed to minimize the impact of change on production applications by
					 automating as much application behavior as possible.</para> 
				<para>Within application development, there are three main
					 perspectives, logical, presentation, and physical. As mentioned previously,
					 these perspectives are each treated separately in different parts of this
					 manual. However, this separation is largely used to organize the material in
					 these manuals, just as it is used to structure the architecture of the product.
					 Because the presentation layer is intimately tied to the logical model, a
					 little time spent thinking about user-interfaces up front will go a long way
					 towards producing usable derived interfaces from the outset. Similarly, the
					 physical layer should not be completely ignored when initially designing the
					 application. Planning for the target environment can be the difference between
					 a smooth transition to production, and a major adjustment of the
					 application.</para> 
				<para>Once an application transitions into production, the problem
					 of change management becomes a central issue. Once again, libraries play a
					 major role in providing a solution to the problem. Each library is stamped with
					 a version number that is incremented whenever a change is made to the
					 application. Each change is stored within the library as a D4 script containing
					 the statements necessary to upgrade an existing deployment to the new version.
					 These scripts are then deployed with the updated library, and run sequentially
					 on the production environment.</para> 
				<para>Because most of the user-interfaces in a Dataphor application
					 are derived, changes to the structures of the application schema will
					 automatically propagate to the user-interfaces. In cases where derived
					 user-interfaces have been customized, or forms have been manually built,
					 changes to the structures may affect the form definitions, and these will have
					 to be updated. Because the updated documents are deployed with the updated
					 library, the Dataphor Frontend Clients will download the new form definitions
					 automatically.</para> 
				<para>The resulting development paradigm allows the developer to
					 focus more on design and architecture issues, and less on implementation,
					 deployment, and change management.</para> 
		  </sect1> 
		  <sect1 id="DDGPreliminaries-DevelopmentScenarios"> 
				<title><indexterm> 
						  <primary>Development Scenarios</primary> 
					 </indexterm><indexterm> 
						  <primary>Dataphor Applications</primary> 
						  <secondary>Development Scenarios</secondary> 
					 </indexterm>Development Scenarios</title> 
				<para>The Dataphoria IDE can connect to an existing Dataphor Server
					 instance, or it can host an instance in-process. When developing Dataphor
					 applications, the IDE is typically run with an in-process server using a local
					 copy of the libraries. For team development efforts, an external version
					 control system can be used to synchronize the development effort, with each
					 developer working on a local copy of the application libraries.</para> 
				<para>In this scenario, once a persistent device is being used,
					 each developer can either connect to the same back-end DBMS on a centrally
					 located server, or connect to a local DBMS instance on their own machine. In
					 either case, upgrades must be coordinated between the different developers.
					 Although this can be accomplished using version control on the library
					 descriptions, it is useful to designate one team member as the librarian. As
					 upgrade scripts are built, the librarian is responsible for injecting them into
					 the appropriate libraries. This eliminates the possibility that two upgrades
					 are assigned the same version number, and ensures that the injection order is
					 consistent.</para> 
		  </sect1> 
		  <sect1 id="DDGPreliminaries-TheRunningExample"> 
				<title><indexterm> 
						  <primary>The Running Example</primary> 
					 </indexterm><indexterm> 
						  <primary>Shipping Application</primary> 
						  <secondary>Requirements</secondary> 
					 </indexterm>The Running Example</title> 
				<para>In order to help illustrate the overall process, and to
					 provide a concrete example along the way, we introduce a running example that
					 will be used throughout this part and the rest of the manual. This example is a
					 hypothetical information system to manage the business of a distribution
					 company. Briefly, it will have to track inventory levels, vendors and clients,
					 as well as sales and purchase orders. The following list itemizes the
					 requirements of the application: 
					 <itemizedlist> 
						  <listitem> 
								<para>The organization purchases and ships multiple
									 types of items.</para> 
						  </listitem> 
						  <listitem> 
								<para>The organization has multiple locations which
									 must all be kept stocked, according to some predetermined inventory
									 levels.</para> 
						  </listitem> 
						  <listitem> 
								<para>The organization fills orders from multiple
									 customers, each of which may have multiple addresses and phone numbers.</para> 
						  </listitem> 
						  <listitem> 
								<para>The organization purchases items from multiple
									 vendors, each of which may have multiple addresses and phone numbers.</para> 
						  </listitem> 
						  <listitem> 
								<para>The organization must know not only the current
									 set of demographic information for any given customer or vendor, but also a
									 historical account of what the information was at any given point, when that
									 information changed, and what user was responsible for the change.</para> 
						  </listitem> 
						  <listitem> 
								<para>The organization tracks notes for customers and
									 vendors. It is important that once a note is entered, it cannot be changed. The
									 date, time, and author of each note must be recorded with the note.</para> 
						  </listitem> 
						  <listitem> 
								<para>For each vendor, the organization must track a
									 shipping rate, as well as whether or not a given item is supplied by that
									 vendor, and the cost of each item supplied.</para> 
						  </listitem> 
						  <listitem> 
								<para>Sales orders for customers must be tracked
									 whenever a sale is made. The sales order must specify an address of the
									 customer to use as the shipping address. The sales order must be filled from
									 inventory on hand at the location. Once the order has been shipped, the net
									 effect of that sale on the inventory of the location involved is
									 recorded.</para> 
						  </listitem> 
						  <listitem> 
								<para>Purchase orders for vendors must be issued
									 whenever the inventory level at a particular location falls below par. When the
									 purchase order is received, the net effect of that purchase on the inventory of
									 the location involved is recorded.</para> 
						  </listitem> 
						  <listitem> 
								<para>The application must be able to generate
									 simulated bids from different vendors by calculating the cost of the items
									 required, plus the shipping cost using the shipping rate of the vendor and the
									 distance between the vendor and the location.</para> 
						  </listitem> 
						  <listitem> 
								<para>The users of the system will fall under three
									 basic categories: Management, Customer Service, and Inventory Clerk. Users in
									 the management role must be allowed to manage users of the system, and control
									 the access rights of those users. Customer Service users must have the ability
									 to manage customer information, and place and ship sales orders. Inventory
									 Clerks must have the ability to manage the inventory and par levels, maintain
									 vendor information, and place and receive purchase orders.</para> 
						  </listitem> 
						  <listitem> 
								<para>The application must also provide various reports
									 required by the organization.</para> 
						  </listitem> 
					 </itemizedlist></para> 
				<para>These requirements are intentionally somewhat vague. As we
					 develop the application, the less detailed areas will be more completely
					 specified as necessary. They are also somewhat simplistic. A typical
					 application would be more detailed than this, but the example is sufficient to
					 illustrate the overall process.</para> 
		  </sect1> 
		  <sect1 id="DDGPreliminaries-ApplicationDesign"> 
				<title><indexterm> 
						  <primary>Application Design</primary> 
					 </indexterm><indexterm> 
						  <primary>Dataphor Applications</primary> 
						  <secondary>Application Design</secondary> 
					 </indexterm>Application Design</title> 
				<para>As covered in the introductory part of this manual, database
					 design plays a central role in the architecture of most, if not all,
					 applications. This is particularly true of Dataphor applications, which are
					 defined almost exclusively by a database design adorned with metadata. Because
					 of this close relationship between database design and application design, we
					 begin the discussion of the running example by covering some basic approaches
					 to database design.</para> 
				<para>Note that database design will be covered in more detail in
					 the later chapters of this guide, but it is such an important topic that it is
					 worth reviewing the fundamentals here. In addition, the Dataphor platform tends
					 to reward good database designs, and conversely, to punish bad ones. In
					 general, if a given problem requires a significant amount of imperative code or
					 client-side scripting, there is likely a more elegant solution to be found
					 within the Dataphor approach to application design.</para> 
				<para>We begin by remarking that data is represented as tables, and
					 nothing but tables, in a database. Recall that in a relational database, each
					 table has a predicate, or meaning, with each row in that table corresponding to
					 a true proposition, or statement of fact. In a very real sense the database is
					 a model of some portion of the real world. In the case of the shipping example,
					 it is a model of the inventory control and ordering systems of a hypothetical
					 shipping business.</para> 
				<para>Just as each base table has meaning, the results of any query
					 also have meaning. For derived tables, or views, this meaning is derived from
					 the tables and operators involved in the expression.</para> 
				<para>Data types are an extremely important part of any database
					 design, effectively enumerating the set of available values for the columns of
					 tables and views. D4 provides several system data types, but these should only
					 be used when they really are an exact match for the type of a given column.
					 Because D4 is a strongly-typed language, types can and should be used to
					 eliminate potential errors such as comparing two values of different
					 types.</para> 
				<para>Types also provide a level of indirection and re-use when
					 designing a Dataphor application. Type definitions can be adorned with useful
					 metadata such as the type of control to be used in the presentation layer, or
					 the width of a text column on a form. This information is "inherited" by
					 columns that are defined on that type, so rather than specify the information
					 multiple times within a schema, it should be specified a single time on the
					 type definition.</para> 
				<para>Another extremely important and often overlooked part of
					 database design is considering integrity constraints. Keys and references are
					 important, but they are not the only types of constraints available. Whenever
					 the requirements of an application specify that a given condition must hold
					 within the data, a constraint should be used to declaratively enforce the
					 requirement.</para> 
				<para>The following list summarizes this short discussion in terms
					 of some useful guidelines to follow when designing a database: 
					 <itemizedlist> 
						  <listitem> 
								<para>Always define keys</para> 
								<para>Remember that tables represent statements of
									 fact, and saying the same thing more than once doesn't make it more true [8].
									 Always think about what the identifier of a given table should be. If a static
									 natural key is available, use it. Otherwise, define a surrogate key, and make
									 it an explicit part of the definition of the table.</para> 
						  </listitem> 
						  <listitem> 
								<para>Don't ignore types, they are a crucial part of
									 any database design</para> 
								<para>D4 provides extensive facilities for defining new
									 types. Types should always be chosen to completely and accurately model the
									 data being represented in the database. Proper type design will go a long way
									 towards eliminating design errors before they become program errors.</para> 
						  </listitem> 
						  <listitem> 
								<para>Always specify constraints completely</para> 
								<para>Constraints are extremely important, and
									 constitute the best approximation of the meaning of the data to the system. The
									 more information the system has about the data in the database, the more it can
									 help in ensuring that applications do not violate the intended meaning. D4
									 provides unprecedented support for declaratively enforcing constraints, take
									 advantage of it.</para> 
						  </listitem> 
						  <listitem> 
								<para>Use references</para> 
								<para>References are an important special case of
									 integrity constraints, and are used not only to enforce integrity in the
									 database, but to allow the presentation layer to navigate a schema effectively.
									 The more information the system has about the relationships that exist among
									 tables and views in the database, the more effective and useful the platform
									 will be in terms of producing a usable presentation layer from the
									 schema.</para> 
						  </listitem> 
						  <listitem> 
								<para>Design completely normalized</para> 
								<para>Normalization theory provides an effective
									 mechanism for detecting and eliminating redundancy in a database design.
									 Intuitively, each table should talk about one concept, and one concept only. A
									 properly designed database will tend to consist of lots of tables, all having
									 very few columns. Note that just because the logical design is fully
									 normalized, doesn't mean the user-interface has to be. As we will see,
									 user-interfaces for views in the Dataphor platform are just as functional as
									 user-interfaces for base table.</para> 
						  </listitem> 
						  <listitem> 
								<para>Write out the meaning of each table or
									 view</para> 
								<para>Use code comments to explicitly specify the
									 meaning of each table and view in the database. Often, this will expose design
									 errors and redundancies. If the meaning for a table is too complex or contains
									 conditions, it should probably be broken down into multiple tables.</para> 
						  </listitem> 
						  <listitem> 
								<para>Don't encode information into values</para> 
								<para>Avoid encoding information into the logical
									 representations for values. Make the information explicit with table
									 definitions, or model it as part of a type definition.</para> 
						  </listitem> 
						  <listitem> 
								<para>Avoid dependencies between columns in the same
									 table</para> 
								<para>Intercolumn dependencies are usually indications
									 of a non-normalized design. Consider decomposing the table definition into
									 multiple tables and allow the dependencies to be managed with keys and
									 references.</para> 
						  </listitem> 
					 </itemizedlist></para> 
		  </sect1> 
		  <sect1 id="DDGPreliminaries-DatabaseDesignfortheShippingExample"> 
				<title><indexterm> 
						  <primary>Shipping Application</primary> 
						  <secondary>Database Design</secondary> 
					 </indexterm>Database Design for the Shipping Example</title> 
				<para>To begin the process of designing the database for the
					 shipping example, we will isolate the main concepts required to model the
					 business. From the requirements presented so far, we have at least the
					 following concepts: 
					 <itemizedlist> 
						  <listitem> 
								<para><phrase role="code">Location</phrase></para> 
								<para><phrase role="code">Location</phrase> represents
									 shipping locations within the organization. The model will have to include
									 address information for each location, as well as track current inventory and
									 par levels for different item types.</para> 
						  </listitem> 
						  <listitem> 
								<para><phrase role="code">Customer</phrase></para> 
								<para><phrase role="code">Customer</phrase> represents
									 entities that will buy items from some location. Customer addresses, and
									 history for each address will have to be tracked.</para> 
						  </listitem> 
						  <listitem> 
								<para><phrase role="code">Vendor</phrase></para> 
								<para><phrase role="code">Vendor</phrase> represents
									 entities that sell the items we keep in stock at each location. Vendor
									 addresses, and history for each address will have to be tracked, as well as
									 shipping rates, and the items each vendor supplies.</para> 
						  </listitem> 
						  <listitem> 
								<para><phrase role="code">ItemType</phrase></para> 
								<para><phrase role="code">ItemType</phrase> represents
									 the different types of items that can be bought or sold by locations. Each item
									 type will have to track current cost.</para> 
						  </listitem> 
						  <listitem> 
								<para><phrase role="code">SalesOrder</phrase></para> 
								<para><phrase role="code">SalesOrder</phrase>
									 represents the actual transaction between a location and a customer. Each sales
									 order will track what items were sold, how much was charged, and when they
									 shipped.</para> 
						  </listitem> 
						  <listitem> 
								<para><phrase role="code">PurchaseOrder</phrase></para>
								
								<para><phrase role="code">PurchaseOrder</phrase>
									 represents the actual transaction between a location and a vendor. Each
									 purchase order will track what items were purchased, how much was paid, and
									 when they were received.</para> 
						  </listitem> 
					 </itemizedlist></para> 
				<para>In addition to these concepts, the application must be able
					 to calculate the shipping cost of a particular purchase order based on the
					 distance to the vendor, and generate bids from different vendors capable of
					 supplying a particular item. In order to calculate distances, the application
					 will use a 
					 <phrase role="code">Coordinate</phrase> data type that can
					 represent the latitude and longitude of a particular zip code. Based on the zip
					 codes in the vendor and location addresses, the shipping cost will be
					 calculated and added to the bidding cost for each supplying vendor.</para> 
				<para>The following diagram shows the basic attributes that will be
					 tracked for each of the concepts described above: 
					 <figure> 
						  <title><indexterm> 
									 <primary>Shipping Database Design</primary> 
								</indexterm>Shipping Database Design</title> 
						  <mediaobject> 
								<imageobject role="fo">
									 <imagedata fileref="Images\ShippingInitialDiagram.svg" format="SVG"
									  scalefit="1"/> 
								</imageobject> 
								<imageobject role="html">
									 <imagedata fileref="Images\ShippingInitialDiagram.emf" scalefit="1"/> 
								</imageobject> 
						  </mediaobject> 
					 </figure></para> 
				<para>Obviously, this is not a complete schema diagram, just a
					 basic outline of the main concepts involved. The details for each component of
					 the architecture will be provided as we progress through the
					 implementation.</para> 
		  </sect1> 
		  <sect1 id="DDGPreliminaries-StyleandNamingConventions"> 
				<title><indexterm> 
						  <primary>Style and Naming Conventions</primary> 
					 </indexterm><indexterm> 
						  <primary>Dataphor Applications</primary> 
						  <secondary>Style and Naming Conventions</secondary> 
					 </indexterm>Style and Naming Conventions</title> 
				<para>Strictly followed naming conventions can contribute
					 significantly to the usability and understandability of a given schema. If
					 catalog elements such as tables, views, operators, types, and columns are
					 consistently and intuitively named, queries and process logic are easier to
					 write and follow. As a result, development and maintenance tasks can be
					 significantly simplified.</para> 
				<para>Of course, style and naming conventions should be agreed upon
					 by the development team, and the Dataphor platform makes no attempt to enforce
					 any particular style or convention. However, Alphora has developed a set of
					 conventions for use in developing Dataphor applications. The running example
					 will use these conventions exclusively, and we present them here as a general
					 guideline for all applications.</para> 
				<sect2 id="DDGPreliminaries-StyleandNamingConventions-Identifiers">
					 
					 <title><indexterm> 
								<primary>Style and Naming Conventions</primary> 
								<secondary>Identifiers</secondary> 
						  </indexterm>Identifiers</title> 
					 <para>Because D4 is a case-sensitive language, and all reserved
						  words in the language are lowercase, we recommend the use of Pascal-casing for
						  all identifiers. Pascal-casing means that the first letter of each word in the
						  identifier is capitalized, and underscores are not used to separate words
						  within an identifier. In addition, acronyms should be fully capitalized. For
						  example: 
						  <programlisting>Vendor
InvoiceItem
SSN
Location_ID</programlisting></para> 
					 <para>In addition to the conventions for identifiers, it is
						  useful to explicitly delineate locally scoped variables and parameters. This is
						  accomplished by prefixing locally scoped variable names with a capital L, and
						  parameter names with a capital A. For example: 
						  <programlisting><emphasis role="bold">var</emphasis> LVariable : Integer;
<emphasis role="bold">create</emphasis> <emphasis role="bold">operator</emphasis> IsValidZipCode(<emphasis role="bold">const</emphasis> AString : String) : Boolean;</programlisting></para> 
					 <para>In addition, identifier names should be chosen carefully
						  to attach as much meaning as possible. Abbreviations should be avoided as they
						  are often counter-intuitive and vary from developer to developer. If
						  abbreviations are used at all, they should be agreed upon prior to being used.
						  The same arguments apply to the use of acronyms.</para> 
				</sect2> 
				<sect2
				 id="DDGPreliminaries-StyleandNamingConventions-StatementsExpressionsAndBlocks">
					 
					 <title><indexterm> 
								<primary>Style and Naming Conventions</primary> 
								<secondary>Statements, Expressions And
									 Blocks</secondary> 
						  </indexterm>Statements, Expressions And Blocks</title> 
					 <para>Blocks in D4 are delimited with the 
						  <phrase role="code"><emphasis
								role="bold">begin</emphasis></phrase> and 
						  <phrase role="code"><emphasis
								role="bold">end</emphasis></phrase> keywords. Some statements such as 
						  <phrase role="code"><emphasis
								role="bold">repeat</emphasis>..<emphasis role="bold">until</emphasis></phrase>
						  and 
						  <phrase role="code"><emphasis
								role="bold">do</emphasis>..<emphasis role="bold">while</emphasis></phrase> also
						  define blocks. Blocks should always begin on a new line, and statements within
						  the block should be indented one tab more than the containing block.</para> 
					 <para>Each statement should begin on a new line. Indentation
						  should be used to show dependence on the previous statement. For example: 
						  <programlisting><emphasis role="bold">if</emphasis> Length(LVariable) &gt; 5 <emphasis role="bold">then</emphasis>
	CallOperator1()
<emphasis role="bold">else</emphasis>
	CallOperator2();</programlisting></para> 
					 <para>In general, if a statement is longer than reasonable
						  (about 60 characters), it should be split onto multiple lines. The split can
						  occur along several statement boundaries including parentheses, lists, and
						  built-in operator invocations. When splitting a parentheses style operator
						  invocation, the parentheses should be used on a new line just like a block
						  delimiter: 
						  <programlisting>CallOperator
(
	LVariable1,
	LVariable2,
	LVariable3
);</programlisting></para> 
					 <para>Similarly for list boundaries: 
						  <programlisting><emphasis role="bold">select table</emphasis>
{
	<emphasis role="bold">row</emphasis> { 1 ID, "John" Name },
	<emphasis role="bold">row</emphasis> { 2, "Joe" }
};</programlisting></para> 
					 <para>Built-in operator invocations can also be used to split a
						  lengthy statement or expression: 
						  <programlisting><emphasis role="bold">select</emphasis> Employee
	<emphasis role="bold">where</emphasis> ID &gt;= 5
		<emphasis role="bold">and</emphasis> City = "Albuquerque";</programlisting></para> 
					 <para>Note that the 
						  <phrase role="code"><emphasis
								role="bold">and</emphasis></phrase> in this example is indented below the 
						  <phrase role="code"><emphasis
								role="bold">where</emphasis></phrase> to indicate that it is part of the
						  restriction condition. The general rule is that blocking statements like 
						  <phrase role="code"><emphasis
								role="bold">begin</emphasis>..<emphasis role="bold">end</emphasis></phrase>,
						  parentheses, and braces should be used consistently as blocks, with the
						  beginning delimiter beginning on a new line, and the statements within the
						  block indented one level. Also, indentation should be used to indicate
						  subordinate statements when spanning lines in a statement or expression.</para>
					 
					 <para>The following example shows a more deeply nested
						  expression using this indentation style: 
						  <programlisting><emphasis role="bold">select</emphasis> Employee
	<emphasis role="bold">where</emphasis> ID &gt;= 5
		<emphasis role="bold">and</emphasis>
		(
			City = "Albuquerque"
				<emphasis role="bold">or</emphasis> City = "Colorado Springs"
		);</programlisting></para> 
					 <para>This style of indentation prevents statements that would
						  require right-alignment. Right-aligned statements require excessive maintenance
						  when changing the enclosing statement. For example: 
						  <programlisting>CallOperator(LVariable1,
             LVariable2,
             LVariable3);</programlisting></para> 
					 <para>In the above case, a change to the operator being called
						  would require that all the subordinate expressions be realigned based on the
						  length of the new operator name.</para> 
					 <para>Another general guideline for expressions and statements
						  is that spaces should never be used before or after parentheses, and should
						  always be used before and after braces. This helps to distinguish braces from
						  parentheses in code, as both symbols are common in D4, with very different
						  meanings. In general, braces delineate lists of values or items that do not
						  require a specific ordering, and parentheses are used to construct lists of
						  items where order is important 
						  <footnote> 
								<para>For consistency with other statements, there are
									 some exceptions to this rule, notably the use of braces in list selectors and
									 order definitions.</para> 
						  </footnote>.</para> 
				</sect2> 
				<sect2 id="DDGPreliminaries-StyleandNamingConventions-Comments"> 
					 <title><indexterm> 
								<primary>Style and Naming Conventions</primary> 
								<secondary>Comments</secondary> 
						  </indexterm>Comments</title> 
					 <para>D4 supports both single-line (<phrase
						  role="code">//</phrase>) and multi-line (<phrase role="code">/*...*/</phrase>)
						  comments. In addition, the language supports nesting of multi-line comments in
						  order to allow multi-line comments to be used both for detailed comments, as
						  well as a technique for eliminating blocks of code from a given program.</para>
					 
				</sect2> 
				<sect2
				 id="DDGPreliminaries-StyleandNamingConventions-DataDefinitionLanguageStatements">
					 
					 <title><indexterm> 
								<primary>Style and Naming Conventions</primary> 
								<secondary>Data Definition Language
									 Statements</secondary> 
						  </indexterm>Data Definition Language Statements</title> 
					 <para>Data Definition Language (DDL) statements in D4 make
						  extensive use of braces to construct sets of items such as columns and keys
						  within a table definition, or tags within a metadata definition. In general,
						  the same guidelines for blocks within expressions and statements apply. For
						  example: 
						  <programlisting><emphasis role="bold">create table</emphasis> Vendor
{
	ID : Integer <emphasis role="bold">tags</emphasis> { Frontend.Width = "5" },
	Name : Description <emphasis role="bold">
		tags</emphasis> { Frontend.Preview.Include = "true" },
	<emphasis role="bold">key</emphasis> { ID }
};</programlisting></para> 
					 <para>DDL statements in D4 all follow the same basic layout as
						  the above 
						  <phrase role="code"><emphasis role="bold">create
								table</emphasis></phrase> statement. Whenever a list of items is required,
						  braces are used to delimit the list. If the entire list will easily fit on a
						  single line, then spaces should be used to separate the braces from the
						  surrounding statement. Otherwise, the braces should be used like block
						  delimiters on separate lines.</para> 
				</sect2> 
				<sect2
				 id="DDGPreliminaries-StyleandNamingConventions-TableAndViewNames"> 
					 <title><indexterm> 
								<primary>Style and Naming Conventions</primary> 
								<secondary>Table And View Names</secondary> 
						  </indexterm>Table And View Names</title> 
					 <para>Keep in mind that tables and views are variables, and
						  that they have a specific meaning within the database. Table and view names
						  should be chosen carefully to reflect that meaning. A significant amount of
						  confusion can be avoided by judiciously selecting intuitive names.</para> 
					 <para>Table and view names should follow the same guidelines as
						  identifiers. In particular, underscores should be avoided. This is because
						  underscores are reserved to delineate table names within object names such as
						  columns and references.</para> 
					 <para>Avoid distinguishing between tables and views in
						  identifiers. This naming convention underscores the logical data independence
						  provided by the Dataphor platform and encourages the interchangeability of
						  tables and views. The users of the logical model should not be concerned with
						  whether a given table variable is base or derived.</para> 
					 <para>Take advantage of the namespacing afforded by libraries.
						  Remembering that the namespace for an object is part of its full name can
						  significantly reduce the length of an identifier within its library.</para> 
					 <para>Use the simplest name possible, and try to name
						  connecting tables, for example 
						  <phrase role="code">Friend</phrase>, rather than 
						  <phrase role="code">ContactContact</phrase>.</para> 
					 <para>Table names can be either singular or plural, and a case
						  can be made for either choice, as the context in which the table is being used
						  determines whether or not singular or plural applies. However, the decision
						  should be made prior to creating any tables, and all tables within the
						  application should use the same convention. Do not mix singular and plural
						  names within a single schema.</para> 
					 <para>We note that one advantage of using singular names is
						  that it avoids inconsistent pluralization rules. For the running example, we
						  have adopted the singular table name approach.</para> 
				</sect2> 
				<sect2 id="DDGPreliminaries-StyleandNamingConventions-ColumnNames">
					 
					 <title><indexterm> 
								<primary>Style and Naming Conventions</primary> 
								<secondary>Column Names</secondary> 
						  </indexterm>Column Names</title> 
					 <para>When choosing names for columns, remember that column
						  names need not be unique within the database. All column names are implicitly
						  namespaced by their containing table variable. As with any identifier, column
						  names should be chosen carefully, and should intuitively reflect their intended
						  meaning.</para> 
					 <para>Key column names are especially important, as they are
						  used to identify and reference the rows within a table. If a column serves as a
						  surrogate identifier for a table, and that column is the entire key, the name 
						  <phrase role="code">ID</phrase> (note the capitalization to
						  emphasize pronunciation) should be used.</para> 
					 <para>For columns that participate in references to other
						  tables in the database, the column name should reflect the name of the table,
						  and of the column in that table being referenced. Here the underscore is used
						  to delineate the name of the table from the name of the column. For example: 
						  <programlisting><emphasis role="bold">create table</emphasis> EmployeeType
{
	ID : EmployeeTypeID,
	Description : Description,
	<emphasis role="bold">key</emphasis> { ID }
};

<emphasis role="bold">create table</emphasis> Employee
{
	ID : EmployeeID,
	Name : ProperName,
	Type_ID : EmployeeTypeID,
	<emphasis role="bold">key</emphasis> { ID },
	<emphasis role="bold">reference</emphasis> Employee_EmployeeType { Type_ID } 
		<emphasis role="bold">references</emphasis> EmployeeType { ID }
};</programlisting></para> 
					 <para>In the above example, the 
						  <phrase role="code">Type_ID</phrase> column of the 
						  <phrase role="code">Employee</phrase> table references the 
						  <phrase role="code">ID</phrase> column of the 
						  <phrase role="code">EmployeeType</phrase> table. Note that
						  the full table name is not used in the name of the 
						  <phrase role="code">Type_ID</phrase> column because the
						  containing table provides the implicit 
						  <phrase role="code">Employee</phrase> specification.</para>
					 
					 <para>When a column participates in both a key and a reference,
						  it should be named based on the meaning of the table that contains it. For
						  example: 
						  <programlisting><emphasis role="bold">create table</emphasis> Contact
{
	ID : ContactID,
	Name : ProperName,
	<emphasis role="bold">key</emphasis> { ID }
};

<emphasis role="bold">create table</emphasis> ContactAddress
{
	Contact_ID : ContactID,
	Street : Street,
	City : City,
	State_ID : StateID,
	ZipCode : ZipCode,
	<emphasis role="bold">key</emphasis> { Contact_ID },
	<emphasis role="bold">reference</emphasis> ContactAddress_Contact { Contact_ID } 
		<emphasis role="bold">references</emphasis> Contact { ID }
};

<emphasis role="bold">create table</emphasis> Person
{
	ID : ContactID,
	Birthday : Date { <emphasis role="bold">nil</emphasis> },
	<emphasis role="bold">key</emphasis> { ID },
	<emphasis role="bold">reference</emphasis> Person_Contact { ID } 
		<emphasis role="bold">references</emphasis> Contact { ID }
};</programlisting></para> 
					 <para>In the above example, the 
						  <phrase role="code">ContactAddress</phrase> table
						  represents extended information that may or may not be present about the
						  contact, so even though the 
						  <phrase role="code">Contact_ID</phrase> column uniquely
						  references a row in the table, the meaning of the 
						  <phrase role="code">ContactAddress</phrase> table does not
						  involve the definition of the 
						  <phrase role="code">Contact</phrase> as an entity. By
						  contrast, even though the 
						  <phrase role="code">Person</phrase> table also represents
						  extended information about the person, namely the birthday, it also means that
						  the specified contact is also a person, and is therefore called 
						  <phrase role="code">ID</phrase>. In other words, if the
						  existence of a row in the table would have meaning, even without the other
						  columns in the table, then the column name should not include the referenced
						  table name. To make this explicit, consider the following equivalent design for
						  the 
						  <phrase role="code">Person</phrase> table: 
						  <programlisting><emphasis role="bold">create table</emphasis> Person
{
	ID : ContactID,
	<emphasis role="bold">key</emphasis> { ID },
	<emphasis role="bold">reference</emphasis> Person_Contact { ID } 
		<emphasis role="bold">references</emphasis> Contact { ID }
};

<emphasis role="bold">create table</emphasis> PersonBirthday
{
	Person_ID : ContactID,
	Birthday : Date,
	<emphasis role="bold">key</emphasis> { Person_ID },
	<emphasis role="bold">reference</emphasis> PersonBirthday_Person { Person_ID } 
		<emphasis role="bold">references</emphasis> Person { ID }
};

<emphasis role="bold">create reference</emphasis> Person_PersonBirthday 
		Person { ID } 
	<emphasis role="bold">references</emphasis> PersonBirthday { Person_ID };</programlisting></para> 
					 <para>In this design it is easier to see that existence of a
						  row in the 
						  <phrase role="code">Person</phrase> table explicitly
						  designates that the specified 
						  <phrase role="code">Contact</phrase> is a 
						  <phrase role="code">Person</phrase>, not just what their
						  birthday is. By contrast, the existence of a row in the 
						  <phrase role="code">ContactAddress</phrase> table simply
						  says what the address for a given contact is, not anything about the contact
						  itself.</para> 
				</sect2> 
				<sect2
				 id="DDGPreliminaries-StyleandNamingConventions-ConstraintAndReferenceNames"> 
					 <title><indexterm> 
								<primary>Style and Naming Conventions</primary> 
								<secondary>Constraint And Reference Names</secondary> 
						  </indexterm>Constraint And Reference Names</title> 
					 <para>Constraint names should be chosen based on the type of
						  constraint. For type, column, and row level constraints, the name is only
						  required to be unique within the containing object. For example: 
						  <programlisting><emphasis role="bold">create type</emphasis> ZipCode <emphasis role="bold">like</emphasis> String
{
	<emphasis role="bold">constraint</emphasis> ZipCodeValid IsZipCodeValid(<emphasis role="bold">value</emphasis>)
};</programlisting></para> 
					 <para>Keep in mind that if no custom message is provided for
						  the constraint, the name of the constraint will be used to construct an error
						  message to be displayed to the user. Clearly and intuitively naming constraints
						  can help the user diagnose the problem.</para> 
					 <para>For catalog level constraints, including references, the
						  constraint name should include the names of the tables involved, separated by
						  underscores. Because references are such a common special case of catalog level
						  constraints, the name for a reference is simply the name of the source table
						  followed by the name of the target table, separated by an underscore. For
						  example: 
						  <programlisting><emphasis role="bold">create table</emphasis> PhoneType
{
	ID : PhoneTypeID,
	Description : Description,
	<emphasis role="bold">key</emphasis> { ID }
};

<emphasis role="bold">create table</emphasis> Phone
{
	Phone : Phone,
	Type_ID : PhoneType_ID,
	<emphasis role="bold">key</emphasis> { Phone },
	<emphasis role="bold">reference</emphasis> Phone_PhoneType { Type_ID } 
		<emphasis role="bold">references</emphasis> PhoneType { ID }
};</programlisting></para> 
					 <para>When multiple references exist between the same source
						  and target table variables, the name of the reference should include some
						  distinguishing element for both references. For example: 
						  <programlisting><emphasis role="bold">create table</emphasis> Node
{
	ID : Integer,
	<emphasis role="bold">key</emphasis> { ID }
};

<emphasis role="bold">create table</emphasis> Link
{
	Node_ID : Integer,
	Parent_Node_ID : Integer,
	<emphasis role="bold">key</emphasis> { Node_ID }
};

<emphasis role="bold">create reference</emphasis> Link_Node Link { Node_ID } 
	<emphasis role="bold">references</emphasis> Node { ID };

<emphasis role="bold">create reference</emphasis> Link_Parent_Node Link { Parent_Node_ID } 
	<emphasis role="bold">references</emphasis> Node { ID };</programlisting></para> 
				</sect2> 
				<sect2
				 id="DDGPreliminaries-StyleandNamingConventions-OperatorsAndEventHandlers"> 
					 <title><indexterm> 
								<primary>Style and Naming Conventions</primary> 
								<secondary>Operators And Event Handlers</secondary> 
						  </indexterm>Operators And Event Handlers</title> 
					 <para>Operator names should be chosen to clearly indicate the
						  action that the operator will perform. Operator names are identifiers and
						  should follow the same guidelines as other identifiers.</para> 
					 <para>Because event handlers are simply operators, they should
						  be named for the action they will perform, rather than the more traditional
						  convention of naming event handlers based on the table and event name to which
						  they are attached. Not only does this convention emphasize that event handlers
						  are just operators and can be invoked directly, but it avoids the possibility
						  of naming clashes because multiple operators can be attached to the same event.
						  For example: 
						  <programlisting><emphasis role="bold">create operator</emphasis> LogContactInsert
(
	<emphasis role="bold">const</emphasis> ARow : <emphasis role="bold">typeof</emphasis>(Contact[])
)
<emphasis role="bold">begin</emphasis>
	...
<emphasis role="bold">end</emphasis>;</programlisting></para> 
				</sect2> 
		  </sect1> 
	 </chapter> 
	 <chapter id="DDGImplementingDataTypes"> 
		  <title><indexterm> 
					 <primary>Implementing Data Types</primary> 
				</indexterm><indexterm> 
					 <primary>Logical Application Design</primary> 
					 <secondary>Implementing Data Types</secondary> 
				</indexterm>Implementing Data Types</title> 
		  <para>This chapter discusses the use and implementation of data types
				in a Dataphor application. Although the D4 language supports several categories
				of types including table, row, list, and others, this chapter discusses scalar
				types specifically.</para> 
		  <para>Scalar types in D4 provide a mechanism for describing the types
				of data to be used by an application. Not only do they model values within the
				logical model, but they provide for the definition of presentation layer
				behavior of values, as well as mappings into various devices. This discussion
				will focus mainly on building types within the logical model, but be aware that
				types not only define logical behavior, but external and internal behavior as
				well.</para> 
		  <para>Various examples throughout the discussion are all taken from the
				
				<phrase role="code">Schema.DataTypes</phrase> d4 document in the 
				<phrase role="code">Sample.Shipping</phrase> library. For the
				complete definition of all the types used in the Shipping application, refer to
				this document.</para> 
		  <sect1 id="DDGImplementingDataTypes-Representations"> 
				<title><indexterm> 
						  <primary>Representations</primary> 
						  <secondary>Overview</secondary> 
					 </indexterm><indexterm> 
						  <primary>Implementing Data Types</primary> 
						  <secondary>Representations</secondary> 
					 </indexterm>Representations</title> 
				<para>Scalar types in D4 have many different
					 <emphasis>representations</emphasis>, falling into the following general
					 categories: 
					 <itemizedlist> 
						  <listitem> 
								<para>Logical, or possible representations</para> 
								<para>Logical representations provide the conceptual
									 representations for values of the type.</para> 
						  </listitem> 
						  <listitem> 
								<para>Native representation</para> 
								<para>The native representation determines the internal
									 representation for values of the type.</para> 
						  </listitem> 
						  <listitem> 
								<para>Physical representation</para> 
								<para>The physical representation is used to encode
									 values of the type as a string of bits.</para> 
						  </listitem> 
						  <listitem> 
								<para>Device representations</para> 
								<para>Device representations are used to encode values
									 of the type for the various storage devices used by the Dataphor Server.</para>
								
						  </listitem> 
						  <listitem> 
								<para>Frontend, or presentation layer
									 representations</para> 
								<para>Frontend representations are used to display and
									 retrieve values of the type in the presentation layer.</para> 
						  </listitem> 
					 </itemizedlist></para> 
				<para>Each scalar type must have at least one logical
					 representation, and may have several, depending on the usage requirements of
					 the type. For example, most of the system types have at least two
					 representations, and some, such as 
					 <phrase role="code">DateTime</phrase>, have several. Note that
					 a representation must be capable of completely representing all values of the
					 type. Only the logical representations of a type can be accessed within
					 D4.</para> 
				<para>Each logical representation is made up of at least one, and
					 possibly several components called <emphasis>properties</emphasis>. Each
					 property has a name and a type. The name of each property is required to be
					 unique across all logical representations of the type. The type of each
					 property is allowed to be any type, including non-scalar types such as rows and
					 lists.</para> 
				<para>Each logical representation has a
					 <emphasis>selector</emphasis> operator for constructing values of the type, and
					 read and write <emphasis>accessors</emphasis> for retrieving and setting the
					 various properties of the representation. The implementation for these
					 operators is specified as part of the definition of the representation, and can
					 be written directly in D4, or <emphasis>host-implemented</emphasis> (provided
					 by a .NET CLR class within the query processor). For some representations,
					 these implementations can be provided automatically by the compiler. For a
					 complete discussion of how the compiler chooses a system representation, refer
					 to the 
					 <ulink type="olinka"
					  url="D4LGCatalogElements-ScalarTypes-PossibleRepresentations.html">Logical
						  Representations</ulink> discussion in the D4 Language Guide.</para> 
				<para>At least one representation must be host-implemented, whether
					 that implementation is system- or user-provided. Whenever possible, the
					 compiler will provide host implementations for a representation. However, only
					 one representation implementation can be system-provided, and this
					 representation determines the native and physical representations for the
					 type.</para> 
				<para>If the native representation for a type is simple and
					 system-provided, then the device representation for the type will be
					 system-provided as well. Otherwise, a scalar type map will have to be provided
					 to determine the device representation. For more information on scalar type
					 maps, refer to the 
					 <ulink type="olinka" url="DDGScalarTypeMapping.html">Scalar
						  Type Maps</ulink> discussion in the Physical Realization part of this
					 guide.</para> 
				<para>For Frontend representations, the Dataphor Server utilizes
					 <emphasis>native accessors</emphasis>. A native accessor is an operator that
					 can be called from within the Dataphor Server, or through the Call-Level
					 Interface (CLI). These operators are used by the presentation layer to convert
					 values of the type to and from a format suitable for display or manipulation
					 within the Frontend. Note that Frontend representations are also logical
					 representations available within D4. For more information on native accessors,
					 refer to the 
					 <ulink type="olinka"
					  url="D4LGCatalogElements-ScalarTypes-NativeAccessors.html">Native
						  Accessors</ulink> discussion in the D4 Language Guide.</para> 
		  </sect1> 
		  <sect1 id="DDGImplementingDataTypes-SimpleTypes"> 
				<title><indexterm> 
						  <primary>Simple Types</primary> 
					 </indexterm><indexterm> 
						  <primary>Implementing Data Types</primary> 
						  <secondary>Simple Types</secondary> 
					 </indexterm>Simple Types</title> 
				<para>We begin by constructing the simplest possible type,
					 consisting of a single representation with a single property. The following
					 example shows the 
					 <phrase role="code">ContactID</phrase> type definition: 
					 <programlisting><emphasis role="bold">create</emphasis> <emphasis role="bold">type</emphasis> ContactID 
{ 
	<emphasis role="bold">representation</emphasis> ContactID { Value : Integer } 
};</programlisting></para> 
				<para>After executing this statement, the 
					 <phrase role="code">ContactID</phrase> type is available for
					 use anywhere within D4. It can serve as the type for variables, columns in
					 tables, and parameters to operators.</para> 
				<para>In addition to the type itself, the compiler generated
					 several operators including a selector, read and write accessors, and
					 comparison operators: 
					 <programlisting>// selector
<emphasis role="bold">create operator</emphasis> ContactID(<emphasis role="bold">const</emphasis> Value : Integer);

// read accessor
<emphasis role="bold">create operator</emphasis> ContactID.ReadValue(<emphasis role="bold">const</emphasis> Value : ContactID);

// write accessor
<emphasis role="bold">create operator</emphasis> ContactID.WriteValue(<emphasis role="bold">const value</emphasis> : ContactID, <emphasis role="bold">const</emphasis> Value : Integer);
</programlisting></para> 
				<para>The 
					 <phrase role="code">Value</phrase> property can also be
					 accessed using a dot (<phrase role="code">.</phrase>) qualifier. The following
					 program listing provides several examples of the use of this new type: 
					 <programlisting><emphasis role="bold">begin</emphasis>
	// selector
	<emphasis role="bold">var</emphasis> LContactID := ContactID(1);

	// write accessor
	LContactID.Value := 2;

	// read accessor
	<emphasis role="bold">var</emphasis> LInteger := LContactID.Value;

	// equality operator
	<emphasis role="bold">var</emphasis> LEqual := LContactID = ContactID(LInteger);

	// special comparer
	<emphasis role="bold">var</emphasis> LIsSpecial := IsSpecial(LContactID);
<emphasis role="bold">end;</emphasis></programlisting></para> 
				<para>In addition, the native representation, physical
					 representation, and device representations for this type are all
					 system-provided.</para> 
		  </sect1> 
		  <sect1 id="DDGImplementingDataTypes-ImplicitConversions"> 
				<title><indexterm> 
						  <primary>Implicit Conversions</primary> 
						  <secondary>Implementing Data Types</secondary> 
					 </indexterm><indexterm> 
						  <primary>Implementing Data Types</primary> 
						  <secondary>Implicit Conversions</secondary> 
					 </indexterm>Implicit Conversions</title> 
				<para>The D4 language makes no distinction between types defined by
					 the system and user-defined types. The 
					 <phrase role="code">ContactID</phrase> type defined in the
					 previous section can be used anywhere a scalar type can be used. However, D4
					 provides <emphasis>transitive implicit conversions</emphasis> to facilitate
					 usage of the new type. For example, the following statement is invalid: 
					 <programlisting><emphasis role="bold">var</emphasis> LContactID : ContactID := 1;</programlisting></para> 
				<para>This is because the declared type of the variable 
					 <phrase role="code">LContactID</phrase> is 
					 <phrase role="code">ContactID</phrase>, and the compiler has no
					 way to convert the 
					 <phrase role="code">Integer</phrase> value 
					 <phrase role="code">1</phrase> to a value of type 
					 <phrase role="code">ContactID</phrase>. Implicit conversions
					 provide the compiler with this information.</para> 
				<para>Implicit conversions can be designated as narrowing, or
					 widening. A narrowing conversion is one that converts a value from a larger set
					 of values to an equivalent value in a smaller set of values. By contrast a
					 widening conversion converts a value to a larger set of values. In other words,
					 a narrowing conversion is one which may lose information or produce a run-time
					 error if the value being converted is not a valid value in the target type. A
					 widening conversion is one which is guaranteed not to produce a run-time error
					 or lose information. For this reason, widening conversions are favored by the
					 compiler when searching for a suitable implicit conversion path.</para> 
				<para>The following example illustrates the creation of both
					 narrowing and widening conversions for the 
					 <phrase role="code">ContactID</phrase> type to and from 
					 <phrase role="code">Integer</phrase>: 
					 <programlisting><emphasis role="bold">create conversion</emphasis> Integer <emphasis role="bold">to</emphasis> ContactID 
	<emphasis role="bold">using</emphasis> ContactID <emphasis role="bold">narrowing</emphasis>;
<emphasis role="bold">create conversion</emphasis> ContactID <emphasis role="bold">to</emphasis> Integer 
	<emphasis role="bold">using</emphasis> ContactID.ReadValue <emphasis role="bold">widening</emphasis>;
</programlisting></para> 
				<para>With these definitions in place, the initial example in this
					 section can now be executed, and the compiler will convert the 
					 <phrase role="code">Integer</phrase> value 
					 <phrase role="code">1</phrase> to a value of type 
					 <phrase role="code">ContactID</phrase> using the 
					 <phrase role="code">ContactID(Integer)</phrase>
					 selector.</para> 
				<para>Because this style of type definition is so common, D4
					 provides a 
					 <phrase role="code"><emphasis
						  role="bold">like</emphasis></phrase> clause as part of the type definition as a
					 shorthand for the declaration of simple types such as 
					 <phrase role="code">ContactID</phrase>. The following example
					 depicts an equivalent definition of the 
					 <phrase role="code">ContactID</phrase> type using a 
					 <phrase role="code"><emphasis
						  role="bold">like</emphasis></phrase> clause: 
					 <programlisting><emphasis role="bold">create type</emphasis> ContactID <emphasis role="bold">like</emphasis> Integer;</programlisting></para> 
				<para>Using this syntax, the 
					 <phrase role="code">ContactID</phrase> type is created with a
					 representation named 
					 <phrase role="code">ContactID</phrase>, with a single property
					 of type 
					 <phrase role="code">Integer</phrase> named 
					 <phrase role="code">Value</phrase>. In addition,
					 representations are created based on any representation of the like type with
					 an explicitly specified native accessor. In this case, the 
					 <phrase role="code">AsString</phrase> representation of the 
					 <phrase role="code">Integer</phrase> type is used to create an 
					 <phrase role="code">AsString</phrase> for the 
					 <phrase role="code">ContactID</phrase> type.</para> 
				<para>While implicit conversions and the 
					 <phrase role="code"><emphasis
						  role="bold">like</emphasis></phrase> syntax make defining and utilizing new
					 types extremely easy, it should be noted that some type safety is lost if they
					 are used. For example, given the following additional type definition: 
					 <programlisting><emphasis role="bold">create type</emphasis> InvoiceID <emphasis role="bold">like</emphasis> Integer;</programlisting>the following statement is valid: 
					 <programlisting><emphasis role="bold">begin</emphasis>
	<emphasis role="bold">var</emphasis> LContactID := ContactID(1);
	<emphasis role="bold">var</emphasis> LInvoiceID := InvoiceID(1);
	// comparison of ContactID and InvoiceID
	<emphasis role="bold">var</emphasis> LEqual := LContactID = LInvoiceID;
<emphasis role="bold">end;</emphasis></programlisting></para> 
				<para>This is because a conversion exists from both 
					 <phrase role="code">ContactID</phrase> and 
					 <phrase role="code">InvoiceID</phrase> to type 
					 <phrase role="code">Integer</phrase>, so the compiler will
					 widen both operands in order to fulfill the request.</para> 
		  </sect1> 
		  <sect1 id="DDGImplementingDataTypes-RepresentingUnits"> 
				<title><indexterm> 
						  <primary>Representing Units</primary> 
					 </indexterm><indexterm> 
						  <primary>Implementing Data Types</primary> 
						  <secondary>Representing Units</secondary> 
					 </indexterm>Representing Units</title> 
				<para>One use for different representations of a type is as a
					 mechanism for exposing the same value in different units. For example, when
					 building a type for distances, representations can be provided for both miles
					 and kilometers. The Shipping application makes use of this feature in the 
					 <phrase role="code">Distance</phrase> type: 
					 <programlisting><emphasis role="bold">create type</emphasis> Distance
{
	<emphasis role="bold">representation</emphasis> Miles { Miles : Decimal	},
	<emphasis role="bold">representation</emphasis> Kilometers
	{
		Kilometers : Decimal		
			<emphasis role="bold">read</emphasis> <emphasis role="bold">value</emphasis>.Miles * 1.609
			<emphasis role="bold">write</emphasis> Miles(Kilometers * 0.621)
	} <emphasis role="bold">selector</emphasis> Miles(Kilometers * 0.621)
};
</programlisting></para> 
				<para>In this example, the 
					 <phrase role="code">Miles</phrase> representation is selected
					 as the physical representation, and the 
					 <phrase role="code">Kilometers</phrase> representation is
					 implemented in terms of the 
					 <phrase role="code">Miles</phrase> representation. Either
					 selector can be used to construct a 
					 <phrase role="code">Distance</phrase> value, and either
					 representation is available from any 
					 <phrase role="code">Distance</phrase> value using the
					 appropriate accessors.</para> 
				<para>Note that the definition of the 
					 <phrase role="code">Kilometers</phrase> selector is the same as
					 the definition for the 
					 <phrase role="code">Kilometers</phrase> property write
					 accessor. These definitions will only be the same for representations with a
					 single property.</para> 
				<para>Using representations in this way allows unit conversion to
					 be implemented within the type definition, eliminating the possibility of
					 accidentally comparing miles with kilometers.</para> 
		  </sect1> 
		  <sect1 id="DDGImplementingDataTypes-CompoundTypes"> 
				<title><indexterm> 
						  <primary>Compound Types</primary> 
					 </indexterm><indexterm> 
						  <primary>Implementing Data Types</primary> 
						  <secondary>Compound Types</secondary> 
					 </indexterm>Compound Types</title> 
				<para>Scalar type representations in D4 can contain any number of
					 properties of any type. An example of such a type in the system library is the 
					 <phrase role="code">DateTime</phrase> type. The default
					 representation 
					 <phrase role="code">DateTime</phrase> for this type has
					 properties for the year, month, day, hour, minute, and second components of 
					 <phrase role="code">DateTime</phrase> values. It should be
					 noted that although the 
					 <phrase role="code">DateTime</phrase> representation of the 
					 <phrase role="code">DateTime</phrase> type is sometimes
					 referred to as the default representation because its name matches the name of
					 the type, the logical model makes no distinction between this and other
					 representations of the type. As with all scalar types, all representations are
					 equally accessible from any 
					 <phrase role="code">DateTime</phrase> value.</para> 
				<para>As with simple types, there are many different possibilities
					 for implementing compound types 
					 <footnote> 
						  <para>While we do use the terms simple and compound when
								referring to scalar types, it should be noted that the terms are only useful
								with respect to the implementation of types within the Dataphor Server.
								Firstly, because the simple vs. compound distinction really applies to
								representations, not types because a given type may have both simple and
								compound representations. Secondly, because the logical model makes no
								distinction among scalar types based on the relative complexity of the
								type.</para> 
					 </footnote> in D4. The simplest approach is to define the
					 system-provided representation as a simple representation based on a supported
					 type, and then use that representation to provide D4-implementations for the
					 selectors and accessors of the other representations. This approach allows the
					 type definition to take advantage of existing native, physical, and device
					 representations. For example, the following program listing shows the type
					 definition for the 
					 <phrase role="code">Degree</phrase> type in the Shipping
					 application: 
					 <programlisting><emphasis role="bold">create type</emphasis> Degree
{	
	<emphasis role="bold">representation</emphasis> Degrees { Degrees : Decimal },	
	<emphasis role="bold">representation</emphasis> Degree	
	{		
		DegreesPart : Integer			
			<emphasis role="bold">read</emphasis> GetDegreesPart(<emphasis role="bold">value</emphasis>.Degrees)			
			<emphasis role="bold">write</emphasis> 
					Degrees(SetDegreesPart(<emphasis role="bold">value</emphasis>.Degrees, DegreesPart)),		
		MinutesPart : Integer			
			<emphasis role="bold">read</emphasis> GetMinutesPart(<emphasis role="bold">value</emphasis>.Degrees)			
			<emphasis role="bold">write</emphasis> 
				Degrees(SetMinutesPart(<emphasis role="bold">value</emphasis>.Degrees, MinutesPart)),		
		SecondsPart : Decimal			
			<emphasis role="bold">read</emphasis> GetSecondsPart(<emphasis role="bold">value</emphasis>.Degrees)			
			<emphasis role="bold">write</emphasis> 
				Degrees(SetSecondsPart(<emphasis role="bold">value</emphasis>.Degrees, SecondsPart))	
	} <emphasis role="bold">selector</emphasis> 
				Degrees(GetDegrees(DegreesPart, MinutesPart, SecondsPart)),	
	<emphasis role="bold">representation</emphasis> AsString 	
	{ 		
		AsString : String 			
			<emphasis role="bold">read</emphasis> DegreesToString(<emphasis role="bold">value</emphasis>.Degrees)			
			<emphasis role="bold">write</emphasis> Degrees(StringToDegrees(AsString))	
	} <emphasis role="bold">selector</emphasis> Degrees(StringToDegrees(AsString))
};</programlisting></para> 
				<para>Notice that the D4 implementations for the selectors and
					 accessors of the 
					 <phrase role="code">Degree</phrase> and 
					 <phrase role="code">AsString</phrase> representations make use
					 of D4 operators such as 
					 <phrase role="code">GetDegreesPart(Decimal) : Integer</phrase>.
					 The definitions for these operators can be found in the 
					 <phrase role="code">Schema.DataTypes</phrase> script in the 
					 <phrase role="code">Sample.Shipping</phrase> library.</para> 
				<para>Another approach is to allow the compiler to provide the
					 system representation for the compound representation. In this case, the native
					 and physical representations can be provided, but the device representations
					 must be host-implemented. Still another approach involves providing the host
					 implementation for the compound representation, allowing complete control over
					 the native, physical, and device representations. For examples of these
					 approaches, refer to the section on host implementation of types and operators
					 in this chapter.</para> 
		  </sect1> 
		  <sect1 id="DDGImplementingDataTypes-TypeConstraints"> 
				<title><indexterm> 
						  <primary>Type Constraints</primary> 
						  <secondary>Implementing Data Types</secondary> 
					 </indexterm><indexterm> 
						  <primary>Implementing Data Types</primary> 
						  <secondary>Type Constraints</secondary> 
					 </indexterm>Type Constraints</title> 
				<para>Almost all type definitions will include at least one
					 <emphasis>constraint</emphasis> definition. Scalar types are allowed to specify
					 multiple constraints to allow the error messages associated with violating a
					 constraint to be more specific. All constraints defined on the type are
					 validated for every assignment to a variable of that type, including local
					 variable and column assignments. Scalar type constraints are used to define the
					 set of valid values for the type.</para> 
				<para>The following example shows the definition for the 
					 <phrase role="code">Description</phrase> type: 
					 <programlisting><emphasis role="bold">create type</emphasis> Description <emphasis role="bold">like</emphasis> String
{
	<emphasis role="bold">constraint</emphasis> LengthValid Length(<emphasis role="bold">value</emphasis>) &lt;= 50
		<emphasis role="bold">tags</emphasis> 
		{ 
			DAE.SimpleMessage = 
				"Description cannot be more than 50 characters." 
		}
}
	<emphasis role="bold">tags</emphasis> { Frontend.Width = "30" }
	<emphasis role="bold">static tags</emphasis> { Storage.Length = "50" };
</programlisting></para> 
				<para>Note that the type definition includes metadata for
					 specifying presentation and storage layer behaviors, and also includes a custom
					 message to be displayed when the constraint is violated. The 
					 <phrase role="code">DAE.SimpleMessage</phrase> tag allows a
					 static message to be displayed, while the 
					 <phrase role="code">DAE.Message</phrase> tag allows dynamic
					 messages to be constructed as a D4 string-valued expression that is evaluated
					 with the value being validated. For example, the following tag definition could
					 be used to provide the invalid value as part of the error message: 
					 <phrase role="code">DAE.Message = "'Description ""' + value +
						  '"" is too long.'"</phrase>.</para> 
				<para>For more complex type constraints, previously defined
					 operators can be invoked within the constraint expression. As with all
					 constraints, the resulting expression must be boolean-valued, functional, and
					 deterministic. For type constraints, the added restriction is included that the
					 expression must not reference any tables or views within the database.</para> 
				<para>The following program listing shows the definition of the 
					 <phrase role="code">ZipCode</phrase> type: 
					 <programlisting><emphasis role="bold">create operator</emphasis> IsZipCode(<emphasis role="bold">const</emphasis> AString : String) : Boolean
<emphasis role="bold">begin</emphasis>	
	<emphasis role="bold">result</emphasis> := 
		(AString.Length() = 5) 
			<emphasis role="bold">or</emphasis>
			(
				AString.Length() = 10 
					<emphasis role="bold">and</emphasis> AString.IndexOf('-') = 5
			);
<emphasis role="bold">end</emphasis>;

<emphasis role="bold">create type</emphasis> Zip <emphasis role="bold">like</emphasis> String
{
	<emphasis role="bold">constraint</emphasis> ZipCodeValid IsZipCode(<emphasis role="bold">value</emphasis>)
}
	<emphasis role="bold">tags</emphasis> { Frontend.Width = "10" }
	<emphasis role="bold">static tags</emphasis> { Storage.Length = "10" };</programlisting></para> 
				<para>Note that because the constraint expression can be evaluated
					 without referencing the state of the database, the definition of the constraint
					 will be transparently downloaded to the Frontend client and evaluated there,
					 avoiding unnecessary network round trips during user input.</para> 
		  </sect1> 
		  <sect1 id="DDGImplementingDataTypes-Defaults"> 
				<title><indexterm> 
						  <primary>Defaults</primary> 
						  <secondary>Implementing Data Types</secondary> 
					 </indexterm><indexterm> 
						  <primary>Implementing Data Types</primary> 
						  <secondary>Defaults</secondary> 
					 </indexterm>Defaults</title> 
				<para>Each type definition in D4 can include an optional
					 <emphasis>default</emphasis> definition that specifies a value to be used when
					 one is not supplied as part of a variable definition or insert statement. The
					 default is allowed to be non-deterministic, and reference global database
					 state. This allows defaults to be used to implement auto-incrementing
					 identifiers. The following example illustrates the use of a type-level default:
					 
					 <programlisting><emphasis role="bold">create type</emphasis> CreatedOnDateTime <emphasis role="bold">like</emphasis> DateTime
{
	<emphasis role="bold">default</emphasis> DateTime()
} <emphasis role="bold">tags</emphasis> { Frontend.Title = "Created On" };</programlisting></para> 
		  </sect1> 
		  <sect1 id="DDGImplementingDataTypes-Specials"> 
				<title><indexterm> 
						  <primary>Specials</primary> 
						  <secondary>Implementing Data Types</secondary> 
					 </indexterm><indexterm> 
						  <primary>Implementing Data Types</primary> 
						  <secondary>Specials</secondary> 
					 </indexterm>Specials</title> 
				<para>A <emphasis>special</emphasis> is a mechanism for
					 representing missing information within a particular type. Each type is allowed
					 to have any number of specials defined. Each special singles out a value of the
					 type as special in terms of the meaning of the value within the application.
					 Each special definition causes the creation of a special selector, and a
					 special comparer for use in manipulating the special values.</para> 
				<para>Special values are also considered satisfying values for the
					 purpose of reference constraint enforcement.</para> 
				<para>An example of the use of a special is provided by the 
					 <phrase role="code">VersionNumber</phrase> system-defined data
					 type. This data type models a four-part version number with 
					 <phrase role="code">Major</phrase>, 
					 <phrase role="code">Minor</phrase>, 
					 <phrase role="code">Revision</phrase>, and 
					 <phrase role="code">Build</phrase> numbers. The following code
					 listing shows a simplified definition for this type: 
					 <programlisting><emphasis role="bold">create type</emphasis> VersionNumber
{
	<emphasis role="bold">representation</emphasis> VersionNumber
	{
		Major : Integer,
		Minor : Integer,
		Revision : Integer,
		Build : Integer
	},
	<emphasis role="bold">special</emphasis> Undefined VersionNumber(-1, -1, -1, -1)
};</programlisting></para> 
				<para>The special definition designates the 
					 <phrase role="code">VersionNumber</phrase> value with all
					 components equal to 
					 <phrase role="code">-1</phrase> as 
					 <phrase role="code">Undefined</phrase>. This definition causes
					 the following additional operators to be defined: 
					 <programlisting>// Special Selector
<emphasis role="bold">create operator</emphasis> VersionNumberUndefined() : VersionNumber;

// Special Comparer
<emphasis role="bold">create operator</emphasis> IsUndefined(<emphasis role="bold">const</emphasis> AValue : VersionNumber) : Boolean;

// Generic Special Comparer
<emphasis role="bold">create operator</emphasis> IsSpecial(<emphasis role="bold">const</emphasis> AValue : VersionNumber) : Boolean;</programlisting></para> 
				<para>The special selector 
					 <phrase role="code">VersionNumberUndefined</phrase> returns the
					 value of the special 
					 <phrase role="code">Undefined</phrase>. The special comparer
					 returns true if the given 
					 <phrase role="code">VersionNumber</phrase> value is equal to
					 the 
					 <phrase role="code">Undefined</phrase> special, and the generic
					 special comparer returns true if the given 
					 <phrase role="code">VersionNumber</phrase> value is equal to
					 any special value of the 
					 <phrase role="code">VersionNumber</phrase> type.</para> 
				<para>Note that in order for specials to work properly as a
					 solution for missing information, they must <emphasis>not</emphasis> be
					 considered as some sort of default value for the type. A special value should
					 be introduced that is outside the domain of normal values for the type in
					 question. For example, the following type definition would not correctly model
					 the 
					 <phrase role="code">Unknown</phrase> salary: 
					 <programlisting><emphasis role="bold">create type</emphasis> Salary <emphasis role="bold">like</emphasis> Money
{
	<emphasis role="bold">special</emphasis> Unknown $0
};</programlisting></para> 
				<para>The reason this does not work from the logical perspective is
					 that the value 
					 <phrase role="code">$0</phrase> is a valid value for the 
					 <phrase role="code">Salary</phrase> type. In order to function
					 reasonably as a special value, the special should be an additional value
					 included in the type, over and above the normal set of values available.</para>
				
		  </sect1> 
		  <sect1 id="DDGImplementingDataTypes-Operators"> 
				<title><indexterm> 
						  <primary>Operators</primary> 
						  <secondary>Implementing Data Types</secondary> 
					 </indexterm><indexterm> 
						  <primary>Implementing Data Types</primary> 
						  <secondary>Operators</secondary> 
					 </indexterm>Operators</title> 
				<para>Operators in D4 allow the behavior of an application to be
					 modeled. In order to be used within D4, each data type must have an equality
					 operator defined, and will usually have a relative comparison operator defined
					 where appropriate. If the native representation for a given type is
					 system-provided, then the compiler will also provide equality and comparison
					 operations based on the native representation. Otherwise, these operators must
					 be supplied with the type definition.</para> 
				<para>In addition to fundamental operations like equality and
					 relative comparison, operators in D4 can be used to provide
					 application-specific behavior for types. In the Shipping example, the
					 geographical coordinates of store and vendor locations are used to compute
					 distances and shipping rates. For each of these types of values, data types are
					 defined to ensure that the values are represented correctly within the
					 application. Operators are then provided to manipulate values of these types to
					 produce the desired shipping distance and cost.</para> 
				<para>The following example illustrates some of these operators: 
					 <programlisting><emphasis role="bold">create operator</emphasis> Distance
(
	<emphasis role="bold">const</emphasis> AFrom : Coordinate, 
	<emphasis role="bold">const</emphasis> ATo : Coordinate
) : Distance
<emphasis role="bold">begin</emphasis>	
	<emphasis role="bold">result</emphasis> := 		
		Kilometers		
		(			
			(				
				(					
					((ATo.Latitude.Degrees - AFrom.Latitude.Degrees) ** 2) + 					
					((ATo.Longitude.Degrees - AFrom.Longitude.Degrees) ** 2)				
				) ** 				
				0.5			
			) / 			
			0.008987		
		);
<emphasis role="bold">end</emphasis>;

<emphasis role="bold">create operator</emphasis> iMultiplication
(
	<emphasis role="bold">const</emphasis> ADistance : Distance, 
	<emphasis role="bold">const</emphasis> ARate : ShippingRate
) : Money
<emphasis role="bold">begin</emphasis>
	<emphasis role="bold">result</emphasis> := ADistance.Miles * ARate.Rate;
<emphasis role="bold">end</emphasis>;</programlisting></para> 
				<para>For more information on defining and using operators, refer
					 to the 
					 <ulink type="link"
					  url="DDGModelingProcessLogic.html"><citetitle>Modeling Process
								Logic</citetitle></ulink> chapter.</para> 
		  </sect1> 
		  <sect1 id="DDGImplementingDataTypes-EventHandlers"> 
				<title><indexterm> 
						  <primary>Event Handlers</primary> 
						  <secondary>Implementing Data Types</secondary> 
					 </indexterm><indexterm> 
						  <primary>Implementing Data Types</primary> 
						  <secondary>Event Handlers</secondary> 
					 </indexterm>Event Handlers</title> 
				<para>An <emphasis>event handler</emphasis> is an operator that has
					 been attached to a specific event occurring within the system. The Dataphor
					 Server provides three kinds of events for scalar types:
					 <emphasis>default</emphasis>, <emphasis>change</emphasis>, and
					 <emphasis>validate</emphasis>. These event handlers can be used to implement
					 special purpose behavior that is not captured by the declarative statements
					 available in D4. For example, the following type definition used in the
					 Shipping example ensures that values of type 
					 <phrase role="code">StateID</phrase> are always uppercase,
					 without requiring the user to ensure that this is the case: 
					 <programlisting><emphasis role="bold">create</emphasis> <emphasis role="bold">type</emphasis> StateID <emphasis role="bold">like</emphasis> String
{
	<emphasis role="bold">constraint</emphasis> StateIDValid (Length(<emphasis role="bold">value</emphasis>) = 2)
}
	<emphasis role="bold">tags</emphasis> { Frontend.Title = "State", Frontend.Width = "4" }
	<emphasis role="bold">static</emphasis> <emphasis role="bold">tags</emphasis> { Storage.Length = "2" };

<emphasis role="bold">create operator</emphasis> StateIDUpper(<emphasis role="bold">var</emphasis> AStateID : StateID) : Boolean
<emphasis role="bold">begin</emphasis>	
	<emphasis role="bold">result</emphasis> := <emphasis role="bold">false</emphasis>;	
	<emphasis role="bold">if not</emphasis>(IsUpper(AStateID)) <emphasis role="bold">then</emphasis>
	<emphasis role="bold">begin</emphasis>		
		AStateID := Upper(AStateID);		
		<emphasis role="bold">result</emphasis> := <emphasis role="bold">true</emphasis>;	// AStateID has been changed
	<emphasis role="bold">end</emphasis>;
<emphasis role="bold">end</emphasis>;
<emphasis role="bold">attach operator</emphasis> StateIDUpper <emphasis role="bold">to</emphasis> StateID <emphasis role="bold">on</emphasis> <emphasis role="bold">validate</emphasis>;</programlisting></para> 
		  </sect1> 
		  <sect1 id="DDGImplementingDataTypes-Host-ImplementedTypesandOperators">
				
				<title><indexterm> 
						  <primary>Host-Implemented Types</primary> 
					 </indexterm><indexterm> 
						  <primary>Host-Implemented Operators</primary> 
					 </indexterm><indexterm> 
						  <primary>Implementing Data Types</primary> 
						  <secondary>Host-Implemented Types and Operators</secondary>
						  
					 </indexterm>Host-Implemented Types and Operators</title> 
				<para>In addition to allowing the system to provide the
					 implementations for a given type, the type definition can include class
					 definitions that specify host-implementations for the various representations,
					 selectors, and accessors of a given type. This is most often done to control
					 the native and physical representations for compound types. In the Shipping
					 example, the 
					 <phrase role="code">Coordinate</phrase> data type is
					 host-implemented. The following program listing shows the definition of the 
					 <phrase role="code">Coordinate</phrase> type: 
					 <programlisting><emphasis role="bold">create type</emphasis> Coordinate
{
	<emphasis role="bold">representation</emphasis> Coordinate
	{
		Latitude : Degree
			<emphasis role="bold">read class</emphasis> "Shipping.LatitudeReadAccessor" 
			<emphasis role="bold">write class</emphasis> "Shipping.LatitudeWriteAccessor",
		Longitude : Degree
			<emphasis role="bold">read class</emphasis> "Shipping.LongitudeReadAccessor"
			<emphasis role="bold">write class</emphasis> "Shipping.LongitudeWriteAccessor"
	} <emphasis role="bold">class</emphasis> "Shipping.CoordinateSelector",	representation AsString
	{
		AsString : String
			<emphasis role="bold">read value</emphasis>.Latitude.AsString + "/" + <emphasis role="bold">value</emphasis>.Longitude.AsString
			<emphasis role="bold">write</emphasis> 
				Coordinate
				(
					Degree.AsString(AsString.SubString(0, AsString.IndexOf("/"))), 
					Degree.AsString(AsString.SubString(AsString.IndexOf("/") + 1))
				)
	}
		<emphasis role="bold">selector</emphasis>
			Coordinate
			(
				Degree.AsString(AsString.SubString(0, AsString.IndexOf("/"))),
				Degree.AsString(AsString.SubString(AsString.IndexOf("/") + 1))
			)
} <emphasis role="bold">class</emphasis> "Shipping.CoordinateConveyor"
	<emphasis role="bold">tags</emphasis> { Storage.Length = "45" };</programlisting></para> 
				<para>In addition to providing the host-implementation for types
					 and representations, the D4 language allows for host-implementation of
					 operators. In the Shipping example, the comparison operator for the 
					 <phrase role="code">Coordinate</phrase> type is a
					 host-implemented operator. 
					 <programlisting><emphasis role="bold">create operator</emphasis> iCompare
(
	<emphasis role="bold">const</emphasis> ACoordinate1 : Coordinate, 
	<emphasis role="bold">const</emphasis> ACoordinate2 : Coordinate
) : Integer
	<emphasis role="bold">class</emphasis> "Shipping.CoordinateCompare";</programlisting></para> 
				<para>These classes are defined in a .NET assembly 
					 <footnote> 
						  <para>A .NET assembly is roughly equivalent to the concept
								of a <emphasis>dynamic link library</emphasis> in traditional Windows-based
								programming.</para> 
					 </footnote> which is registered with the Dataphor Server as
					 part of the registration of the 
					 <phrase role="code">Shipping</phrase> library. The project
					 source for the assembly is available in the 
					 <phrase role="code">Source</phrase> sub-directory of the 
					 <phrase role="code">Shipping</phrase> library directory. The
					 source project includes the following files: 
					 <itemizedlist> 
						  <listitem> 
								<para><phrase role="code">Shipping.csproj</phrase> -
									 Microsoft Visual C# Project File</para> 
						  </listitem> 
						  <listitem> 
								<para><phrase role="code">AssemblyInfo.cs</phrase> -
									 Contains assembly level attribute definitions.</para> 
						  </listitem> 
						  <listitem> 
								<para><phrase role="code">Coordinate.cs</phrase> -
									 Contains the implementation classes for the Coordinate data types and
									 operators.</para> 
						  </listitem> 
						  <listitem> 
								<para><phrase role="code">Domains.cs</phrase> -
									 Contains the SQL device mapping for the coordinate data type.</para> 
						  </listitem> 
						  <listitem> 
								<para><phrase role="code">Register.cs</phrase> -
									 Contains the Dataphor registration implementation for the assembly.</para> 
						  </listitem> 
					 </itemizedlist></para> 
				<para>These files are compiled into a .NET assembly, which is then
					 placed directly in the 
					 <phrase role="code">Shipping</phrase> library directory. The
					 assembly is then referenced as a library file in the definition of the 
					 <phrase role="code">Shipping</phrase> library, and marked to be
					 registered as an assembly. When the library loads, any files referenced are
					 copied into the Dataphor Server run-time directory. Any file marked to be
					 registered as an assembly is then loaded into the Dataphor Server application
					 domain, and searched for the 
					 <phrase role="code">DAERegisterAttribute</phrase>. The 
					 <phrase role="code">AssemblyInfo.cs</phrase> file contains this
					 entry, and specifies that the 
					 <phrase role="code">Alphora.Shipping.DAERegister</phrase> class
					 should be used to perform the registration. This class is responsible for
					 returning to the Dataphor Server a list of the available host implementations,
					 and the class alias for each. The classes returned are then registered with
					 Dataphor Server, and can be referenced in any class definition from D4.</para> 
				<para>For more information on the implementations in the 
					 <phrase role="code">Shipping</phrase> library, refer to the
					 source code for each host-implementation class.</para> 
		  </sect1> 
	 </chapter> 
	 <chapter id="DDGRepresentingDatawithTablesandViews"> 
		  <title><indexterm> 
					 <primary>Representing Data with Tables and Views</primary> 
				</indexterm><indexterm> 
					 <primary>Logical Application Design</primary> 
					 <secondary>Representing Data with Tables and Views</secondary> 
				</indexterm>Representing Data with Tables and Views</title> 
		  <para>This chapter discusses using tables and views to represent the
				data structures of an application. The first section discusses tables, or base
				table variables, and the various components that make up their definitions. The
				next section discusses table-valued operators and expressions, and the various
				inference mechanisms at work in the D4 compiler. The final section focuses on
				derived table variables, including view updatability.</para> 
		  <sect1 id="DDGRepresentingDatawithTablesandViews-BaseTableVariables"> 
				<title><indexterm> 
						  <primary>Tables</primary> 
						  <secondary>Representing Data With</secondary> 
					 </indexterm><indexterm> 
						  <primary>Representing Data with Tables and Views</primary> 
						  <secondary>Tables</secondary> 
					 </indexterm>Tables</title> 
				<para>Perhaps the most important aspect of the relational model is
					 the idea that tables in the database have meaning. They allow us to model some
					 aspect of reality, and then ask questions about that model. With this in mind,
					 we turn to the problem of building a database to model the organization in the
					 Shipping application. Recall that the requirements of the application involve
					 tracking shipping locations, vendors, customers, orders, and inventory. We
					 begin by modeling the organization itself as a set of locations.</para> 
				<para>The following illustration provides a more detailed visual
					 representation of the tables involved in representing shipping locations within
					 the organization: 
					 <figure> 
						  <title><indexterm> 
									 <primary>Shipping Database Design</primary> 
									 <secondary>Locations</secondary> 
								</indexterm>Shipping Database Design: Locations</title>
						  
						  <mediaobject> 
								<imageobject role="fo">
									 <imagedata fileref="Images\LocationDiagram.svg" format="SVG" scalefit="1"/> 
								</imageobject> 
								<imageobject role="html">
									 <imagedata fileref="Images\LocationDiagram.emf" scalefit="1"/> 
								</imageobject> 
						  </mediaobject> 
					 </figure></para> 
				<para>Note that although tabular representations such as this
					 diagram are often used to help visualize database designs, they are only
					 pictorial representations. It is important to remember that table values are
					 not flat structures, nor do they have any ordering, left-to-right, or
					 top-to-bottom. They are n-dimensional structures, where each column in the
					 table value corresponds to another dimension, with possible values for that
					 dimension taken from the type of that column.</para> 
				<para>Of course, the visual representation omits some extremely
					 important details such as the data types of the columns involved, and any
					 constraints (except for the visual representation of keys with asterisks, and
					 references with directed lines) that may need to be enforced on the data. The
					 following D4 script taken from the 
					 <phrase role="code">Schema.LocationTables</phrase> document
					 fills in these details: 
					 <programlisting><emphasis>//* Table: Location
// Location designated by [ID] is named [Name], has phone # [Phone], 
// and address [Street], [City], [State_ID], [Zip]</emphasis>
<emphasis role="bold">create table</emphasis> Location
{
	ID : LocationID,
	Name : ProperName <emphasis role="bold">tags</emphasis> { Frontend.Preview.Include = "true" },
	Phone : Phone,
	Street : Description
		<emphasis role="bold">tags</emphasis> { Frontend.Group = "Address" },
	City : Description 
		<emphasis role="bold">tags</emphasis> { Frontend.Group = "Address", Frontend.FlowBreak = "true" },
	State_ID : StateID 
		<emphasis role="bold">tags</emphasis> { Frontend.Group = "Address", Frontend.FlowBreak = "true" },
	ZipCode : Zip <emphasis role="bold">tags</emphasis> { Frontend.Group = "Address" },
	<emphasis role="bold">key</emphasis> { ID }
};

<emphasis role="bold">create reference</emphasis> Location_State 
	Location { State_ID } <emphasis role="bold">references</emphasis> State { ID } 
	<emphasis role="bold">tags</emphasis> { Frontend.Embedded = "false" };
<emphasis role="bold">create reference</emphasis> Location_ZipCode 
	Location { ZipCode } <emphasis role="bold">references</emphasis> ZipCode { ZipCode } 
	<emphasis role="bold">tags</emphasis> { Frontend.Embedded = "false" };</programlisting></para> 
				<para>With this table definition, we can now represent any number
					 of shipping locations within the organization. The existence of a row in the 
					 <phrase role="code">Location</phrase> table corresponds
					 directly with the existence of a location in the real world. Each shipping
					 location is given a unique identifier, represented by the 
					 <phrase role="code">ID</phrase> column. The address and phone
					 number of the location are also recorded. Because of the reference to the 
					 <phrase role="code">ZipCode</phrase> table, the value in the 
					 <phrase role="code">ZipCode</phrase> column must correspond
					 with the value of the 
					 <phrase role="code">ZipCode</phrase> column for some row in the
					 
					 <phrase role="code">ZipCode</phrase> table. This guarantees
					 that for any location, approximate geographical coordinates can be determined.
					 This fact will be used later when we calculate distances between shipping
					 locations and vendors.</para> 
				<para>The above table definition includes several metadata tags
					 that, along with the definition of the table itself, are used to derive
					 user-interfaces for the table. We will have more to say about these tags in
					 Part III of this guide. We include them here to show that although this guide
					 covers logical, presentation, and physical design considerations separately,
					 when developing applications in Dataphor, it is often helpful to consider these
					 issues as a whole.</para> 
				<para>At this point, with just a few simple tables created (<phrase
					 role="code">State</phrase>, 
					 <phrase role="code">ZipCode</phrase>, and 
					 <phrase role="code">Location</phrase>), we already have a
					 working application. To see this, right-click on the 
					 <phrase role="code">Location</phrase> table in the Dataphor
					 Explorer and select 
					 <phrase role="code">Browse</phrase>. The resulting browse
					 interface provides an entry point to manage shipping locations within the
					 organization.</para> 
				<para>The next several sections will discuss the various components
					 of a base table variable definition, such as columns, keys, orders, constraints
					 and references.</para> 
				<sect2
				 id="DDGRepresentingDatawithTablesandViews-BaseTableVariables-Columns"> 
					 <title><indexterm> 
								<primary>Columns</primary> 
								<secondary>Representing Data With Tables</secondary> 
						  </indexterm><indexterm> 
								<primary>Nilability Indicator</primary> 
						  </indexterm>Columns</title> 
					 <para>As mentioned in Part I, the structure of a base table
						  variable is explicitly specified as a set of columns in the table definition.
						  Each column has a name that is unique within the table, and is defined to be of
						  some type. Note that while D4 allows non-scalar-valued columns in table and row
						  type definitions, the SQL-based devices that serve as the storage engine for
						  the Dataphor Server do not support these kinds of table definitions.</para> 
					 <para>Each column may contain a default definition, and a set
						  of constraint definitions. If a default is specified on the column, it will be
						  used in favor of a default specified in the type definition. Any constraint
						  definitions specified on the column are enforced in addition to any constraints
						  defined in the type definition. Defaults and constraints will be discussed in
						  more detail in the 
						  <ulink type="link"
							url="DDGEnforcingBusinessRulesDeclaratively.html"><citetitle>Enforcing Business
									 Rules Declaratively</citetitle></ulink> chapter.</para> 
					 <para>Column definitions also contain a nilability indicator
						  that determines whether the column is required to have a value. Note that
						  disallowing nils with the nilability indicator is basically shorthand for the
						  constraint specification 
						  <phrase role="code"><emphasis
								role="bold">not</emphasis>(IsNil(<emphasis
								role="bold">value</emphasis>))</phrase> 
						  <footnote> 
								<para>There are cases having to do with
									 <emphasis>proposables</emphasis> where the nilability indicator provides more
									 information to the Dataphor Server than the equivalent constraint expression
									 would. Proposables will be discussed in detail in Part III of this guide. In
									 addition, as with most declarative statements, using the nilability indicator
									 over the equivalent constraint definition allows the Dataphor Server to make
									 certain implementation optimizations.</para> 
						  </footnote>.</para> 
				</sect2> 
				<sect2
				 id="DDGRepresentingDatawithTablesandViews-BaseTableVariables-KeysandOrders"> 
					 <title><indexterm> 
								<primary>Keys</primary> 
								<secondary>Representing Data With Tables</secondary> 
						  </indexterm><indexterm> 
								<primary>Orders</primary> 
								<secondary>Representing Data With Tables</secondary> 
						  </indexterm>Keys and Orders</title> 
					 <para>Every table definition can have any number of keys
						  (except 0) defined. If no key definition is provided as part of a base table
						  variable definition, then all comparable columns of the table variable are
						  assumed as the key.</para> 
					 <para>Each table definition can also include any number of
						  order definitions. These definitions serve two purposes in the application
						  schema. First, they provide the list of possible orderings for user-interfaces
						  in the Frontend. Second, they provide a mapping for index creation in the
						  physical layer.</para> 
					 <para>Note that the 
						  <phrase role="code"><emphasis role="bold">order
								by</emphasis></phrase> clause of a cursor definition can always be used to
						  request data in any order, regardless of the order definitions provided for a
						  table variable. Order definitions are metadata that is used by the presentation
						  layer and the physical layer.</para> 
					 <para>Each order definition can specify any number of columns
						  in the table variable. The order in which the columns appear in the order
						  definition determines the order of the index. Each order column definition can
						  also include an ascending indicator, and an optional sort function.</para> 
					 <para><indexterm> 
								<primary>TableDee</primary> 
						  </indexterm><indexterm> 
								<primary>TableDum</primary> 
						  </indexterm>An important point about table values in D4 is
						  that the set of columns that make up the table is not necessarily non-empty.
						  Not only can table values with no columns be produced by projection, but base
						  table variable definitions are allowed to have no columns. There are two
						  possible table values with no columns: the table with no columns and no rows,
						  and the table with no columns and one row. Note that the table with no columns
						  cannot have more than one row, otherwise it would contain duplicates (a row
						  with no columns is equal to a row with no columns). These table values turn out
						  to be both useful and important in the D4 language. So much so that they have
						  been defined in the system catalog as the tables 
						  <phrase role="code">TableDum</phrase> and 
						  <phrase role="code">TableDee</phrase>, respectively 
						  <footnote> 
								<para>The names 
									 <phrase role="code">TableDee</phrase> and 
									 <phrase role="code">TableDum</phrase> are taken
									 from the collection of articles by Hugh Darwen, republished as Adventures in
									 Relationland in reference [7]</para> 
						  </footnote>.</para> 
					 <para>Also note that just as tables are allowed to have no
						  columns, so are keys and references. Indeed the key of 
						  <phrase role="code">TableDum</phrase> and 
						  <phrase role="code">TableDee</phrase> is obviously an empty
						  key. When a table is defined with an empty key, the table is effectively
						  constrained to have at most one row. This is because any row, no matter what
						  the values for any of its columns, would have the same values for no columns.
						  The empty key is particularly useful for database-wide settings tables that
						  should only ever have one row.</para> 
				</sect2> 
				<sect2
				 id="DDGRepresentingDatawithTablesandViews-BaseTableVariables-ConstraintsandReferences">
					 
					 <title><indexterm> 
								<primary>Constraints</primary> 
								<secondary>Representing Data With Tables</secondary> 
						  </indexterm><indexterm> 
								<primary>References</primary> 
								<secondary>Representing Data With Tables</secondary> 
						  </indexterm>Constraints and References</title> 
					 <para>Table variable definitions may also include any number of
						  constraint and reference definitions. Constraint definitions may be row-level,
						  or transition constraint definitions. In either case, the constraint expression
						  is allowed to reference table variables in the database. If a given constraint
						  definition does not reference table variables in the database, the constraint
						  is considered immediate. Otherwise, the constraint is considered deferred.
						  Immediate constraints are checked whenever a potentially violating modification
						  occurs. Deferred constraints, on the other hand, are checked when the
						  transaction in which the modification occurred is being committed.</para> 
					 <para>References are directional, meaning that they originate
						  in one table variable, and target another. When discussing a given reference
						  from the perspective of the originating table variable, the reference is called
						  a <emphasis>source reference</emphasis>. When discussing a given reference from
						  the perspective of the referenced table variable, the reference is called a
						  <emphasis>target reference</emphasis>.</para> 
					 <para>Constraints and references will be discussed in more
						  detail in the 
						  <ulink type="link"
							url="DDGEnforcingBusinessRulesDeclaratively.html"><citetitle>Enforcing Business
									 Rules Declaratively</citetitle></ulink> chapter.</para> 
				</sect2> 
		  </sect1> 
		  <sect1 id="DDGRepresentingDatawithTablesandViews-TableOperators"> 
				<title><indexterm> 
						  <primary>Table Operators</primary> 
						  <secondary>Overview</secondary> 
					 </indexterm>Table Operators</title> 
				<para>Generally speaking, a table operator is an operator that
					 deals primarily with table values. This section introduces the various table
					 operators available in D4, and discusses the inference mechanisms of the D4
					 compiler that are used to determine the schema-level description of the
					 resulting table values. There are several important points to be made regarding
					 table operators in general.</para> 
				<para>First, the term <emphasis>table operator</emphasis> is more
					 of a categorization of the system operators for use in guiding the discussion
					 than an actual delineation of operators. For example, some table operators,
					 such as 
					 <phrase role="code"><emphasis
						  role="bold">exists</emphasis></phrase> and 
					 <phrase role="code"><emphasis
						  role="bold">in</emphasis></phrase> take table values as arguments, but result
					 in scalar values. It is important to remember that operators in D4 are a
					 general purpose construct. Each operator can take any number of parameters of
					 any type, and optionally return a result of any type.</para> 
				<para>Second, it is important to remember that the operators
					 discussed in this section are, at least conceptually, table-level. That is,
					 they operate on entire table values at once, and result in a new table value.
					 Of course, the actual implementation is pipelined for maximum efficiency, but
					 this is transparent to the logical model. These operations should not be
					 thought of as row-at-a-time operations.</para> 
				<para>Third, when used together the operators discussed in this
					 section form an <emphasis>algebra</emphasis>. In particular, the output of one
					 operator is a table value and can be used as the input to another. This
					 property is called <emphasis>closure</emphasis> and means that these operators
					 can be chained together to form arbitrarily complex expressions. This is very
					 different from traditional calculus style languages such as SQL that require
					 that a query be expressed in a particular form such as 
					 <phrase role="code"><emphasis
						  role="bold">select..from..where</emphasis></phrase> 
					 <footnote> 
						  <para>In fairness, it should be noted that SQL-92 provides
								support for nested query expressions within the from clause, effectively
								providing for algebraic style nesting. However, because this capability was
								introduced after the fact, nesting queries in SQL requires excessive
								"circumlocution". In addition, many systems still do not provide support for
								this feature, and even among those that do, there are often severe limitations
								on its usage.</para> 
					 </footnote>.</para> 
				<para>And finally, the operators discussed in this section are all
					 <emphasis>built-in</emphasis> operators, meaning that the syntax for the
					 invocation is built into the D4 language. As stated above, D4 provides
					 facilities for defining table-valued operators over and above the built-in and
					 system-provided operators.</para> 
				<para>The following sections will discuss the various inference
					 mechanisms of the D4 compiler in general, and the behavior of each operator in
					 particular. The explanations for each built-in table operator will draw on the
					 data model of the shipping application. The full definition for these table
					 variables is found in the various schema documents in the 
					 <phrase role="code">Sample.Shipping</phrase> library.</para> 
				<para>Note that this discussion only includes the most common table
					 operators. For a complete description of all the available table operators,
					 refer to the 
					 <ulink url="D4LGTableExpressions.html"><citetitle>Table
								Operators</citetitle></ulink> chapter of the D4 Language Guide.</para> 
				<sect2
				 id="DDGRepresentingDatawithTablesandViews-TableOperators-CompilerInferenceMechanisms">
					 
					 <title><indexterm> 
								<primary>Inference Mechanisms</primary> 
						  </indexterm><indexterm> 
								<primary>Type Inference</primary> 
						  </indexterm><indexterm> 
								<primary>Key Inference</primary> 
						  </indexterm><indexterm> 
								<primary>Order Inference</primary> 
						  </indexterm><indexterm> 
								<primary>Reference Inference</primary> 
						  </indexterm><indexterm> 
								<primary>Metadata Inference</primary> 
						  </indexterm><indexterm> 
								<primary>Characteristic Inference</primary> 
						  </indexterm>Inference Mechanisms</title> 
					 <para>One of the primary functions of the compiler is
						  <emphasis>semantic verification</emphasis>, or the process of ensuring that all
						  the expressions and invocations in a given D4 program are being used correctly.
						  For example, the following expression is valid syntactically: 
						  <programlisting>"One" / "Two";</programlisting>However, there is no overload of the division operator that
						  takes two parameters of type 
						  <phrase role="code">String</phrase>. This expression is
						  therefore semantically incorrect. To put it another way, one of the primary
						  reasons for having types in a language is to allow the compiler to verify that
						  a given statement is performing a valid operation.</para> 
					 <para>In order to perform this vital process of semantic
						  verification, the compiler uses several different types of
						  <emphasis>inference</emphasis>: 
						  <itemizedlist> 
								<listitem> 
									 <para>Type Inference</para> 
								</listitem> 
								<listitem> 
									 <para>Key Inference</para> 
								</listitem> 
								<listitem> 
									 <para>Order Inference</para> 
								</listitem> 
								<listitem> 
									 <para>Reference Inference</para> 
								</listitem> 
								<listitem> 
									 <para>Metadata Inference</para> 
								</listitem> 
								<listitem> 
									 <para>Characteristics</para> 
								</listitem> 
						  </itemizedlist></para> 
					 <para>Some of these inference mechanisms such as type inference
						  and characteristics apply general to all expressions and statements of D4.
						  Others, such as key inference and metadata inference, apply specifically to
						  table operators.</para> 
					 <para>Type inference for operators that deal primarily with
						  scalar values is relatively straightforward: the result type of the expression
						  is simply the result type of the resolved overload of the operator. For
						  example: 
						  <programlisting>5 + 5;</programlisting>Because the arguments are both values of type 
						  <phrase role="code">Integer</phrase>, the operator 
						  <phrase role="code">+</phrase> (<phrase
						  role="code">iAddition</phrase>) resolves to the overload signature 
						  <phrase role="code">(Integer, Integer)</phrase>, which has
						  a result type of 
						  <phrase role="code">Integer</phrase>. The result type of
						  the expression is therefore 
						  <phrase role="code">Integer</phrase>, and the type
						  inference is complete.</para> 
					 <para>Characteristic inference will be discussed in more detail
						  in the 
						  <ulink type="link"
							url="DDGModelingProcessLogic.html"><citetitle>Modeling Process
									 Logic</citetitle></ulink> chapter.</para> 
					 <para>For table operators, the process is somewhat more
						  involved than for scalar operators, due to the amount of information that must
						  be inferred about a given expression. Of course, the process involves
						  determining the type of the result, but it also involves determining the keys,
						  orders, references and metadata.</para> 
					 <para>All the table operators infer metadata for the columns
						  involved in the operation, and for the description of the result set itself.
						  These metadata are inferred only if the original metadata tag definition was
						  specified as 
						  <phrase role="code"><emphasis
								role="bold">dynamic</emphasis></phrase>, rather than 
						  <phrase role="code"><emphasis
								role="bold">static</emphasis></phrase>. Static tags are not inferred by the
						  metadata inference engine. Unless explicitly specified, metadata tags are
						  assumed to be dynamic.</para> 
					 <para>The inference mechanisms used by the D4 compiler attempt
						  to infer as much information as possible about the result of a given
						  expression. Consequently, the processes being used are quite complex, and the
						  resulting descriptions can become quite involved. To help the developer
						  determine what the compiler has inferred about a given expression, the D4
						  system library includes the 
						  <ulink type="link"
							url="O-System.Diagnostics.ShowPlan.html"><phrase
								role="code">ShowPlan</phrase></ulink> operator. This operator takes an
						  arbitrary D4 expression as a string argument, and returns a string
						  representation of the compiled and bound execution plan for the given
						  expression, including type descriptions, inferred keys, orders, and references,
						  as well as device binding information. For more information on using this
						  operator, refer to the System Library documentation for the operator.</para> 
				</sect2> 
				<sect2
				 id="DDGRepresentingDatawithTablesandViews-TableOperators-Projection"> 
					 <title>Specifying Columns</title> 
					 <para>D4 provides several operators for specifying the set of
						  columns to be included in the result set. The most general of these is the
						  <emphasis>specify</emphasis> operator (<phrase role="code">{ }</phrase>) which
						  allows columns to be specified by name, or as an expression in terms of the
						  source columns.</para> 
					 <para>The following examples illustrate the use of the specify
						  operator: 
						  <programlisting><emphasis role="bold">select</emphasis> Location { ID, Name };</programlisting> 
						  <programlisting>ID    Name           
----- -------------- 
01001 Location 01001 
01002 Location 01002 
01003 Location 01003 
01004 Location 01001</programlisting></para> 
					 <para>In the above example, the result includes the key of the 
						  <phrase role="code">Location</phrase> table, namely the 
						  <phrase role="code">ID</phrase> column, and so the key of
						  the result is 
						  <phrase role="code">ID</phrase>. The following example
						  illustrates a key-changing projection: 
						  <programlisting><emphasis role="bold">select</emphasis> Location { ZipCode };</programlisting> 
						  <programlisting>ZipCode 
------- 
84058   
84062   
84604</programlisting></para> 
					 <para>The result set does not include the key of the 
						  <phrase role="code">Location</phrase> table, and so the key
						  of the result set is all columns, or 
						  <phrase role="code">ZipCode</phrase>. As a result, the
						  projection eliminates duplicates, and the result set has only 3 rows (the
						  unique set of zipcodes for all locations).</para> 
					 <para>Note that the specify list is allowed to be empty. For
						  example: 
						  <programlisting><emphasis role="bold">select</emphasis> Location { };</programlisting></para> 
					 <para>In this case, not only does the resulting table value
						  have no columns, but the resulting key has no columns as well. If the input to
						  the projection has any rows, the result of this projection is 
						  <phrase role="code">TableDee</phrase> (the table with no
						  columns and one row), otherwise, the result is 
						  <phrase role="code">TableDum</phrase> (the table with no
						  columns and no rows).</para> 
					 <para>The following example illustrates the use of the specify
						  operator to introduce computed columns into a result set: 
						  <programlisting><emphasis role="bold">select</emphasis> InvoiceItem { Invoice_ID, Number, Quantity, Amount, Quantity * Amount LineTotal };</programlisting> 
						  <programlisting>Invoice_ID Number Quantity    Amount LineTotal 
---------- ------ ----------- ------ --------- 
27         1      10.00000000 $2.20  $22.00    
31         1      10.00000000 $2.20  $22.00    
33         1      4.00000000  $2.20  $8.80     
33         2      2.00000000  $4.54  $9.08     </programlisting></para> 
					 <para>Note that the specify operator is shorthand for an
						  equivalent 
						  <phrase role="code"><emphasis
								role="bold">add-over-rename</emphasis></phrase> expression. All keys, orders,
						  and references are inferred as though the longhand expression had been used.
						  The following examples illustrate the equivalent longhand for various specify
						  expressions: 
						  <programlisting><emphasis role="bold">select</emphasis> Contact { ID, Name }
// is equivalent to
<emphasis role="bold">select</emphasis> Contact <emphasis role="bold">over</emphasis> { ID, Name }</programlisting> 
						  <programlisting><emphasis role="bold">select</emphasis> ContactPhone { Contact_ID ID, Phone }
// is equivalent to
<emphasis role="bold">select</emphasis> ContactPhone 
	<emphasis role="bold">over</emphasis> { Contact_ID, Phone } 
	<emphasis role="bold">rename</emphasis> { Contact_ID ID }</programlisting> 
						  <programlisting><emphasis role="bold">select</emphasis> InvoiceItem { Invoice_ID, Number Line_Number, Quantity * Amount Line_Total }
// is equivalent to
<emphasis role="bold">select</emphasis> InvoiceItem 
	<emphasis role="bold">add</emphasis> { Quantity * Amount Line_Total } 
	<emphasis role="bold">over</emphasis> { Invoice_ID, Number, Line_Total } 
	<emphasis role="bold">rename</emphasis> { Number Line_Number }</programlisting></para> 
					 <para>As each of these examples show, a specify clause is
						  always at least a projection. The extension and rename operations are only
						  included when necessary.</para> 
					 <para>For more information on the 
						  <phrase role="code"><emphasis
								role="bold">over</emphasis></phrase> and 
						  <phrase role="code"><emphasis
								role="bold">remove</emphasis></phrase> operators, refer to the 
						  <ulink type="olinka"
							url="D4LGTableExpressions-OverandRemove.html">Over and Remove</ulink>
						  discussion in the D4 Language Guide.</para> 
					 <para>For more information on the specify operator, refer to
						  the 
						  <ulink type="olinka"
							url="D4LGTableExpressions-Specify.html">Specify</ulink> discussion in the D4
						  Language Guide.</para> 
					 <para>For more information on the 
						  <phrase role="code"><emphasis
								role="bold">rename</emphasis></phrase> operator, refer to the 
						  <ulink type="olinka"
							url="D4LGTableExpressions-Rename.html">Rename</ulink> discussion in the D4
						  Language Guide.</para> 
					 <para>For more information on the 
						  <phrase role="code"><emphasis
								role="bold">add</emphasis></phrase> operator, refer to the 
						  <ulink type="olinka"
							url="D4LGTableExpressions-Add.html">Extension</ulink> discussion in the D4
						  Language Guide.</para> 
				</sect2> 
				<sect2
				 id="DDGRepresentingDatawithTablesandViews-TableOperators-Restriction"> 
					 <title>Specifying Rows</title> 
					 <para>D4 also provides several operators for specifying the set
						  of rows to be included in the result set. This section discusses the 
						  <phrase role="code"><emphasis
								role="bold">where</emphasis></phrase> operator (restriction) and the 
						  <phrase role="code"><emphasis
								role="bold">return</emphasis></phrase> operator (quota).</para> 
					 <sect3> 
						  <title>Restriction</title> 
						  <para>The 
								<phrase role="code"><emphasis
									 role="bold">where</emphasis></phrase> operator involves restricting the rows to
								be included in the result. This operator allows a boolean-valued expression in
								terms of the columns of the input called the <emphasis>restriction
								condition</emphasis>. Every row of the input for which the restriction
								condition evaluates to true is included in the result set. This restriction
								condition becomes a constraint in the result set. This fact will become useful
								when we discuss view updatability in the section on Derived Table
								Variables.</para> 
						  <para>The following examples illustrate the use of the 
								<phrase role="code"><emphasis
									 role="bold">where</emphasis></phrase> operator to select a specific set of
								rows: 
								<programlisting><emphasis role="bold">select</emphasis> Location <emphasis role="bold">where</emphasis> ZipCode = '84058';</programlisting> 
								<programlisting>ID    Name           Phone    Street      City State_ID ZipCode 
----- -------------- -------- ----------- ---- -------- ------- 
01001 Location 01001 123-1234 41 N State  Orem UT       84058   
01002 Location 01002 123-1235 878 N 800 E Orem UT       84058   </programlisting></para> 
						  <para>The above example selects all rows with a 
								<phrase role="code">ZipCode</phrase> equal to 
								<phrase role="code">'84058'</phrase>. Note that the
								equality comparison here is taking advantage of the implicit conversion
								available from 
								<phrase role="code">String</phrase> to 
								<phrase role="code">ZipCode</phrase>. Without this
								conversion, we would have to write 
								<phrase role="code"><emphasis
									 role="bold">where</emphasis> ZipCode = Zip('84058')</phrase>, explicitly
								invoking the 
								<phrase role="code">Zip</phrase> selector to promote
								the 
								<phrase role="code">String</phrase> value 
								<phrase role="code">'84058'</phrase> to a 
								<phrase role="code">Zip</phrase> value for
								comparison.</para> 
						  <para>Because the above example does not involve an
								equality comparison on the key, the key of the result is still 
								<phrase role="code">{&nbsp;ID&nbsp;}</phrase>. By
								contrast, the following example does change the key of the result: 
								<programlisting><emphasis role="bold">select</emphasis> Location <emphasis role="bold">where</emphasis> ID = '01001';</programlisting> 
								<programlisting>ID    Name           Phone    Street     City State_ID ZipCode 
----- -------------- -------- ---------- ---- -------- ------- 
01001 Location 01001 123-1234 41 N State Orem UT       84058   </programlisting></para> 
						  <para>In this case, the equality comparison involves a key
								column, and so that column is removed from any key of the result. Because 
								<phrase role="code">ID</phrase> is the only column in
								the key, the resulting key is empty (<phrase role="code">{&nbsp;}</phrase>),
								meaning that the resulting table is guaranteed to have at most one row.</para> 
						  <para>In other words, any time a restriction involves
								setting an entire key equal to some value, the key of the result will have no
								columns. This fact is particularly useful when using the row extractor to
								guarantee that only a single row is involved.</para> 
						  <para>For example, the following query could return
								multiple rows, and will give a warning at compile-time, and an error at
								run-time because the Dataphor Server cannot determine which row should be
								extracted from the table: 
								<programlisting><emphasis role="bold">select</emphasis> Location[].Name</programlisting></para> 
						  <para>To ensure that only one row will ever be involved,
								and to eliminate the warning given by the compiler, the following query can be
								used: 
								<programlisting><emphasis role="bold">select</emphasis> Location['01001'].Name</programlisting></para> 
						  <para>For more information on the 
								<phrase role="code"><emphasis
									 role="bold">where</emphasis></phrase> operator, refer to the 
								<ulink type="olinkb"
								 url="D4LGTableExpressions-Where.html">Restriction</ulink> discussion in the D4
								Language Guide.</para> 
					 </sect3> 
					 <sect3> 
						  <title>Quota Queries</title> 
						  <para>The 
								<phrase role="code"><emphasis
									 role="bold">return</emphasis></phrase> operator is used to limit the
								cardinality of the result set. The optional 
								<phrase role="code"><emphasis
									 role="bold">by</emphasis></phrase> clause specifies the order in which the
								quota operation should be performed.</para> 
						  <para>The following examples illustrate the use of the 
								<phrase role="code"><emphasis
									 role="bold">quota</emphasis></phrase> operator to limit the number of rows
								included in a result set: 
								<programlisting><emphasis role="bold">select</emphasis> Invoice <emphasis role="bold">return</emphasis> 1;</programlisting> 
								<programlisting>ID Location_ID User_ID Date      Status_ID 
-- ----------- ------- --------- --------- 
27 01001       Admin   9/27/2004 NEW       </programlisting></para> 
						  <para>In this example, the 
								<phrase role="code"><emphasis
									 role="bold">by</emphasis></phrase> clause is explicitly specified: 
								<programlisting><emphasis role="bold">select</emphasis> Invoice <emphasis role="bold">return</emphasis> 1 <emphasis role="bold">by</emphasis> { ID };</programlisting> 
								<programlisting>ID Location_ID User_ID Date      Status_ID 
-- ----------- ------- --------- --------- 
27 01001       Admin   9/27/2004 NEW       </programlisting></para> 
						  <para>In the following example, the result set is limited
								to the set of rows with the latest 
								<phrase role="code">Date</phrase>: 
								<programlisting><emphasis role="bold">select</emphasis> Invoice <emphasis role="bold">return</emphasis> 1 <emphasis role="bold">by</emphasis> { Date <emphasis role="bold">desc</emphasis> };</programlisting> 
								<programlisting>ID Location_ID User_ID Date      Status_ID 
-- ----------- ------- --------- --------- 
27 01001       Admin   9/27/2004 NEW       
31 01001       Admin   9/27/2004 NEW       
33 01001       Admin   9/27/2004 NEW       </programlisting></para> 
						  <para>Note that omitting the 
								<phrase role="code"><emphasis
									 role="bold">by</emphasis></phrase> clause and specifying an empty 
								<phrase role="code"><emphasis
									 role="bold">by</emphasis></phrase> clause are <emphasis>not</emphasis>
								equivalent. This is because an empty 
								<phrase role="code"><emphasis
									 role="bold">by</emphasis></phrase> clause specifies that the result set should
								include all rows that have the same value for no columns, or in other words,
								all rows. For example, the following 
								<phrase role="code"><emphasis
									 role="bold">return</emphasis></phrase> operator returns all rows in the 
								<phrase role="code">Invoice</phrase> table: 
								<programlisting><emphasis role="bold">select</emphasis> Invoice <emphasis role="bold">return</emphasis> 1 <emphasis role="bold">by</emphasis> { };</programlisting> 
								<programlisting>ID Location_ID User_ID Date      Status_ID 
-- ----------- ------- --------- --------- 
27 01001       Admin   9/27/2004 NEW       
31 01001       Admin   9/27/2004 NEW       
33 01001       Admin   9/27/2004 NEW       </programlisting></para> 
						  <para>For more information on the 
								<phrase role="code"><emphasis
									 role="bold">return</emphasis></phrase> operator, refer to the 
								<ulink type="olinkb"
								 url="D4LGTableExpressions-Quota.html">Quota</ulink> discussion in the D4
								Language Guide.</para> 
					 </sect3> 
				</sect2> 
				<sect2> 
					 <title>Combining Rows From Multiple Tables</title> 
					 <para>D4 provides several operators for combining table values
						  in different ways. This section discusses the 
						  <phrase role="code"><emphasis
								role="bold">union</emphasis></phrase>, 
						  <phrase role="code"><emphasis
								role="bold">minus</emphasis></phrase>, 
						  <phrase role="code"><emphasis
								role="bold">times</emphasis></phrase>, 
						  <phrase role="code"><emphasis
								role="bold">intersect</emphasis></phrase>, and 
						  <phrase role="code"><emphasis
								role="bold">join</emphasis></phrase> operators.</para> 
					 <sect3> 
						  <title>Union</title> 
						  <para>The <emphasis role="bold"><phrase
								role="code">union</phrase></emphasis> operator combines rows from each input
								table value into one result, with duplicates eliminated. The input table values
								must have the same set of columns in order to apply this operator. Note that
								column matching is done by name, not by ordinal position within the table
								value.</para> 
						  <para>The following example illustrates the use of the 
								<phrase role="code"><emphasis
									 role="bold">union</emphasis></phrase> operator to combine the results of two
								queries: 
								<programlisting><emphasis role="bold">select</emphasis> (SaleOrder { ID }) 
	<emphasis role="bold">union</emphasis> (PurchaseOrder { ID });</programlisting> 
								<programlisting>ID 
-- 
27 
31 
33 </programlisting></para> 
						  <para>For more information on the 
								<phrase role="code"><emphasis
									 role="bold">union</emphasis></phrase> operator, refer to the 
								<ulink type="olinka"
								 url="D4LGTableExpressions-Union.html">Union</ulink> discussion in the D4
								Language Guide.</para> 
					 </sect3> 
					 <sect3> 
						  <title>Difference</title> 
						  <para>The 
								<phrase role="code"><emphasis
									 role="bold">minus</emphasis></phrase>, or difference operator includes all rows
								in the left input that are not present in the right input. Both input table
								values must have the same set of columns in order to apply this operator. Note
								that column matching is done by name, not by ordinal position within the table
								value.</para> 
						  <para>The following example illustrates the use of the 
								<phrase role="code"><emphasis
									 role="bold">minus</emphasis></phrase> operator to compute the set of contacts
								that are not vendors: 
								<programlisting><emphasis role="bold">select</emphasis> (Contact { ID }) 
	<emphasis role="bold">minus</emphasis> (Vendor { ID });</programlisting> 
								<programlisting>ID 
-- 
5  
6  
7  
8  
9  
10 </programlisting></para> 
						  <para>For more information on the 
								<phrase role="code"><emphasis
									 role="bold">minus</emphasis></phrase> operator, refer to the 
								<ulink type="olinka"
								 url="D4LGTableExpressions-Minus.html">Minus</ulink> discussion in the D4
								Language Guide.</para> 
					 </sect3> 
					 <sect3> 
						  <title>Join</title> 
						  <para>The 
								<phrase role="code"><emphasis
									 role="bold">join</emphasis></phrase> operator combines rows from each input
								table value that have matching column values for a specified set of columns.
								Joins may be natural or conditioned, and they may be inner, or outer. Outer
								joins may also be performed using the 
								<phrase role="code"><emphasis
									 role="bold">lookup</emphasis></phrase> keyword, which provides the same
								semantics for retrieval, but different semantics for updates. The 
								<phrase role="code"><emphasis
									 role="bold">lookup</emphasis></phrase> operator will be discussed in the
								updatability section.</para> 
						  <para>Natural joins rely on common column names between the
								input table values to perform the match. The union of the columns of both
								inputs become the columns of the output, with metadata merged the same as for
								columns in the 
								<phrase role="code"><emphasis
									 role="bold">union</emphasis></phrase> operator. This gives rise to three
								possibilities for natural joins: 
								<itemizedlist> 
									 <listitem> 
										  <para>No common columns.</para> 
										  <para>If the inputs contain no commonly named
												columns, the operation is a Cartesian product. The D4 language provides the
												keyword 
												<phrase role="code"><emphasis
													 role="bold">times</emphasis></phrase> to force this type of operation. If the 
												<phrase role="code"><emphasis
													 role="bold">times</emphasis></phrase> keyword is used, the inputs are not
												allowed to have common column names. If a usage of the standard 
												<phrase role="code"><emphasis
													 role="bold">join</emphasis></phrase> keyword results in a Cartesian product,
												the compiler will issue a warning.</para> 
									 </listitem> 
									 <listitem> 
										  <para>Some common columns.</para> 
										  <para>If the inputs contain some commonly named
												columns, and some columns with different names, the operation is a standard
												join. D4 provides the 
												<phrase role="code"><emphasis
													 role="bold">join</emphasis></phrase> keyword for this purpose. The join
												condition is constructed as a set of equality comparisons between values in the
												columns from the left and right input in order to satisfy the join
												condition.</para> 
									 </listitem> 
									 <listitem> 
										  <para>All common columns.</para> 
										  <para>If the inputs contain only commonly named
												columns (i.e. the left and right input table values are of the same table type)
												then the operation is an intersection. The D4 language provides the keyword 
												<phrase role="code"><emphasis
													 role="bold">intersect</emphasis></phrase> for this purpose. If the 
												<phrase role="code"><emphasis
													 role="bold">intersect</emphasis></phrase> keyword is used, the inputs are not
												allowed to have differing column names.</para> 
									 </listitem> 
								</itemizedlist></para> 
						  <para>Conditioned joins require each input table to have no
								commonly named columns, and allow the join condition to be specified as part of
								the operation using the 
								<phrase role="code"><emphasis
									 role="bold">by</emphasis></phrase> clause. The join condition in this case is
								required to consist only of equality comparisons among columns in opposite
								input tables.</para> 
						  <para>While inner joins include output rows only for rows
								where a match occurs in both inputs, outer joins allow output rows to be
								included where a match did not occur in a given input. Left outer joins allow
								all rows from the left input to be included, while right outer joins allow all
								rows from the right input to be included, regardless of whether a matching row
								in the opposite input table value was found.</para> 
						  <para>Outer joins also allow an optional 
								<phrase role="code"><emphasis
									 role="bold">rowexists</emphasis></phrase> column to be included in the result
								that is true if a row in the outer table was found, and false otherwise.</para>
						  
						  <para>The following examples illustrate the use of the
								various 
								<phrase role="code"><emphasis
									 role="bold">join</emphasis></phrase> operators to combine result sets from
								different queries based on the relationship between columns in the
								results.</para> 
						  <para>The following example depicts a natural one-to-one
								join: 
								<programlisting><emphasis role="bold">select</emphasis> Invoice <emphasis role="bold">join</emphasis> SaleOrder;</programlisting> 
								<programlisting>ID Location_ID User_ID Date      Status_ID Customer_ID 
-- ----------- ------- --------- --------- ----------- 
27 01001       Admin   9/27/2004 NEW       8           
31 01001       Admin   9/27/2004 NEW       7           
33 01001       Admin   9/27/2004 NEW       8           </programlisting>The only common column name in the above example is 
								<phrase role="code">ID</phrase>, which is a key of both
								the left and right inputs. This means that the join is one-to-one, and the key
								of the output is 
								<phrase role="code">{&nbsp;ID&nbsp;}</phrase>.</para> 
						  <para>The following example depicts a conditioned
								one-to-one join: 
								<programlisting><emphasis role="bold">select</emphasis> (Invoice <emphasis role="bold">rename</emphasis> I) 
	<emphasis role="bold">join</emphasis> (SaleOrder <emphasis role="bold">rename</emphasis> S)
		<emphasis role="bold">by</emphasis> I.ID = S.ID
	{ I.ID, I.Status_ID, S.ID, S.Customer_ID };</programlisting> 
								<programlisting>I.ID I.Status_ID S.ID S.Customer_ID 
---- ----------- ---- ------------- 
27   NEW         27   8             
31   NEW         31   7             
33   NEW         33   8             </programlisting>In the above example, the join condition is specified by the
								by clause. Because the join columns (<phrase
								role="code">{&nbsp;I.ID&nbsp;}</phrase> and 
								<phrase role="code">{&nbsp;S.ID&nbsp;}</phrase>) form
								keys in both the left and right inputs, the join is again one-to-one, but the
								keys of both inputs are present in the result.</para> 
						  <para>The following example depicts a conditioned left
								(outer) one-to-one join: 
								<programlisting><emphasis role="bold">select</emphasis> (Invoice <emphasis role="bold">rename</emphasis> I)
	<emphasis role="bold">left join</emphasis> (SaleOrder <emphasis role="bold">rename</emphasis> S)
		<emphasis role="bold">by</emphasis> I.ID = S.ID
		<emphasis role="bold">include rowexists</emphasis>
	{ I.ID, I.Status_ID, rowexists, S.ID, S.Customer_ID };</programlisting> 
								<programlisting>I.ID I.Status_ID rowexists S.ID       S.Customer_ID 
---- ----------- --------- ---------- ------------- 
1    COM         True      1          7             
2    COM         False     &lt;No Value&gt; &lt;No Value&gt;    
7    COM         False     &lt;No Value&gt; &lt;No Value&gt;    </programlisting>As with the previous example, the join condition is specific
								using the by clause, and the join is again one-to-one. In this case, however,
								the keys of both inputs are present, but the key of the right input is inferred
								as a <emphasis>sparse</emphasis> key, meaning that multiple rows may have no
								value for the columns of the key.</para> 
						  <para>The following example depicts a natural one-to-many
								join: 
								<programlisting><emphasis role="bold">select</emphasis> Contact { ID, Name } 
	<emphasis role="bold">join</emphasis> 
	(
		ContactAddress 
		{ 
				Contact_ID ID, 
				Number, 
				City, 
				State_ID, 
				ZipCode 
			}
		);</programlisting> 
								<programlisting>ID Name                  Number City           State_ID ZipCode 
-- --------------------- ------ -------------- -------- ------- 
1  KC Foods              1      Chesterfield   MA       01012   
2  Hijinks Emporium      1      Albuquerque    NM       87111   
3  Ralph's Wholesale     1      Denver         CO       80202   
4  Thriftways            1      New Orleans    LA       70112   
5  Quickie Mart          1      Orem           UT       84057   
6  Super Store           1      American Fork  UT       84003   
7  Emergency Essentials  1      Clearfield     UT       84017   
8  Food Masters          1      Salt Lake City UT       84054   
9  Unequalled Anywhere   1      Salt Lake City UT       84116   
10 Universe of Discourse 1      Pleasant Grove UT       84062   
10 Universe of Discourse 2      Orem           UT       84057  </programlisting>In this example, the result will in general have several rows
								for each row of the left input. The key for the left input is 
								<phrase role="code">{&nbsp;ID&nbsp;}</phrase>, while
								the key for the right input is 
								<phrase
								role="code">{&nbsp;ID,&nbsp;Number&nbsp;}</phrase> (after the rename). The key
								of the result is therefore 
								<phrase
								role="code">{&nbsp;ID,&nbsp;Number&nbsp;}</phrase>.</para> 
						  <para>The following example depicts a natural many-to-one
								join: 
								<programlisting><emphasis role="bold">select</emphasis> ContactPhone { Contact_ID, PhoneType_ID, Phone } 
	<emphasis role="bold">join</emphasis> (PhoneType { ID PhoneType_ID, Description });</programlisting> 
								<programlisting>Contact_ID PhoneType_ID Phone    Description  
---------- ------------ -------- ------------ 
1          MOB          123-1234 Mobile Phone 
2          FAX          555-1212 Fax Machine  
3          MOB          877-9908 Mobile Phone 
4          FAX          813-9988 Fax Machine  
5          WOR          319-9989 Work Phone   
6          WOR          126-6654 Work Phone   
7          FAX          334-6574 Fax Machine  
8          MOB          877-9988 Mobile Phone 
9          WOR          133-0098 Work Phone   
10         FAX          123-0122 Fax Machine  </programlisting>The result set in this case contains one row for each row in 
								<phrase role="code">ContactPhone</phrase>, with the
								data from the matching 
								<phrase role="code">PhoneType</phrase> row repeated.
								The key for the left input is 
								<phrase
								role="code">{&nbsp;Contact_ID,&nbsp;PhoneType_ID&nbsp;}</phrase>, while the key
								for the right input is 
								<phrase role="code">{&nbsp;PhoneType_ID&nbsp;}</phrase>
								(after the rename). The key of the result is therefore 
								<phrase
								role="code">{&nbsp;Contact_ID,&nbsp;PhoneType_ID&nbsp;}</phrase>.</para> 
						  <para>The following example depicts a many-to-many join: 
								<programlisting><emphasis role="bold">select</emphasis> Location { ID, Name, ZipCode } 
	<emphasis role="bold">join</emphasis> (ContactAddress { Contact_ID, Number, ZipCode });</programlisting> 
								<programlisting>ID    Name           ZipCode Contact_ID Number 
----- -------------- ------- ---------- ------ 
01004 Location 01004 84062   10         1      </programlisting>This examples shows 
								<phrase role="code">Location</phrase> rows that have
								the same 
								<phrase role="code">ZipCode</phrase> as 
								<phrase role="code">ContactAddress</phrase> rows.
								Because the join column (<phrase role="code">ZipCode</phrase>) does not form a
								superkey of either input, the join is many-to-many. The key is therefore the
								Cartesian product of the keys of the inputs, or 
								<phrase
								role="code">{&nbsp;ID,&nbsp;Contact_ID,&nbsp;Number&nbsp;}</phrase>.</para> 
						  <para>For more information on the various 
								<phrase role="code"><emphasis
									 role="bold">join</emphasis></phrase> operators, refer to the 
								<ulink type="olinkb"
								url="D4LGTableExpressions-Join.html">Join</ulink> discussion in the D4 Language
								Guide.</para> 
						  <para>For more information on outer joins specifically,
								refer to the 
								<ulink type="olinkb"
								url="D4LGTableExpressions-OuterJoin.html">Outer Join</ulink> discussion in the
								D4 Language Guide.</para> 
					 </sect3> 
				</sect2> 
				<sect2
				id="DDGRepresentingDatawithTablesandViews-TableOperators-Aggregation"> 
					 <title>Computing Aggregates</title> 
					 <para>Aggregation involves adding a set of columns to the
						  result, where the value for each of those columns is provided by computing an
						  aggregate value from the rows of the input. Optionally, a grouping for the rows
						  of the input may be specified, resulting in an output row for each group in the
						  input rows, with the aggregate column values computed for the set of input rows
						  within the group. D4 provides the 
						  <phrase role="code"><emphasis
								role="bold">group</emphasis></phrase> operator for this purpose.</para> 
					 <para>If a by clause is specified, every column in the by
						  clause is a column in the output, with keys, orders, and references inferred
						  the same as for projection of the input over the columns of the by clause. If a
						  by clause is not specified, the result will have one row and an empty key. All
						  columns in the add clause are included in the output.</para> 
					 <para>The following example illustrates the use of the 
						  <phrase role="code"><emphasis
								role="bold">group</emphasis></phrase> operator to introduce aggregated columns
						  into a result set: 
						  <programlisting><emphasis role="bold">select</emphasis> SaleOrderItem 
	<emphasis role="bold">group by</emphasis> { Invoice_ID } 
		<emphasis role="bold">add</emphasis> { Sum(LineTotal) InvoiceTotal };</programlisting> 
						  <programlisting>Invoice_ID InvoiceTotal 
---------- ------------ 
27         $22.00       
31         $22.00       
33         $17.88       </programlisting></para> 
					 <para>For more information on the 
						  <phrase role="code"><emphasis
								role="bold">group</emphasis></phrase> operator, refer to the 
						  <ulink type="link"
						  url="D4LGTableExpressions-Aggregate.html">Aggregate</ulink> discussion in the
						  D4 Language Guide.</para> 
					 <para>The following aggregate operators are defined in the
						  System library: 
						  <itemizedlist> 
								<listitem> 
									 <para><phrase role="code"><ulink type="olinkb"
												url="O-System.Count.html">Count</ulink></phrase></para> 
								</listitem> 
								<listitem> 
									 <para><phrase role="code"><ulink type="olinkb"
												url="O-System.Sum.html">Sum</ulink></phrase></para> 
								</listitem> 
								<listitem> 
									 <para><phrase role="code"><ulink type="olinkb"
												url="O-System.Min.html">Min</ulink></phrase></para> 
								</listitem> 
								<listitem> 
									 <para><phrase role="code"><ulink type="olinkb"
												url="O-System.Max.html">Max</ulink></phrase></para> 
								</listitem> 
								<listitem> 
									 <para><phrase role="code"><ulink type="olinkb"
												url="O-System.Avg.html">Avg</ulink></phrase></para> 
								</listitem> 
								<listitem> 
									 <para><phrase role="code"><ulink type="olinkb"
												url="O-System.All.html">All</ulink></phrase></para> 
								</listitem> 
								<listitem> 
									 <para><phrase role="code"><ulink type="olinkb"
												url="O-System.Any.html">Any</ulink></phrase></para> 
								</listitem> 
						  </itemizedlist></para> 
					 <para>In addition D4 allows user-defined aggregate operators to
						  be created using the 
						  <phrase role="code"><emphasis role="bold">create aggregate
								operator</emphasis></phrase> statement. For more information on creating
						  aggregate operators, refer to 
						  <ulink type="olinkb"
						  url="D4LGCatalogElements-Operators-AggregateOperators.html">Aggregate
								Operators</ulink> in the D4 Language Guide.</para> 
				</sect2> 
				<sect2
				id="DDGRepresentingDatawithTablesandViews-TableOperators-Adorn"> 
					 <title>Specifying Metadata</title> 
					 <para>The 
						  <phrase role="code"><emphasis
								role="bold">adorn</emphasis></phrase> operator allows metadata and structural
						  information to be introduced within a given expression. Column metadata,
						  defaults, and constraints can be introduced, as well as table-level metadata,
						  keys 
						  <footnote> 
								<para>Note that keys introduced by the adorn operation
									 are <emphasis>not</emphasis> enforced by the Dataphor Server. They are allowed
									 in the adorn operator to allow the developer to specify additional keys that
									 may exist within a given table value, but are not apparent to the Dataphor
									 Server. This feature should be used with care, as it can lead to runtime errors
									 if used incorrectly.</para> 
						  </footnote>, orders, and constraints. If constraints are
						  introduced, a restriction is used to remove potentially violating rows from the
						  result. The adorn operation can also affect metadata on inferred keys, orders,
						  and references of the expression, as well as remove inferred keys, orders, and
						  references.</para> 
					 <para>The adorn operator is typically used when constructing
						  views for use in the Frontend. As such, discussion of this operator will be
						  deferred to the next part.</para> 
					 <para>For more information on the 
						  <phrase role="code"><emphasis
								role="bold">adorn</emphasis></phrase> operator, refer to the 
						  <ulink type="olinka"
						  url="D4LGTableExpressions-Adorn.html">Adorn</ulink> discussion in the D4
						  Language Guide.</para> 
				</sect2> 
				<sect2
				id="DDGRepresentingDatawithTablesandViews-TableOperators-Extraction"> 
					 <title>Extracting Rows and Columns</title> 
					 <para>D4 provides two extraction operators for accessing
						  individual values within table and row values: the table-indexer (or row
						  extractor), and the column extractor.</para> 
					 <para>The table-indexer expression allows a single row to be
						  extracted from a table value. The syntax of the expression is similar to the
						  multi-term indexer expression common in languages such as Pascal (e.g. 
						  <phrase role="code">LArray[2, 4]</phrase>), with the
						  addition of an optional <emphasis>by clause</emphasis> to allow the columns to
						  be used in the indexer to be explicitly specified.</para> 
					 <para>The column extractor allows access to the columns of a
						  row value. The column extractor is simply the dot operator invoked on a row
						  valued expression. For example, the following expression retrieves the value of
						  the 
						  <phrase role="code">Name</phrase> column of a row in the 
						  <phrase role="code">Location</phrase> table: 
						  <programlisting><emphasis role="bold">select</emphasis> Location["01001"].Name;</programlisting></para> 
					 <para>Note that although this example shows combined usage of
						  the table-indexer and column extractor expressions, both can be used
						  independently. For example: 
						  <programlisting><emphasis role="bold">begin</emphasis>
	<emphasis role="bold">var</emphasis> LRow := Location["01001"];
	<emphasis role="bold">var</emphasis> LName := LRow.Name;
<emphasis role="bold">end</emphasis>;</programlisting></para> 
					 <para>For more information on the table-indexer, refer to the 
						  <ulink type="olinkb"
						  url="D4LGLanguageElements-Expressions-IndexerExpression.html">Indexer
								Expression</ulink> discussion in the D4 Language Guide.</para> 
					 <para>For more information on the column extractor, refer to
						  the 
						  <ulink type="olinkb"
						  url="D4LGLanguageElements-Expressions-QualifierExpression.html">Qualifier
								Expression</ulink> discussion in the D4 Language Guide.</para> 
				</sect2> 
		  </sect1> 
		  <sect1
		  id="DDGRepresentingDatawithTablesandViews-DerivedTableVariables"> 
				<title><indexterm> 
						  <primary>Views</primary> 
						  <secondary>Representing Data With</secondary> 
					 </indexterm><indexterm> 
						  <primary>Representing Data with Tables and Views</primary> 
						  <secondary>Views</secondary> 
					 </indexterm>Views</title> 
				<para>In addition to base table variables, the D4 language allows
					 for the definition of derived table variables or <emphasis>views</emphasis>.
					 Views are table variables whose structure and content is specified by some
					 table-valued expression. The expression itself is allowed, but not required, to
					 reference other table variables, base and derived within the database.</para> 
				<para>View definitions can also include additional logical
					 components such as keys 
					 <footnote> 
						  <para>Note that, as with the adorn operator, keys
								introduced in view definitions are not enforced by the Dataphor Server, and
								should only be specified when absolutely necessary.</para> 
					 </footnote>, orders, constraints, and references. Constraint
					 specifications in view definitions become part of the restriction condition of
					 the view, effectively limiting the rows visible within the view to those
					 satisfying the constraint specifications.</para> 
				<para>Views can be involved in reference definitions, but note that
					 the reference constraint will be enforced via a database-wide integrity
					 constraint if the source or target table variable is a view. Because of this,
					 references that involve views are not enforced by default. This behavior can be
					 changed using the 
					 <phrase role="code">DAE.Enforced</phrase> tag, but the
					 catalog-level expression will be used to enforce the constraint. Consider
					 rewriting the reference constraint enforcement using transition constraints if
					 this is deemed to be a problem.</para> 
				<para>View definitions can also include metadata specifications
					 that are added to the table variable in addition to the metadata inferred by
					 the type inference engine of the compiler.</para> 
				<para><indexterm> 
						  <primary>View Updatability</primary> 
						  <seealso>Update Propagation</seealso> 
					 </indexterm>Once defined, view references can be used anywhere
					 that a table-valued expression can appear. Specifically, they can appear within
					 any select statement, and as the target of any data modification statement.
					 This feature is commonly referred to as <emphasis>view updatability</emphasis>.
					 In fact, D4 takes this concept even further, and allows arbitrary table-valued
					 expressions to appear as the target of any data modification statement. It is
					 important to note that the following discussion about the updatability rules
					 for each operator actually applies to all table-valued expressions, not just
					 views.</para> 
				<para><indexterm> 
						  <primary>Propagation</primary> 
						  <see>Update Propagation</see> 
					 </indexterm><indexterm> 
						  <primary>Update Propagation</primary> 
					 </indexterm>The Dataphor Server supports full view updatability
					 (table-valued expression updatability, loosely speaking) by completely
					 specifying how each operator propagates a given data modification to the
					 inputs. In this way, every data modification is translated into equivalent data
					 modifications against the table variables involved in the expression.</para> 
				<para>This is not to say that every data modification against a
					 view or table-valued expression will succeed. Each data modification statement
					 is subject not only to the constraints defined within the global database, but
					 to the specific constraints introduced by the various operations involved in
					 the defining expression. Any data modification that would cause a violation of
					 any of these constraints is rejected 
					 <footnote> 
						  <para>More precisely, if the constraint being violated is
								an immediate constraint, the data modification is rejected. Otherwise, the
								transaction containing the modification that caused the constraint violation is
								not allowed to be committed. An error occurs when the transaction is being
								committed, rather than when the data modification statement is executed.</para>
						  
					 </footnote>.</para> 
				<para>In addition to the system-defined behavior for propagating a
					 given data modification, the Dataphor Server allows for complete control over
					 the propagation rules using <emphasis>language modifiers</emphasis>. Language
					 modifiers are a general purpose construct available within expressions and
					 statements of the D4 language that can be used to pass information directly to
					 the compiler. These modifiers can be used to control the propagation behavior
					 of each operation within a given expression. The available language modifiers
					 are discussed in more detail in the D4 Language Guide, but the commonly
					 available modifiers that directly relate to data modification propagation are
					 listed below: 
					 <itemizedlist> 
						  <indexterm> 
								<primary>Propagation Modifiers</primary> 
						  </indexterm> 
						  <indexterm> 
								<primary>Language Modifiers</primary> 
								<secondary>Propagation Modifiers</secondary> 
								<see>Propagation Modifiers</see> 
						  </indexterm> 
						  <indexterm> 
								<primary>Modifiers</primary> 
								<see>Language Modifiers</see> 
						  </indexterm> 
						  <listitem> 
								<para><phrase
									 role="code">PropagateInsert</phrase></para> 
								<para>Indicates whether or not insert propagation
									 should occur, and if it does, how conflicts with existing rows should be
									 handled. 
									 <phrase role="code">Ensure</phrase> indicates that
									 an insert of an existing row should be propagated as an update. 
									 <phrase role="code">Ignore</phrase> indicates that
									 an insert of an existing row should not be propagated.</para> 
						  </listitem> 
						  <listitem> 
								<para><phrase
									 role="code">PropagateUpdate</phrase></para> 
								<para>Indicates whether or not update propagation
									 should occur.</para> 
						  </listitem> 
						  <listitem> 
								<para><phrase
									 role="code">PropagateDelete</phrase></para> 
								<para>Indicates whether or not delete propagation
									 should occur.</para> 
						  </listitem> 
						  <listitem> 
								<para><phrase
									 role="code">PropagateDefault</phrase></para> 
								<para>Indicates whether or not default propagation
									 should occur.</para> 
						  </listitem> 
						  <listitem> 
								<para><phrase
									 role="code">PropagateValidate</phrase></para> 
								<para>Indicates whether or not validate propagation
									 should occur.</para> 
						  </listitem> 
						  <listitem> 
								<para><phrase
									 role="code">PropagateChange</phrase></para> 
								<para>Indicates whether or not change propagation
									 should occur.</para> 
						  </listitem> 
					 </itemizedlist></para> 
				<para>Possible values for these modifiers are 
					 <phrase role="code">True</phrase> and 
					 <phrase role="code">False</phrase>. The 
					 <phrase role="code">PropagateInsert</phrase> modifier also
					 recognizes 
					 <phrase role="code">Ensure</phrase> and 
					 <phrase role="code">Ignore</phrase>. The default value for each
					 modifier is 
					 <phrase role="code">True</phrase>.</para> 
				<para>Note that for binary table operators, the modifier may be
					 qualified with 
					 <phrase role="code">Left</phrase> or 
					 <phrase role="code">Right</phrase> to indicate the input to
					 which the modifier should be applied.</para> 
				<para>The Dataphor Server also supports completely redefining a
					 given data modification statement using "instead-of" event handlers. These
					 event handlers can completely take the place of a given data modification.
					 These, and other types of event handlers will be discussed in the 
					 <ulink type="link"
					 url="DDGEnforcingStimulus-ResponseRules.html"><citetitle>Enforcing
								Stimulus-Response Rules</citetitle></ulink> chapter.</para> 
				<para>The following sections discuss the default update propagation
					 rules for each table-valued operator of the D4 language. Again, examples are
					 taken from the data model for the Shipping Application. The creation scripts
					 for this data model can be found in the schema documents of the 
					 <phrase role="code">Sample.Shipping</phrase> library.</para> 
				<sect2
				id="DDGRepresentingDatawithTablesandViews-DerivedTableVariables-Projection"> 
					 <title><indexterm> 
								<primary>View Updatability</primary> 
								<secondary>Projection</secondary> 
						  </indexterm>Projection</title> 
					 <para>Data modification through a projection operation is
						  accomplished by performing the modification directly against the input. Note
						  that in the case of an insert, if the input does not specify a default for any
						  required columns that were removed by the projection operation, the insert
						  modification will be rejected.</para> 
					 <para>Note that the 
						  <phrase role="code"><emphasis
								role="bold">adorn</emphasis></phrase> operator can be used to introduce
						  defaults for a given expression prior to a projection operation. For example: 
						  <programlisting><emphasis role="bold">select</emphasis> Invoice
	<emphasis role="bold">adorn</emphasis> { Status_ID { <emphasis role="bold">default</emphasis> 'NEW' } }
	<emphasis role="bold">remove</emphasis> { Status_ID };</programlisting></para> 
				</sect2> 
				<sect2
				id="DDGRepresentingDatawithTablesandViews-DerivedTableVariables-Restriction"> 
					 <title><indexterm> 
								<primary>View Updatability</primary> 
								<secondary>Restriction</secondary> 
						  </indexterm>Restriction</title> 
					 <para>Data modification through a restriction operation is
						  accomplished by performing the modification directly against the input. Note
						  that in the case of an insert or update, if the restriction predicate is
						  enforced and the new row does not satisfy the restriction condition, the
						  modification will be rejected.</para> 
					 <para>In addition to the modifiers available for all binary
						  table operators, the 
						  <phrase role="code"><emphasis
								role="bold">where</emphasis></phrase> operator also defines the following
						  modifiers: 
						  <itemizedlist> 
								<indexterm> 
									 <primary>Propagation Modifiers</primary> 
									 <secondary>Restriction</secondary> 
								</indexterm> 
								<listitem> 
									 <para><phrase
										  role="code">EnforcePredicate</phrase></para> 
									 <para>Indicates whether the predicate of the
										  restriction should be enforced for data modifications. Possible values for this
										  modifier are 
										  <phrase role="code">True</phrase> and 
										  <phrase role="code">False</phrase>.</para> 
								</listitem> 
						  </itemizedlist></para> 
					 <para>The default value for the 
						  <phrase role="code">EnforcePredicate</phrase> modifier is
						  false, meaning that by default, data modifications through a restriction are
						  not required to satisfy the restriction condition 
						  <footnote> 
								<para>We note that this behavior is subject to
									 change.</para> 
						  </footnote>.</para> 
				</sect2> 
				<sect2
				id="DDGRepresentingDatawithTablesandViews-DerivedTableVariables-Extension"> 
					 <title><indexterm> 
								<primary>View Updatability</primary> 
								<secondary>Extension</secondary> 
						  </indexterm>Extension</title> 
					 <para>Data modification through an extension operation is
						  accomplished by performing the modification against the input with the extended
						  columns removed.</para> 
				</sect2> 
				<sect2
				id="DDGRepresentingDatawithTablesandViews-DerivedTableVariables-Aggregation"> 
					 <title><indexterm> 
								<primary>View Updatability</primary> 
								<secondary>Aggregation</secondary> 
						  </indexterm>Aggregation</title> 
					 <para>Data modification through an aggregation operation is
						  accomplished by performing the modification against a projection of the
						  aggregation source over the columns in the by clause, with the aggregate
						  columns of the modification row removed. Note that if the aggregation does not
						  specify a by clause, the modification is effectively an attempt to update a
						  table literal, and will be rejected.</para> 
				</sect2> 
				<sect2
				id="DDGRepresentingDatawithTablesandViews-DerivedTableVariables-Rename"> 
					 <title><indexterm> 
								<primary>View Updatability</primary> 
								<secondary>Rename</secondary> 
						  </indexterm>Rename</title> 
					 <para>Data modification through a rename operation is
						  accomplished by performing the modification directly against the input with the
						  affects of the rename operation reversed.</para> 
				</sect2> 
				<sect2
				id="DDGRepresentingDatawithTablesandViews-DerivedTableVariables-Redefine"> 
					 <title><indexterm> 
								<primary>View Updatability</primary> 
								<secondary>Redefine</secondary> 
						  </indexterm>Redefine</title> 
					 <para>Data modification through a redefine operation is
						  accomplished by performing the modification as though the operation were
						  expressed longhand.</para> 
				</sect2> 
				<sect2
				id="DDGRepresentingDatawithTablesandViews-DerivedTableVariables-Specify"> 
					 <title><indexterm> 
								<primary>View Updatability</primary> 
								<secondary>Specify</secondary> 
						  </indexterm>Specify</title> 
					 <para>Data modification through a specify operation is
						  accomplished by performing the modification as though the operation were
						  expressed longhand.</para> 
				</sect2> 
				<sect2
				id="DDGRepresentingDatawithTablesandViews-DerivedTableVariables-Adorn"> 
					 <title><indexterm> 
								<primary>View Updatability</primary> 
								<secondary>Adorn</secondary> 
						  </indexterm>Adorn</title> 
					 <para>Data modification through an adorn operation is
						  accomplished by performing the modification directly against the input, with
						  the added stipulation that if the adorn operation includes any constraints, the
						  new row must satisfy the constraints.</para> 
				</sect2> 
				<sect2
				id="DDGRepresentingDatawithTablesandViews-DerivedTableVariables-Quota"> 
					 <title><indexterm> 
								<primary>View Updatability</primary> 
								<secondary>Quota</secondary> 
						  </indexterm>Quota</title> 
					 <para>Data modification through a quota operation is
						  accomplished by performing the modification directly against the input.</para> 
				</sect2> 
				<sect2
				id="DDGRepresentingDatawithTablesandViews-DerivedTableVariables-Explode"> 
					 <title><indexterm> 
								<primary>View Updatability</primary> 
								<secondary>Explode</secondary> 
						  </indexterm>Explode</title> 
					 <para>Data modification through an explode operation is
						  accomplished by performing the modification directly against the input, with
						  any columns introduced by the expression removed.</para> 
				</sect2> 
				<sect2
				id="DDGRepresentingDatawithTablesandViews-DerivedTableVariables-Union"> 
					 <title><indexterm> 
								<primary>View Updatability</primary> 
								<secondary>Union</secondary> 
						  </indexterm>Union</title> 
					 <para>Data modification through a union operation is
						  accomplished by attempting the modification in the left input and the right
						  input. Only if the modification is rejected in both left and right inputs is
						  the modification rejected. Note that only constraint violation and other user
						  level severity errors are considered a rejection of the modification for this
						  purpose. For example, an environment severity error such as a concurrency
						  violation would not be considered a data modification rejection, but rather a
						  general failure of the modification process.</para> 
					 <para>In addition to the modifiers available for all binary
						  table operators, the 
						  <phrase role="code"><emphasis
								role="bold">union</emphasis></phrase> operator also defines the following
						  modifier: 
						  <itemizedlist> 
								<indexterm> 
									 <primary>Propagation Modifiers</primary> 
									 <secondary>Union</secondary> 
								</indexterm> 
								<listitem> 
									 <para><phrase
										  role="code">EnforcePredicate</phrase></para> 
									 <para>Indicates whether the predicate of the
										  resulting view should be enforced for data modifications. Possible values for
										  this modifier are 
										  <phrase role="code">True</phrase> and 
										  <phrase role="code">False</phrase>.</para> 
								</listitem> 
						  </itemizedlist></para> 
					 <para>The default value for the 
						  <phrase role="code">EnforcePredicate</phrase> modifier for
						  the 
						  <phrase role="code"><emphasis
								role="bold">union</emphasis></phrase> operator is 
						  <phrase role="code">True</phrase>. If the predicate for the
						  union is not enforced, the modification will simply be propagated to both the
						  left and right inputs.</para> 
				</sect2> 
				<sect2
				id="DDGRepresentingDatawithTablesandViews-DerivedTableVariables-Difference"> 
					 <title><indexterm> 
								<primary>View Updatability</primary> 
								<secondary>Difference</secondary> 
						  </indexterm>Difference</title> 
					 <para>Data modification through a difference operation is
						  accomplished by attempting the modification in the right input. If the
						  modification is accepted in the right input, it is undone, and the data
						  modification is rejected. Otherwise, the modification is propagated to the left
						  input.</para> 
					 <para>In addition to the modifiers available for all binary
						  table operators, the 
						  <phrase role="code"><emphasis
								role="bold">minus</emphasis></phrase> operator also defines the following
						  modifier: 
						  <itemizedlist> 
								<indexterm> 
									 <primary>Propagation Modifiers</primary> 
									 <secondary>Difference</secondary> 
								</indexterm> 
								<listitem> 
									 <para><phrase
										  role="code">EnforcePredicate</phrase></para> 
									 <para>Indicates whether the predicate of the
										  resulting view should be enforced for data modifications. Possible values for
										  this modifier are 
										  <phrase role="code">True</phrase> and 
										  <phrase role="code">False</phrase>.</para> 
								</listitem> 
						  </itemizedlist></para> 
					 <para>The default value for the 
						  <phrase role="code">EnforcePredicate</phrase> modifier for
						  the 
						  <phrase role="code"><emphasis
								role="bold">minus</emphasis></phrase> operator is 
						  <phrase role="code">True</phrase>. If the predicate for the
						  difference is not enforced, the modification will simply be propagated to the
						  left input.</para> 
				</sect2> 
				<sect2
				id="DDGRepresentingDatawithTablesandViews-DerivedTableVariables-Join"> 
					 <title><indexterm> 
								<primary>View Updatability</primary> 
								<secondary>Join</secondary> 
						  </indexterm>Join</title> 
					 <para>Data modification through a 
						  <phrase role="code"><emphasis
								role="bold">join</emphasis></phrase> operation is accomplished by performing
						  the modification against left input with the columns of the right input
						  removed, and performing the modification against the right input with the
						  columns of the left input removed. The 
						  <phrase role="code"><emphasis
								role="bold">lookup</emphasis></phrase> operator provides a simply way to
						  control update propagation through the operator. Left lookups do not propagate
						  modifications to the right side, and right lookups do not propagate
						  modifications to the left side.</para> 
					 <para>Modification through outer joins is also affected by the 
						  <phrase role="code"><emphasis
								role="bold">rowexists</emphasis></phrase> column. The value of this column in
						  the row being modified effectively governs the existence of the row in the
						  outer input. Setting the 
						  <phrase role="code"><emphasis
								role="bold">rowexists</emphasis></phrase> column to true will insert a row in
						  the outer input, and clearing it will delete a row from the outer input. Note
						  that this applies only to left and right <emphasis>joins</emphasis>, as the
						  outer lookup operators will not propagate modifications to the outer
						  table.</para> 
					 <para>In addition to the modifiers available for all binary
						  table operators, the 
						  <phrase role="code"><emphasis
								role="bold">join</emphasis></phrase> operators also define the following
						  modifiers: 
						  <itemizedlist> 
								<indexterm> 
									 <primary>Propagation Modifiers</primary> 
									 <secondary>Join</secondary> 
								</indexterm> 
								<listitem> 
									 <para><phrase
										  role="code">EnforcePredicate</phrase></para> 
									 <para>Indicates whether the join predicate of the
										  resulting view should be enforced for data modifications. Possible values for
										  this modifier are 
										  <phrase role="code">True</phrase> and 
										  <phrase role="code">False</phrase>. The default
										  value for this modifier for the 
										  <phrase role="code"><emphasis
												role="bold">join</emphasis></phrase> operators is 
										  <phrase role="code">False</phrase>.</para> 
								</listitem> 
								<listitem> 
									 <para><phrase role="code">RetrieveLeft</phrase>, 
										  <phrase
										  role="code">RetrieveRight</phrase></para> 
									 <para>Indicates whether a change to the left join
										  key columns should cause the right side to be retrieved, and vice versa.
										  Possible values for these modifiers are 
										  <phrase role="code">True</phrase> and 
										  <phrase role="code">False</phrase>.</para> 
								</listitem> 
								<listitem> 
									 <para><phrase role="code">ClearLeft</phrase>, 
										  <phrase role="code">ClearRight</phrase></para> 
									 <para>Indicates whether the absence of a row in the
										  database corresponding to the new values for the left join key columns should
										  clear the right side of the join, and vice versa. Possible values for these
										  modifiers are 
										  <phrase role="code">True</phrase> and 
										  <phrase role="code">False</phrase>.</para> 
								</listitem> 
								<listitem> 
									 <para><phrase role="code">CoordinateLeft</phrase>, 
										  <phrase
										  role="code">CoordinateRight</phrase></para> 
									 <para>Indicates whether a change in the left join
										  key columns should set the values for the right join key columns, and vice
										  versa. Possible values for these modifiers are 
										  <phrase role="code">True</phrase> and 
										  <phrase role="code">False</phrase>.</para> 
								</listitem> 
								<listitem> 
									 <para><phrase
										  role="code">UpdateLeftToRight</phrase></para> 
									 <para>Indicates whether a data modification should
										  be performed on the left side first. By default, this is determined based on
										  the cardinality of the join. Many-to-one joins are updated right to left, while
										  all other cardinalities are update left-to-right. This functionality is useful
										  for ensuring that updates occur in the order determined by existing constraints
										  that cannot be deferred (foreign keys in an existing system). Possible values
										  for this modifier are 
										  <phrase role="code">True</phrase> and 
										  <phrase role="code">False</phrase>.</para> 
								</listitem> 
								<listitem> 
									 <para><phrase role="code">AnyOf</phrase>, 
										  <phrase role="code">AllOf</phrase></para> 
									 <para>Determines what columns in the outer side of
										  the join constitute the existence of a row in that side. Row existence is
										  defined as having a value for any column in the 
										  <phrase role="code">AnyOf</phrase> modifier,
										  and all columns in the 
										  <phrase role="code">AllOf</phrase> modifier, if
										  specified. By default, the 
										  <phrase role="code">AnyOf</phrase> modifier is
										  set to all non-join-key columns in the outer side, and the 
										  <phrase role="code">AllOf</phrase> modifier is
										  empty. The value for these modifiers is given as a semi-colon delimited list of
										  column names.</para> 
								</listitem> 
						  </itemizedlist></para> 
				</sect2> 
		  </sect1> 
		  <sect1 id="DDGRepresentingDatawithTablesandViews-UsingViews"> 
				<title><indexterm> 
						  <primary>Using Views</primary> 
					 </indexterm><indexterm> 
						  <primary>Representing Data with Tables and Views</primary> 
						  <secondary>Using Views</secondary> 
					 </indexterm>Using Views</title> 
				<para>In this section we discuss using <emphasis>views</emphasis>
					 as a mechanism for exposing different perspectives of the database. As the
					 motivating example, consider the following diagram illustrating the
					 specialization relationship that exists between contacts, customers, and
					 vendors: 
					 <figure> 
						  <title><indexterm> 
									 <primary>Shipping Database Design</primary> 
									 <secondary>Contact Specialization</secondary> 
								</indexterm>Shipping Database Design: Contact
								Specialization</title> 
						  <mediaobject> 
								<imageobject role="fo">
									 <imagedata fileref="Images\ContactSpecializationDiagram.svg" format="SVG"
									 scalefit="1"/> 
								</imageobject> 
								<imageobject role="html">
									 <imagedata fileref="Images\ContactSpecializationDiagram.emf" scalefit="1"/> 
								</imageobject> 
						  </mediaobject> 
					 </figure></para> 
				<para>As the diagram shows, both customers and vendors
					 <emphasis>are</emphasis> contacts. This design allows the common aspects of
					 contacts, such as name, addresses, phone numbers, and history, to be re-used,
					 but results in a fragmented view of the customer and vendor entities. To use
					 this data model directly, we must insert a row into both 
					 <phrase role="code">Contact</phrase> and 
					 <phrase role="code">Customer</phrase> to insert a single
					 customer.</para> 
				<para>To solve this problem, we use views to provide a simplified
					 perspective of the 
					 <phrase role="code">Customer</phrase> and 
					 <phrase role="code">Vendor</phrase> entities in the logical
					 model. The following script shows the definition of the 
					 <phrase role="code">CustomerDetail</phrase> view: 
					 <programlisting>//* View: CustomerDetail
<emphasis role="bold">create view</emphasis> CustomerDetail
	Contact <emphasis role="bold">join</emphasis> Customer
	<emphasis role="bold">tags</emphasis>
	{
		Frontend.Title = "Customer",
		Frontend.Plural.Title = "Customers"
	};</programlisting></para> 
				<para>Because the join is one-to-one, all keys, orders, and
					 references are inferred as we would expect. Furthermore, because of view
					 updatability, inserting a row into the 
					 <phrase role="code">CustomerDetail</phrase> view inserts a row
					 into both the 
					 <phrase role="code">Contact</phrase> and 
					 <phrase role="code">Customer</phrase> tables
					 simultaneously.</para> 
				<para>In addition, the default proposable interface determines that
					 the default value for the 
					 <phrase role="code">ID</phrase> column in the 
					 <phrase role="code">CustomerDetail</phrase> view should be
					 obtained by invoking default defined for the 
					 <phrase role="code">ID</phrase> column of the 
					 <phrase role="code">Contact</phrase> table. This value is also
					 used to set the 
					 <phrase role="code">ID</phrase> column of the newly inserted 
					 <phrase role="code">Customer</phrase> row, and the insert into 
					 <phrase role="code">CustomerDetail</phrase> succeeds, exactly
					 as we would expect.</para> 
				<para>While this is an admittedly simple example, it effectively
					 illustrates the power of logical data independence in providing a unified
					 external view of the database. Even though the 
					 <phrase role="code">CustomerDetail</phrase> and 
					 <phrase role="code">VendorDetail</phrase> table variables are
					 defined as views, they behave exactly as base table variables in the logical
					 model.</para> 
				<para>As we shall see in Part III, this logical data independence
					 functions not only at the logical level within the conceptual model, but,
					 because of the advanced inference mechanisms of the D4 compiler, extends to the
					 presentation layer as well, allowing views to serve as first-class entry points
					 into the schema from the user-interface perspective.</para> 
		  </sect1> 
	 </chapter> 
	 <chapter id="DDGEnforcingBusinessRulesDeclaratively"> 
		  <title><indexterm> 
					 <primary>Business Rules</primary> 
				</indexterm><indexterm> 
					 <primary>Logical Application Design</primary> 
					 <secondary>Business Rules</secondary> 
				</indexterm>Enforcing Business Rules Declaratively</title> 
		  <para>Perhaps the most important aspect of any application is the
				enforcement of business rules. Applications exist to help users make decisions
				without violating business policies and practices, enabling them to perform
				their duties faster, and more effectively. As a result, most of the development
				effort exerted in building applications today is devoted to enforcing business
				rules.</para> 
		  <para>In traditional client-server programming, this enforcement is
				done largely through procedural means, either within a stored procedure on the
				server, a "business object" in a middleware layer, or even directly within the
				client-side application. One of the primary goals of the Dataphor platform is
				to provide an environment where business-rules can be expressed declaratively,
				rather than enforced procedurally.</para> 
		  <para>This chapter discusses the various features of the Dataphor
				Server that can be used to enforce business rules as declaratively as possible
				within an application. The discussion covers the first of two broad classes of
				business rules: constraints, or rules that state what conditions must hold
				within the database, and stimulus-response rules, or rules that specify an
				action to be taken in response to some event occurring within the database. The
				second type of business rule will be discussed in the next chapter but
				one.</para> 
		  <sect1 id="DDGEnforcingBusinessRulesDeclaratively-Defaults"> 
				<title><indexterm> 
						  <primary>Defaults</primary> 
						  <secondary>As Business Rules</secondary> 
					 </indexterm><indexterm> 
						  <primary>Business Rules</primary> 
						  <secondary>Defaults</secondary> 
					 </indexterm>Defaults</title> 
				<para>Defaults are business rules that provide a default value for
					 either a scalar type, or for some column of a table variable. In both cases,
					 the default expression is an arbitrary expression that must evaluate to a value
					 of the type of the scalar type or column on which the default is defined. In
					 addition, the default value generated must satisfy any constraints on the
					 scalar type or column in question.</para> 
				<para>The expression is allowed to reference table variables in the
					 global database, and is not required to be functional or deterministic. This
					 makes defaults ideal for use in implementing surrogate keys using generators.
					 In fact, the pattern is so common that the D4 System Library includes an
					 operator to help ease implementation of generators called 
					 <phrase role="code">EnsureGenerators</phrase>.</para> 
				<para>The following script provides an example of the use of a
					 default definition to provide the value for a surrogate key, as well as for a
					 simple default set to the current date and time: 
					 <programlisting>// Ensure that a generators table exists for this library.
EnsureGenerators();

//* Table: Contact
// The Contact named [Name], is identified by [ID], 
// with primary phone type [Primary_PhoneType_ID]
// Customers and Vendors are both contacts.
<emphasis role="bold">create table</emphasis> Contact
{
	ID : ContactID 
		{ <emphasis role="bold">default</emphasis> GetNextGenerator("Shipping.Contact.ID") },
	Name : ProperName,	
	NameSince : DateTime { <emphasis role="bold">default</emphasis> DateTime() },
	NameBy : UserID { <emphasis role="bold">default</emphasis> UserID() },
	Primary_PhoneType_ID : PhoneTypeID,	
	<emphasis role="bold">key</emphasis> { ID }
};</programlisting></para> 
				<para>Because defaults are part of the application schema and
					 available to the Frontend clients, they can provide the default values for new
					 rows during the data entry process within the user-interface. This is done
					 using the <emphasis>default</emphasis> proposable interface available through
					 the CLI. If the expression for a default does not reference table variables in
					 the database, then the default is considered <emphasis>remotable</emphasis>,
					 and the default expression will be downloaded to the client and evaluated
					 remotely, preventing a network round trip.</para> 
				<para>The default proposable interface will be covered in more
					 detail with the other proposable interfaces in Part III of this guide. At this
					 point, it suffices to say that default definitions are available through the
					 Frontend, and the logic does not have to be repeated in the presentation layer
					 once it has been declared in the application schema.</para> 
		  </sect1> 
		  <sect1 id="DDGEnforcingBusinessRulesDeclaratively-Constraints"> 
				<title><indexterm> 
						  <primary>Constraints</primary> 
						  <secondary>As Business Rules</secondary> 
					 </indexterm><indexterm> 
						  <primary>Business Rules</primary> 
						  <secondary>Constraints</secondary> 
					 </indexterm>Constraints</title> 
				<para>Constraints are business rules that allow a given condition
					 that must hold to be stated within the database. The database system is then
					 responsible for ensuring that no data modification statement is ever allowed to
					 violate the stated condition. D4 allows constraints to be expressed at several
					 different levels, both for simplicity and completeness of the implementation.
					 The following list itemizes these levels: 
					 <itemizedlist> 
						  <listitem> 
								<para>Type Constraints</para> 
								<para>Type constraints are defined on scalar types, and
									 specify valid values for a given type. These constraints are unique in that
									 they are not a special case of a database wide integrity constraint, as all the
									 other constraints are. As such, these constraints are not allowed to reference
									 table variables in the database.</para> 
						  </listitem> 
						  <listitem> 
								<para>Column Constraints</para> 
								<para>Column constraints are defined on table variable
									 columns, either base or derived, and specify valid values for columns of the
									 table variable. These constraints are enforced in addition to any constraints
									 defined on the type of the column. Because all column constraints are
									 considered immediately checked constraints, column constraint expressions are
									 not allowed to reference table variables in the database.</para> 
						  </listitem> 
						  <listitem> 
								<para>Row Constraints</para> 
								<para>Row level constraints are defined in terms of a
									 single row of a given table variable, either base or derived. These constraints
									 specify valid values for rows within the table variable. Row level constraints
									 may be either simple, or transition constraints. Transition constraints allow
									 an insert, update, and delete transition expression to be specified. Whether a
									 row constraint is simple, or transition, it is allowed to reference table
									 variables in the database. Row constraints that do not reference table
									 variables in the database are checked immediately. Otherwise, the row
									 constraint is considered deferred and checked at transaction commit.</para> 
						  </listitem> 
						  <listitem> 
								<para>Table Constraints</para> 
								<para>Table constraints are defined in terms of a
									 single table in the database. Only key constraints fall under this category in
									 D4. Note that although key constraints technically reference table variables in
									 the database, they are checked immediately.</para> 
						  </listitem> 
						  <listitem> 
								<para>Database Constraints</para> 
								<para>Database constraints are defined in terms of an
									 arbitrary expression involving any number of table variables in the database.
									 Reference constraints are an important special case of this class of
									 constraint, and as such have a specific syntax.</para> 
						  </listitem> 
					 </itemizedlist></para> 
				<para>All constraint expressions must be functional, meaning that
					 they do not perform any modification of the database, and deterministic,
					 meaning that for any given input, the expression will always return the same
					 result. The compiler will ensure that the expression satisfies these
					 requirements.</para> 
				<para>Note that if a given constraint expression evaluates to 
					 <phrase role="code"><emphasis
						  role="bold">nil</emphasis></phrase> for some context, the constraint is
					 considered satisfied. This convention simplifies writing constraint
					 expressions, and roughly corresponds to asserting that if a value is not
					 present, it cannot violate any constraint 
					 <footnote> 
						  <para>Of course, a constraint could be written stating that
								a value is required, e.g. 
								<phrase role="code">not(IsNil(value))</phrase>. The
								specification 
								<phrase role="code">not nil</phrase> as part of a
								column definition (the default nilability) is effectively shorthand for this
								constraint.</para> 
					 </footnote>.</para> 
				<para>All constraint expressions are allowed to reference the
					 current context being validated. For database-level constraints, this context
					 is simply the global database. For other types of constraints, this context is
					 available through implicit variables, as shown in the following table: 
					 <indexterm> 
						  <primary>Constraints</primary> 
						  <secondary>Implicit Variables</secondary> 
					 </indexterm><indexterm> 
						  <primary>Implicit Variables</primary> 
						  <secondary>Constraints</secondary> 
					 </indexterm> 
					 <informaltable> 
						  <tgroup cols="2">
								<colspec colname="col1" colnum="1" colwidth="*"/>
								<colspec colname="col2" colnum="2" colwidth="*"/> 
								<thead> 
									 <row> 
										  <entry colname="col1">Constraint Type</entry> 
										  <entry colname="col2">Implicit Variable</entry>
										  
									 </row> 
								</thead> 
								<tbody> 
									 <row> 
										  <entry colname="col1">Scalar Type
												Constraints</entry> 
										  <entry colname="col2">The value being validated
												is available as a variable named 
												<phrase role="code"><emphasis
													 role="bold">value</emphasis></phrase> of the scalar type on which the
												constraint is defined.</entry> 
									 </row> 
									 <row> 
										  <entry colname="col1">Column
												Constraints</entry> 
										  <entry colname="col2">The value being validated
												is available as a variable named 
												<phrase role="code"><emphasis
													 role="bold">value</emphasis></phrase> of the type of the column on which the
												constraint is defined.</entry> 
									 </row> 
									 <row> 
										  <entry colname="col1">Row Constraints</entry> 
										  <entry colname="col2">Columns of the row being
												validated are available by name.</entry> 
									 </row> 
									 <row> 
										  <entry colname="col1">Transition Constraints -
												Insert Transition</entry> 
										  <entry colname="col2">Columns of the new row
												being validated are available by name, namespaced by the keyword 
												<phrase role="code"><emphasis
													 role="bold">new</emphasis></phrase>.</entry> 
									 </row> 
									 <row> 
										  <entry colname="col1">Transition Constraints -
												Update Transition</entry> 
										  <entry colname="col2">Columns of the new row
												being validated are available by name, namespaced by the keyword 
												<phrase role="code"><emphasis
													 role="bold">new</emphasis></phrase>. Columns of the old row being replaced are
												available by name, namespaced by the keyword 
												<phrase role="code"><emphasis
													 role="bold">old</emphasis></phrase>.</entry> 
									 </row> 
									 <row> 
										  <entry colname="col1">Transition Constraints -
												Delete Transition</entry> 
										  <entry colname="col2">Columns of the row being
												deleted are available by name, namespaced by the keyword 
												<phrase role="code"><emphasis
													 role="bold">old</emphasis></phrase>.</entry> 
									 </row> 
								</tbody> 
						  </tgroup> 
					 </informaltable></para> 
				<sect2
				id="DDGEnforcingBusinessRulesDeclaratively-Constraints-CustomErrorMessages"> 
					 <title><indexterm> 
								<primary>Custom Error Messages</primary> 
						  </indexterm><indexterm> 
								<primary>Constraints</primary> 
								<secondary>Custom Error Messages</secondary> 
						  </indexterm>Custom Error Messages</title> 
					 <para>All constraint definitions are allowed to specify custom
						  error messages to be used when displaying a constraint violation to the user.
						  This is accomplished using the 
						  <phrase role="code">DAE.Message</phrase> and 
						  <phrase role="code">DAE.SimpleMessage</phrase> tags. By
						  default, keys and references define custom error messages based on the current
						  values being validated and the name of the table variables involved in the
						  constraint. The 
						  <phrase role="code">DAE.SimpleMessage</phrase> tag is a
						  string which is displayed without modification to the user whenever the
						  constraint is violated. The 
						  <phrase role="code">DAE.Message</phrase> tag is a D4
						  expression that evaluates to a string which is displayed to the user whenever
						  the constraint is violated. This expression can reference the same implicit
						  variables that are available within the constraint expression to access the
						  values being validated.</para> 
				</sect2> 
				<sect2
				id="DDGEnforcingBusinessRulesDeclaratively-Constraints-RowConstraints"> 
					 <title><indexterm> 
								<primary>Row Constraints</primary> 
								<secondary>As Business Rules</secondary> 
						  </indexterm>Row Constraints</title> 
					 <para>Row constraints are formulated in terms of a single row
						  of the table on which they are defined. The columns of the table are available
						  by name within the constraint expression. Row constraints are allowed to
						  reference global table variables. The compiler detects when this is the case,
						  and marks the constraint deferred, rather than immediate.</para> 
					 <para>The following example depicts an immediate row
						  constraint: 
						  <programlisting><emphasis role="bold">alter table</emphasis> ContactNameDuring 
{ 
	<emphasis role="bold">create constraint</emphasis> DatesValid From &lt;= To 
};</programlisting>This constraint enforces that for each row in the 
						  <phrase role="code">ContactNameDuring</phrase> table, the
						  value of the 
						  <phrase role="code">From</phrase> column is less than or
						  equal to the value of the 
						  <phrase role="code">To</phrase> column.</para> 
					 <para>The following example depicts a deferred row constraint: 
						  <programlisting><emphasis role="bold">alter table</emphasis> InvoiceItem
{
	<emphasis role="bold">create constraint</emphasis> ItemsSupplied
		<emphasis role="bold">exists</emphasis> (VendorItemType <emphasis role="bold">rename</emphasis> VIT <emphasis role="bold">where</emphasis> VIT.ItemType_ID = .ItemType_ID)
	<emphasis role="bold">tags</emphasis>
	{
		DAE.Message =
			"'Item type ' + ItemType_ID + ' is not supplied by any vendor.'"
	}
};</programlisting>This constraint ensures that the item type for each invoice
						  item is supplied by some vendor.</para> 
				</sect2> 
				<sect2
				id="DDGEnforcingBusinessRulesDeclaratively-Constraints-References"> 
					 <title><indexterm> 
								<primary>References</primary> 
								<secondary>As Business Rules</secondary> 
						  </indexterm>References</title> 
					 <para>Next to keys and type constraints, references are perhaps
						  the most common type of constraint. As such, they have an explicit syntax. This
						  syntax not only provides a shorthand in D4 for expressing the relationship, but
						  it allows the Dataphor Server to understand the semantics of the data involved.
						  The Dataphor Server can then use this information in a variety of ways, from
						  providing an efficient implementation for enforcing the constraint, to using
						  the meaning of the relationship to elaborate queries, and produce
						  user-interfaces for the presentation layer.</para> 
					 <para>The following example shows a simple reference constraint
						  from 
						  <phrase role="code">Invoice</phrase> to 
						  <phrase role="code">Location</phrase>: 
						  <programlisting><emphasis role="bold">create reference</emphasis> Invoice_Location 
	Invoice { Location_ID } 
	<emphasis role="bold">references</emphasis> Location { ID };</programlisting>This constraint simply specifies that for every row in the 
						  <phrase role="code">Invoice</phrase> table, the value of
						  the 
						  <phrase role="code">Location_ID</phrase> column must appear
						  in the 
						  <phrase role="code">ID</phrase> column for some row of the 
						  <phrase role="code">Location</phrase> table.</para> 
					 <para>As stated earlier, references are shorthand for an
						  equivalent database-wide constraint definition. In this case, the equivalent
						  formulation is: 
						  <programlisting><emphasis role="bold">not exists</emphasis> (Invoice { Location_ID ID }) <emphasis role="bold">minus</emphasis> (Location { ID });</programlisting>Although this formulation is logically equivalent, it is by no
						  means the most efficient formulation in terms of enforcing the constraint. In
						  this formulation, every modification to the 
						  <phrase role="code">Invoice</phrase> or 
						  <phrase role="code">Location</phrase> tables would result
						  in the entire constraint being checked. Internally, therefore, the Dataphor
						  Server uses an entirely difference formulation that only checks the constraint
						  for rows that have been changed. This mechanism will be discussed in the next
						  section.</para> 
					 <para>In addition to the enforcement, the compiler builds
						  descriptive error messages that include the data being validated.</para> 
					 <para>Because references play such an important role in
						  presentation layer development, they will be discussed from that perspective in
						  detail in Part III.</para> 
				</sect2> 
				<sect2
				id="DDGEnforcingBusinessRulesDeclaratively-Constraints-TransitionConstraints"> 
					 <title><indexterm> 
								<primary>Transition Constraints</primary> 
								<secondary>As Business Rules</secondary> 
						  </indexterm>Transition Constraints</title> 
					 <para>Transition constraints allow for data transitions to be
						  validated. There are three different transitions that can be validated: 
						  <phrase role="code"><emphasis
								role="bold">insert</emphasis></phrase>, 
						  <phrase role="code"><emphasis
								role="bold">update</emphasis></phrase>, and 
						  <phrase role="code"><emphasis
								role="bold">delete</emphasis></phrase>, corresponding to the modifications that
						  can be performed. A given transition constraint may have an expression
						  specified for each transition. Within the insert transition, the values of the
						  new row are available by column name, namespaced with the 
						  <phrase role="code"><emphasis
								role="bold">new</emphasis></phrase> keyword. Within the delete transition, the
						  values of the old row are available by column name, namespaced with the 
						  <phrase role="code"><emphasis
								role="bold">old</emphasis></phrase> keyword. Within the update transition, both
						  old and new row values are available.</para> 
					 <para>Transition constraints are expressed and validated
						  row-level. Transition constraints are allowed to reference global table
						  variables. The compiler detects when this is the case, and marks the constraint
						  as deferred, rather than immediate.</para> 
					 <para>The following example depicts an immediate transition
						  constraint: 
						  <programlisting><emphasis role="bold">alter table</emphasis> Invoice
{
	<emphasis role="bold">create transition constraint</emphasis> StatusValid
		<emphasis role="bold">on update</emphasis> 
			(<emphasis role="bold">old</emphasis>.Status_ID = <emphasis role="bold">new</emphasis>.Status_ID) 
				<emphasis role="bold">or</emphasis> 
				(
					(<emphasis role="bold">old</emphasis>.Status_ID = "NEW") 
						<emphasis role="bold">and</emphasis> (<emphasis role="bold">new</emphasis>.Status_ID = "PRO")
				) 
				<emphasis role="bold">or</emphasis> 
				(
					(<emphasis role="bold">old</emphasis>.Status_ID = "PRO") 
						<emphasis role="bold">and</emphasis> (<emphasis role="bold">new</emphasis>.Status_ID = "COM")
				)
		<emphasis role="bold">tags</emphasis>
		{
			DAE.SimpleMessage = 
				"
					Invoice status can only be changed from New to Processed, 
					or from Processed to Completed.
				"
		}
};</programlisting>This constraint enforces that the status of an invoice can
						  only be changed from 
						  <phrase role="code">NEW</phrase> to 
						  <phrase role="code">PRO</phrase>, or from 
						  <phrase role="code">PRO</phrase> to 
						  <phrase role="code">COM</phrase>.</para> 
					 <para>As an example of a deferred transition constraint, we
						  will discuss the reformulation of a reference constraint in terms of transition
						  constraints. To enforce a reference constraint, the D4 compiler will build two
						  transition constraints: one on the source table, and one on the target. The
						  following listing shows the equivalent formulations for the 
						  <phrase role="code">Invoice_Location</phrase> reference
						  constraint: 
						  <programlisting><emphasis role="bold">alter table</emphasis> Invoice
{
	<emphasis role="bold">create transition constraint</emphasis> Invoice_Location
		<emphasis role="bold">on insert 
				exists</emphasis> (Location <emphasis role="bold">where</emphasis> ID = <emphasis role="bold">new</emphasis>.Location_ID)
		<emphasis role="bold">on update</emphasis>
			(<emphasis role="bold">old</emphasis>.Location_ID = <emphasis role="bold">new</emphasis>.Location_ID)
				<emphasis role="bold">or exists</emphasis> (Location <emphasis role="bold">where</emphasis> ID = <emphasis role="bold">new</emphasis>.Location_ID)
};

<emphasis role="bold">alter table</emphasis> Location
{
	<emphasis role="bold">create transition constraint</emphasis> Invoice_Location
		<emphasis role="bold">on update</emphasis>
			(<emphasis role="bold">old</emphasis>.ID = <emphasis role="bold">new</emphasis>.ID)
			<emphasis role="bold">or not exists</emphasis> (Invoice <emphasis role="bold">where</emphasis> Location_ID = <emphasis role="bold">old</emphasis>.ID)
		<emphasis role="bold">on delete not exists</emphasis> (Invoice <emphasis role="bold">where</emphasis> Location_ID = <emphasis role="bold">old</emphasis>.ID)
};</programlisting>The first constraint on the originating table specifies that
						  if a row is inserted or updated in the 
						  <phrase role="code">Invoice</phrase> table, a row with the
						  same 
						  <phrase role="code">Location_ID</phrase> exists in the 
						  <phrase role="code">Location</phrase> table. The second
						  constraint, on the targeted table, specifies that if a row is updated or
						  deleted in the 
						  <phrase role="code">Location</phrase> table, there are no
						  rows in the 
						  <phrase role="code">Invoice</phrase> table with the same 
						  <phrase role="code">Location_ID</phrase>.</para> 
				</sect2> 
				<sect2
				id="DDGEnforcingBusinessRulesDeclaratively-Constraints-GeneralizedKeysandReferences">
					 
					 <title><indexterm> 
								<primary>Generalized Keys and References</primary> 
								<secondary>As Business Rules</secondary> 
						  </indexterm>Generalized Keys and References</title> 
					 <para>As an example of a somewhat more complicated constraint,
						  consider the relationship between the 
						  <phrase role="code">Invoice</phrase>, 
						  <phrase role="code">SaleOrder</phrase>, and 
						  <phrase role="code">PurchaseOrder</phrase> tables. As the
						  following diagram shows, an 
						  <phrase role="code">Invoice</phrase> may be a 
						  <phrase role="code">SaleOrder</phrase> or a 
						  <phrase role="code">PurchaseOrder</phrase>: 
						  <figure> 
								<title><indexterm> 
										  <primary>Shipping Database Design</primary> 
										  <secondary>Invoice Specialization</secondary> 
									 </indexterm>Shipping Database Design: Invoice
									 Specialization</title> 
								<mediaobject> 
									 <imageobject role="fo">
										  <imagedata fileref="Images\InvoiceDiagram.svg" format="SVG" scalefit="1"/> 
									 </imageobject> 
									 <imageobject role="html">
										  <imagedata fileref="Images\InvoiceDiagram.emf" scalefit="1"/> 
									 </imageobject> 
								</mediaobject> 
						  </figure></para> 
					 <para>The references from 
						  <phrase role="code">SaleOrder</phrase> and 
						  <phrase role="code">PurchaseOrder</phrase> to 
						  <phrase role="code">Invoice</phrase> ensure that every
						  sales or purchase order in the system is also an invoice. But the design as
						  given is incomplete. Namely, it allows for two types of invalid data. First,
						  there is nothing to prevent an 
						  <phrase role="code">Invoice</phrase> row from being entered
						  with a corresponding row in both the 
						  <phrase role="code">SaleOrder</phrase>
						  <emphasis>and</emphasis> 
						  <phrase role="code">PurchaseOrder</phrase> tables. Second,
						  there is nothing to prevent an 
						  <phrase role="code">Invoice</phrase> row from being entered
						  without a corresponding row in either the 
						  <phrase role="code">SaleOrder</phrase>
						  <emphasis>or</emphasis> the 
						  <phrase role="code">PurchaseOrder</phrase> tables.</para> 
					 <para>Both of these problems can be solved using transition
						  constraints. The first problem is solved with what is essentially a key
						  constraint defined over the 
						  <phrase role="code">ID</phrase> column of both the 
						  <phrase role="code">SaleOrder</phrase> and 
						  <phrase role="code">PurchaseOrder</phrase> tables. The
						  following listing shows the transition constraint definitions involved: 
						  <programlisting>//* Constraint: InvoiceExclusive
// An invoice cannot be both a sale order and a purchase order.
// Catalog formulation:
// create constraint InvoiceExclusive
//		not exists ((SaleOrder over { ID }) join (PurchaseOrder over { ID }));

<emphasis role="bold">alter table</emphasis> SaleOrder
{
	<emphasis role="bold">create transition constraint</emphasis> InvoiceExclusive
		<emphasis role="bold">on insert not exists</emphasis> (PurchaseOrder <emphasis role="bold">where</emphasis> ID = <emphasis role="bold">new</emphasis>.ID)
		<emphasis role="bold">on update</emphasis> 
			(<emphasis role="bold">old</emphasis>.ID = <emphasis role="bold">new</emphasis>.ID) 
				<emphasis role="bold">or not exists</emphasis> (PurchaseOrder <emphasis role="bold">where</emphasis> ID = <emphasis role="bold">new</emphasis>.ID)
};

<emphasis role="bold">alter table</emphasis> PurchaseOrder
{
	<emphasis role="bold">create transition constraint</emphasis> InvoiceExclusive
		<emphasis role="bold">on insert not exists</emphasis> (SaleOrder <emphasis role="bold">where</emphasis> ID = <emphasis role="bold">new</emphasis>.ID)
		<emphasis role="bold">on update</emphasis> 
			(<emphasis role="bold">old</emphasis>.ID = <emphasis role="bold">new</emphasis>.ID) 
				<emphasis role="bold">or not exists</emphasis> (SaleOrder <emphasis role="bold">where</emphasis> ID = <emphasis role="bold">new</emphasis>.ID)
};</programlisting>Rendered in English, these constraints simply state that 1)
						  When a row is inserted into one table, no row with the same 
						  <phrase role="code">ID</phrase> exists in the other table,
						  and 2) Whenever a row is updated in one table, either the value of the 
						  <phrase role="code">ID</phrase> column is the same, or no
						  row with the new 
						  <phrase role="code">ID</phrase> exists in the other
						  table.</para> 
					 <para>The second problem (that an invoice could exist that is
						  neither a sale order nor a purchase order) is solved with what is essentially a
						  reference constraint that originates in the 
						  <phrase role="code">Invoice</phrase> table, and targets
						  both the 
						  <phrase role="code">SaleOrder</phrase> and 
						  <phrase role="code">PurchaseOrder</phrase> tables. The
						  following listing shows the transition constraint definitions involved: 
						  <programlisting>//* Constraint: InvoiceValid
// An invoice must be either a sale order or a purchase order.
// Catalog formulation:
//	create constraint InvoiceValid
// 	not exists (Invoice { ID } minus (SaleOrder { ID } union PurchaseOrder { ID });
	
<emphasis role="bold">alter table</emphasis> Invoice
{
	<emphasis role="bold">create transition constraint</emphasis> InvoiceValid
		<emphasis role="bold">on insert</emphasis> 
			<emphasis role="bold">exists</emphasis> (SaleOrder <emphasis role="bold">where</emphasis> ID = <emphasis role="bold">new</emphasis>.ID) 
				<emphasis role="bold">or exists</emphasis> (PurchaseOrder <emphasis role="bold">where</emphasis> ID = <emphasis role="bold">new</emphasis>.ID)
		<emphasis role="bold">on update</emphasis> 
			(<emphasis role="bold">old</emphasis>.ID = <emphasis role="bold">new</emphasis>.ID) 
				<emphasis role="bold">or exists</emphasis> (SaleOrder <emphasis role="bold">where</emphasis> ID = <emphasis role="bold">new</emphasis>.ID) 
				<emphasis role="bold">or exists</emphasis> (PurchaseOrder <emphasis role="bold">where</emphasis> ID = <emphasis role="bold">new</emphasis>.ID)
};

<emphasis role="bold">alter table</emphasis> SaleOrder
{
	<emphasis role="bold">create transition constraint</emphasis> InvoiceValid
		<emphasis role="bold">on update</emphasis> 
			(<emphasis role="bold">old</emphasis>.ID = <emphasis role="bold">new</emphasis>.ID) 
				<emphasis role="bold">or not exists</emphasis> (Invoice <emphasis role="bold">where</emphasis> ID = <emphasis role="bold">old</emphasis>.ID) 
				<emphasis role="bold">or exists</emphasis> (PurchaseOrder <emphasis role="bold">where</emphasis> ID = <emphasis role="bold">old</emphasis>.ID)
		<emphasis role="bold">on delete</emphasis> 
			<emphasis role="bold">not exists</emphasis> (Invoice <emphasis role="bold">where</emphasis> ID = <emphasis role="bold">old</emphasis>.ID) 
				<emphasis role="bold">or exists</emphasis> (PurchaseOrder <emphasis role="bold">where</emphasis> ID = <emphasis role="bold">old</emphasis>.ID)
};

<emphasis role="bold">alter table</emphasis> PurchaseOrder
{
	<emphasis role="bold">create transition constraint</emphasis> InvoiceValid
		<emphasis role="bold">on update</emphasis> 
			(<emphasis role="bold">old</emphasis>.ID = <emphasis role="bold">new</emphasis>.ID) 
				<emphasis role="bold">or not exists</emphasis> (Invoice <emphasis role="bold">where</emphasis> ID = <emphasis role="bold">old</emphasis>.ID) 
				<emphasis role="bold">or exists</emphasis> (SaleOrder <emphasis role="bold">where</emphasis> ID = <emphasis role="bold">old</emphasis>.ID)
		<emphasis role="bold">on delete</emphasis> 
			<emphasis role="bold">not exists</emphasis> (Invoice <emphasis role="bold">where</emphasis> ID = <emphasis role="bold">old</emphasis>.ID) 
				<emphasis role="bold">or exists</emphasis> (SaleOrder <emphasis role="bold">where</emphasis> ID = <emphasis role="bold">old</emphasis>.ID)
};</programlisting>Enforcement of this constraint is somewhat more involved, and
						  really breaks down into two separate components: the originating constraint
						  defined on the 
						  <phrase role="code">Invoice</phrase> table, and the
						  targeting constraint defined on the 
						  <phrase role="code">SaleOrder</phrase> and 
						  <phrase role="code">PurchaseOrder</phrase> tables.</para> 
					 <para>Rendered in English, the originating constraint specifies
						  that 1) When a row is inserted into the 
						  <phrase role="code">Invoice</phrase> table, a row with the
						  same 
						  <phrase role="code">ID</phrase> exists in either the 
						  <phrase role="code">SaleOrder</phrase> or 
						  <phrase role="code">PurchaseOrder</phrase> tables, and 2)
						  When a row is updated in the 
						  <phrase role="code">Invoice</phrase> table, either the 
						  <phrase role="code">ID</phrase> is the same, or the insert
						  condition is satisfied.</para> 
					 <para>The targeting constraint specifies that 1) When a row is
						  deleted from the 
						  <phrase role="code">SaleOrder</phrase> or 
						  <phrase role="code">PurchaseOrder</phrase> tables, either
						  there is no row with the same 
						  <phrase role="code">ID</phrase> in the 
						  <phrase role="code">Invoice</phrase> table, or there is a
						  row with the same 
						  <phrase role="code">ID</phrase> in the other table, and 2)
						  When a row is updated in the 
						  <phrase role="code">SaleOrder</phrase> or 
						  <phrase role="code">PurchaseOrder</phrase> tables, either
						  the 
						  <phrase role="code">ID</phrase> is the same, or the
						  condition for deletion is satisfied.</para> 
					 <para>Clearly, these constraint expressions reference the
						  global state of the database, and are therefore not checked until transaction
						  commit time. To see why this is the case, suppose the constraints were checked
						  immediately. There is a reference constraint from 
						  <phrase role="code">SaleOrder</phrase> to 
						  <phrase role="code">Invoice</phrase> so in order to insert
						  a 
						  <phrase role="code">SaleOrder</phrase> row, an 
						  <phrase role="code">Invoice</phrase> row must be defined,
						  but now we have created a constraint that says that in order to insert an 
						  <phrase role="code">Invoice</phrase> row, a 
						  <phrase role="code">SaleOrder</phrase> row must be defined
						  (or a 
						  <phrase role="code">PurchaseOrder</phrase> row, but the
						  same problem arises). As a result, if the constraints as specified were checked
						  immediately, there would be no way to enter data into the system. The problem
						  is resolved by deferring the constraint check until the transaction is being
						  committed.</para> 
					 <para>Notice that in each of these transition constraint
						  definitions, the update formulation includes a comparison of the old and new
						  values of the 
						  <phrase role="code">ID</phrase> column. This is an
						  optimization that allows the query processor to decide whether the execution of
						  the more expensive 
						  <phrase role="code"><emphasis
								role="bold">exists</emphasis></phrase> condition is necessary.</para> 
					 <para>Note also the convention in both of these solutions of
						  naming the transition constraints in each table the same name. This makes it
						  clear that they are all enforcing the same constraint from different
						  perspectives.</para> 
				</sect2> 
		  </sect1> 
	 </chapter> 
	 <chapter id="DDGModelingProcessLogic"> 
		  <title><indexterm> 
					 <primary>Process Logic</primary> 
				</indexterm><indexterm> 
					 <primary>Logical Application Design</primary> 
					 <secondary>Process Logic</secondary> 
				</indexterm>Modeling Process Logic</title> 
		  <para>In addition to being a relationally complete data manipulation
				language, D4 provides a full imperative language for modeling the process logic
				of a given application. This chapter discusses the various imperative features
				of the D4 language such as flow control, structured exception handling, and
				operators.</para> 
		  <para>Note that although this chapter focuses on the imperative
				features of the D4 language, the Dataphor platform is a declarative development
				environment. In a traditional imperative language, the product of application
				development is an executable containing a "main" program loop. By contrast, the
				product of development in Dataphor is a set of application schema that model
				the problem domain, adorned with pieces of imperative code that run in response
				to events throughout the system, more like the <emphasis>event-driven
				programming</emphasis> model of RAD paradigms.</para> 
		  <sect1 id="DDGModelingProcessLogic-LanguageElements"> 
				<title><indexterm> 
						  <primary>Language Elements</primary> 
					 </indexterm><indexterm> 
						  <primary>Process Logic</primary> 
						  <secondary>Language Elements</secondary> 
					 </indexterm>Language Elements</title> 
				<para>As with any imperative language, the basic elements of the D4
					 language are types, values, variables, statements, expressions, and
					 operators.</para> 
				<para>Types have already been discussed in some detail, and so we
					 simply repeat the definition here for completeness: types are named sets of
					 values. Each type allows the developer to specify the valid domain of values
					 for a given context within the language such as a variable, a column within a
					 table, or the parameters of an operator.</para> 
				<para>Every value, such as the integer value 
					 <phrase role="code">5</phrase>, has an associated type. The
					 type of a given value is fixed by the compiler, and is used to guarantee at
					 compile-time that every usage of the value within the language is valid within
					 the context in which it appears. This is commonly referred to as
					 <emphasis>strong-typing</emphasis>, and allows the compiler to verify the
					 semantics, or meaning, of a given program.</para> 
				<para>Variables provide the storage locations for values within the
					 D4 language. Variables can be as simple as a local variable of type 
					 <phrase role="code">Integer</phrase>, and as complex as a base
					 table variable within the global database. Every variable has a
					 <emphasis>scope</emphasis> which defines the lifetime and accessibility of the
					 variable.</para> 
				<para>Variables declared within local scopes, such as those
					 delimited by 
					 <phrase role="code"><emphasis
						  role="bold">begin</emphasis>..<emphasis role="bold">end</emphasis></phrase>
					 blocks within D4, are valid only within that scope, or a nested scope. In
					 addition, table variables can be defined within the global scope, or database,
					 and also within the scope of the current session, by using the keyword 
					 <phrase role="code"><emphasis
						  role="bold">session</emphasis></phrase> in the 
					 <phrase role="code"><emphasis role="bold">create
						  table</emphasis></phrase> or 
					 <phrase role="code"><emphasis
						  role="bold">view</emphasis></phrase> statement.</para> 
				<para>Statements form the fundamental unit of execution within the
					 D4 language. Various statements are provided for performing basic tasks within
					 the language such as variable declaration, structural definition, and so on.
					 There are three basic categories of statements within D4: imperative
					 statements, data manipulation language statements, and data definition language
					 statements.</para> 
				<para>Imperative statements are the basic statements such as
					 assignment and flow control statements that form the basis of the imperative
					 capabilities of the D4 language. These statements will be discussed in more
					 detail in the following sections.</para> 
				<para>Data manipulation language statements are the familiar 
					 <phrase role="code"><emphasis
						  role="bold">select</emphasis></phrase>, 
					 <phrase role="code"><emphasis
						  role="bold">insert</emphasis></phrase>, 
					 <phrase role="code"><emphasis
						  role="bold">update</emphasis></phrase>, and 
					 <phrase role="code"><emphasis
						  role="bold">delete</emphasis></phrase> statements that are used to retrieve and
					 manipulate data in table variables.</para> 
				<para>Data definition language statements are used to describe and
					 maintain the various catalog structures available within D4. These are
					 statements such as 
					 <phrase role="code"><emphasis role="bold">create
						  table</emphasis></phrase> and 
					 <phrase role="code"><emphasis role="bold">create
						  operator</emphasis></phrase>.</para> 
				<para>Expressions are statements that return a value. Expressions
					 can be as simple as a single literal value selector, or as complex as an
					 arbitrary table-valued expression. An important point to be made is that any
					 given expression in D4 can be combined with other expressions to produce larger
					 expressions. These can then be further combined with other expressions and so
					 on, allowing expressions of arbitrary complexity to be built within the
					 language. This may seem like a trivial observation, but the degree to which
					 this nesting of expressions is possible within a language has a direct impact
					 on its flexibility and power. Traditionally, DBMS languages such as SQL have
					 suffered from various limitations on the types of expressions that can appear
					 in given contexts. One of the goals of the Dataphor Server is to insulate the
					 developer as much as possible from these limitations in existing
					 systems.</para> 
				<para>Operators are pre-compiled sets of D4 statements that can be
					 invoked from elsewhere within a D4 program. Each operator can take any number
					 of parameters, each with a name and declared type, and can optionally return a
					 value of some type. If a given operator does not return a value, it is
					 considered a statement equivalent, and can be used anywhere that a statement is
					 expected within D4. If an operator does return a value, it is considered an
					 expression equivalent, and can be used anywhere that an expression is expected,
					 so long as the return type of the operator is valid within the context in which
					 it appears, of course.</para> 
				<para>These basic elements provide the foundation for all the
					 functionality and capabilities of the D4 language. The following sections
					 discuss the various imperative statements and capabilities of the D4 language
					 in more detail. The chapter concludes with an example of processing logic taken
					 from the Shipping application.</para> 
		  </sect1> 
		  <sect1 id="DDGModelingProcessLogic-ValuesandVariables"> 
				<title><indexterm> 
						  <primary>Values</primary> 
						  <secondary>Process Logic and</secondary> 
					 </indexterm><indexterm> 
						  <primary>Variables</primary> 
						  <secondary>Process Logic and</secondary> 
					 </indexterm><indexterm> 
						  <primary>Process Logic</primary> 
						  <secondary>Values and Variables</secondary> 
					 </indexterm>Values and Variables</title> 
				<para>In addition to the scalar types discussed in the 
					 <ulink type="link"
					 url="DDGImplementingDataTypes.html"><citetitle>Implementing Data
								Types</citetitle></ulink> chapter, the D4 language provides the following
					 categories of types: 
					 <itemizedlist> 
						  <listitem> 
								<para>Lists</para> 
						  </listitem> 
						  <listitem> 
								<para>Rows</para> 
						  </listitem> 
						  <listitem> 
								<para>Tables</para> 
						  </listitem> 
						  <listitem> 
								<para>Cursors</para> 
						  </listitem> 
					 </itemizedlist></para> 
				<para>Each of these type categories can be used to declare
					 variables, select and manipulate values, and define operator parameters and
					 result types. The following sections will discuss each of these types of
					 values.</para> 
				<sect2 id="DDGModelingProcessLogic-ValuesandVariables-UsingLists"> 
					 <title><indexterm> 
								<primary>Using Lists</primary> 
						  </indexterm><indexterm> 
								<primary>Process Logic</primary> 
								<secondary>Using Lists</secondary> 
						  </indexterm><indexterm> 
								<primary>Lists</primary> 
								<secondary>Using Lists</secondary> 
						  </indexterm>Using Lists</title> 
					 <para>This section describes how to use list selectors and the
						  system-provided operators of the Dataphor Server to construct and manipulate
						  list values.</para> 
					 <para>A list is an ordered collection of values of the same
						  type. Values in the list are distinguishable by ordinal position. The list type
						  specifies the type of values in the list. A list selector is used to construct
						  a list value: 
						  <programlisting><emphasis role="bold">begin</emphasis>
	<emphasis role="bold">var</emphasis> LList : <emphasis role="bold">list</emphasis>(Integer) := { 12, 13, 14, 15 };
	// list type can be specified in the selector
	LList := <emphasis role="bold">list</emphasis>(Integer) { };
<emphasis role="bold">end</emphasis>;</programlisting></para> 
					 <para>The following operators are defined for lists: 
						  <itemizedlist> 
								<listitem> 
									 <para>Comparison Operators</para> 
									 <para>The comparison operators 
										  <phrase role="code"><ulink type="olinka"
												url="O-System.iEqual.html">=</ulink></phrase> and 
										  <phrase role="code"><ulink type="olinka"
												url="O-System.iNotEqual.html">&lt;&gt;</ulink></phrase> are defined for list
										  values. Two lists are equal if they are of the same type, have the same number
										  of values, and the values in each list are equal by ordinal position: 
										  <programlisting><emphasis role="bold">begin</emphasis>
	<emphasis role="bold">var</emphasis> LList1 := { 1, 2, 3 };
	<emphasis role="bold">var</emphasis> LList2 := { 1, 2, 3 };
	<emphasis role="bold">if not</emphasis>(LList1 = LList2) <emphasis role="bold">then</emphasis>
		<emphasis role="bold">raise</emphasis> Error("Lists not equal");
<emphasis role="bold">end</emphasis>;</programlisting></para> 
								</listitem> 
								<listitem> 
									 <para>Membership Operator</para> 
									 <para>The membership operator 
										  <phrase role="code"><emphasis
												role="bold"><ulink type="olinka"
												url="O-System.iIn.html">in</ulink></emphasis></phrase> is defined for lists and
										  returns true if the given value is in the specified list: 
										  <programlisting><emphasis role="bold">begin</emphasis>
	<emphasis role="bold">var</emphasis> LList := { 1, 2, 3 };
	<emphasis role="bold">if not</emphasis>(3 <emphasis role="bold">in</emphasis> LList) <emphasis role="bold">then</emphasis>
		<emphasis role="bold">raise</emphasis> Error("3 is not in the list");
<emphasis role="bold">end</emphasis>;</programlisting></para> 
								</listitem> 
								<listitem> 
									 <para>List Indexer</para> 
									 <para>The indexer operator (<ulink type="olinka"
										  url="O-System.iIndexer.html"><phrase role="code">[]</phrase></ulink>) is
										  defined for lists and allows the values of a list to be accessed by ordinal
										  position within the list. Indexes are zero-based: 
										  <programlisting><emphasis role="bold">begin</emphasis>
	<emphasis role="bold">var</emphasis> LList := { 1, 2, 3 };
	<emphasis role="bold">if not</emphasis>(LList[0] = 1) <emphasis role="bold">then</emphasis>
		<emphasis role="bold">raise</emphasis> Error("First item is not 1");
<emphasis role="bold">end</emphasis>;</programlisting></para> 
								</listitem> 
								<listitem> 
									 <para><phrase role="code"><ulink type="olinka"
												url="O-System.Count.html">Count</ulink></phrase></para> 
									 <para>Returns the number of values in the given
										  list.</para> 
								</listitem> 
								<listitem> 
									 <para><phrase role="code"><ulink type="olinka"
												url="O-System.Clear.html">Clear</ulink></phrase></para> 
									 <para>Removes all values from the specified list.
										  The target list must be a list variable.</para> 
								</listitem> 
								<listitem> 
									 <para><phrase role="code"><ulink type="olinka"
												url="O-System.iExtend.html">Add</ulink></phrase></para> 
									 <para>Adds the specified value into the given list.
										  The target list must be a list variable.</para> 
								</listitem> 
								<listitem> 
									 <para><phrase role="code"><ulink type="olinka"
												url="O-System.Insert.html">Insert</ulink></phrase></para> 
									 <para>Inserts the specified value in the given list
										  at the desired location. The target list must be a list variable.</para> 
								</listitem> 
								<listitem> 
									 <para><phrase role="code"><ulink type="olinka"
												url="O-System.iRemove.html">Remove</ulink></phrase></para> 
									 <para>Removes the specified value from the given
										  list. The target list must be a list variable.</para> 
								</listitem> 
								<listitem> 
									 <para><phrase role="code"><ulink type="olinka"
												url="O-System.RemoveAt.html">RemoveAt</ulink></phrase></para> 
									 <para>Removes the value at the specified location
										  from the given list. The target list must be a list variable.</para> 
								</listitem> 
								<listitem> 
									 <para><phrase role="code"><ulink type="olinka"
												url="O-System.IndexOf.html">IndexOf</ulink></phrase></para> 
									 <para>Returns the index of the specified value
										  within the given list. If the value is not in the list, -1 is returned.</para> 
								</listitem> 
						  </itemizedlist></para> 
					 <para>For more information on these operators, refer to 
						  <ulink type="olinka" url="O-System.ListOperators.html">List
								Operators</ulink>.</para> 
				</sect2> 
				<sect2 id="DDGModelingProcessLogic-ValuesandVariables-UsingRows"> 
					 <title><indexterm> 
								<primary>Using Rows</primary> 
						  </indexterm><indexterm> 
								<primary>Process Logic</primary> 
								<secondary>Using Rows</secondary> 
						  </indexterm><indexterm> 
								<primary>Rows</primary> 
								<secondary>Using Rows</secondary> 
						  </indexterm>Using Rows</title> 
					 <para>This section describes how to use row selectors and the
						  system-provided operators of the Dataphor Server to construct and manipulate 
						  <ulink type="link"
						  url="D4LGLanguageElements-Values-RowValues.html">row values</ulink>.</para> 
					 <para>A row is a set of named values called columns. The row
						  type specifies the name and type of each column. A row selector is used to
						  construct a value of a specified row type: 
						  <programlisting><emphasis role="bold">var</emphasis> LRow : <emphasis role="bold">row</emphasis> { ID : Integer } := <emphasis role="bold">row</emphasis> { 5 ID };</programlisting></para> 
					 <para>As the preceding example illustrates, variables are
						  allowed to be of any 
						  <ulink type="link"
						  url="D4LGLanguageElements-Types-RowTypes.html">row type</ulink>. Optionally,
						  the type of the row can be specified as part of the row selector. In this case,
						  the expressions in the row selector provide values for the columns of the row.
						  For example, to define a row with 
						  <phrase role="code">nil</phrase> for all columns, use a
						  type specifier in the selector, but do not provide any expressions in the body
						  of the selector:
						  <programlisting><emphasis role="bold">var</emphasis> LRow := <emphasis role="bold">row of</emphasis> { ID : Integer } { };</programlisting></para>
					 <para>When combined with the <emphasis
						  role="bold"><phrase role="code">typeof</phrase></emphasis> type specifier, this
						  can provide a useful shorthand. For example, within the body of a row-valued
						  operator, the 
						  <phrase role="code"><emphasis
								role="bold">result</emphasis></phrase> can be initialized with an empty row
						  with the following statement:
						  <programlisting><emphasis role="bold">result</emphasis> := <emphasis role="bold">row of typeof</emphasis>(<emphasis role="bold">result</emphasis>) { };</programlisting></para>
					 <para>The following operators are defined for row types: 
						  <itemizedlist> 
								<listitem> 
									 <para>Comparison Operators</para> 
									 <para>The comparison operators 
										  <phrase role="code"><ulink type="olinka"
												url="O-System.iEqual.html">=</ulink></phrase> and 
										  <phrase role="code"><ulink type="olinka"
												url="O-System.iNotEqual.html">&lt;&gt;</ulink></phrase> are defined for row
										  values. Two row values are equal if they are of the same row type and both rows
										  have values for the same set of columns by name, and those values are
										  equal.</para> 
								</listitem> 
								<listitem> 
									 <para>Column Extractor</para> 
									 <para>The column extraction operator 
										  <phrase role="code">.</phrase> (dot) retrieves
										  the value for a single column in the row. If the row does not have a value for
										  the given column, the result is 
										  <phrase role="code">nil</phrase>. If the row
										  variable that is the target of the extraction does not have a value, the result
										  of evaluating the extraction is also 
										  <phrase role="code">nil</phrase>.</para> 
								</listitem> 
								<listitem> 
									 <para>Row Update</para> 
									 <para>Row 
										  <phrase role="code"><emphasis
												role="bold"><ulink type="link"
												url="D4LGDataManipulation-UpdateStatement.html">update</ulink></emphasis></phrase>
										  allows the values for specific columns within a given row to be changed. The
										  target of a row update must be a variable: 
										  <programlisting><emphasis role="bold">begin</emphasis>
	<emphasis role="bold">var</emphasis> LRow := <emphasis role="bold">row</emphasis> { 5 ID, "John" Name };
	<emphasis role="bold">update</emphasis> LRow <emphasis role="bold">set</emphasis> { Name := "Jack" };
<emphasis role="bold">end</emphasis>;</programlisting></para> 
								</listitem> 
								<listitem> 
									 <para>Row Project</para> 
									 <para>Row project (<phrase role="code"><emphasis
												role="bold"><ulink type="olinka"
												url="O-System.iProject.html">over</ulink></emphasis></phrase>) returns a row
										  with only the specified columns of the given row: 
										  <programlisting><emphasis role="bold">begin</emphasis>
	<emphasis role="bold">var</emphasis> LRow1 := <emphasis role="bold">row</emphasis> { 5 ID, "John" Name };
	<emphasis role="bold">var</emphasis> LRow2 := LRow1 <emphasis role="bold">over</emphasis> { ID };
<emphasis role="bold">end</emphasis>;</programlisting></para> 
								</listitem> 
								<listitem> 
									 <para>Row Remove</para> 
									 <para>Row 
										  <phrase role="code"><emphasis
												role="bold"><ulink type="olinka"
												url="O-System.iRemove.html">remove</ulink></emphasis></phrase> returns a row
										  with the specified columns removed from the given row: 
										  <programlisting><emphasis role="bold">begin</emphasis>
	<emphasis role="bold">var</emphasis> LRow1 := <emphasis role="bold">row</emphasis> { 5 ID, "John" Name };
	<emphasis role="bold">var</emphasis> LRow2 := LRow1 <emphasis role="bold">remove</emphasis> { Name };
<emphasis role="bold">end</emphasis>;</programlisting></para> 
								</listitem> 
								<listitem> 
									 <para>Row Add</para> 
									 <para>Row 
										  <phrase role="code"><emphasis
												role="bold"><ulink type="olinka"
												url="O-System.iExtend.html">add</ulink></emphasis></phrase> allows columns to
										  be added to a given row. The current values of the columns in the source row
										  are available by column name within the expressions defining the new columns: 
										  <programlisting><emphasis role="bold">begin</emphasis>
	<emphasis role="bold">var</emphasis> LRow1 := <emphasis role="bold">row</emphasis> { 5 ID };
	<emphasis role="bold">var</emphasis> LRow2 := LRow1 <emphasis role="bold">add</emphasis> { "John" Name };
<emphasis role="bold">end</emphasis>;</programlisting></para> 
								</listitem> 
								<listitem> 
									 <para>Row Redefine</para> 
									 <para>Row 
										  <phrase role="code"><emphasis
												role="bold"><ulink type="link"
												url="D4LGTableExpressions-Redefine.html">redefine</ulink></emphasis></phrase>
										  allows columns of a given row to be redefined. The current values of the
										  columns in the source row are available by column name within the expressions
										  defining the new columns. Just as with table redefine, this operator is defined
										  as a shorthand for adding a new column 
										  <phrase role="code">X</phrase>, removing some
										  column 
										  <phrase role="code">Y</phrase>, and then
										  renaming 
										  <phrase role="code">X</phrase> to 
										  <phrase role="code">Y</phrase>: 
										  <programlisting><emphasis role="bold">begin</emphasis>
	<emphasis role="bold">var</emphasis> LRow1 := <emphasis role="bold">row</emphasis> { 5 ID, "John" Name };
	LRow1 := LRow1 <emphasis role="bold">redefine</emphasis> { ID := 6 };

	// equivalent
	LRow1 := 
		LRow1 
			<emphasis role="bold">add</emphasis> { 6 X } 
			<emphasis role="bold">remove</emphasis> { ID } 
			<emphasis role="bold">rename</emphasis> { X ID };
<emphasis role="bold">end</emphasis>;</programlisting></para> 
								</listitem> 
								<listitem> 
									 <para>Row Rename</para> 
									 <para>Row 
										  <phrase role="code"><emphasis
												role="bold"><ulink type="olinka"
												url="O-System.iRename.html">rename</ulink></emphasis></phrase> allows columns
										  of a given row to be renamed. The values of the renamed columns are unaffected:
										  
										  <programlisting><emphasis role="bold">begin</emphasis>
	<emphasis role="bold">var</emphasis> LRow1 :=	<emphasis role="bold">row</emphasis> { 5 ID, "John" Name };
	<emphasis role="bold">var</emphasis> LRow2 := LRow1 <emphasis role="bold">rename</emphasis> { ID X, Name Y };
<emphasis role="bold">end</emphasis>;</programlisting></para> 
								</listitem> 
								<listitem> 
									 <para>Row Specify</para> 
									 <para>Row specify allows the desired columns to be
										  specified. Just as for table-valued expressions, this operator is shorthand for
										  an extend-project-rename operation.</para> 
								</listitem> 
								<listitem> 
									 <para>Row Join</para> 
									 <para>Row 
										  <phrase role="code"><emphasis
												role="bold"><ulink type="olinka"
												url="O-System.iJoin.html">join</ulink></emphasis></phrase> allows two rows to
										  be joined together. If the two rows have common column names, the values for
										  those columns in each row must be equal: 
										  <programlisting><emphasis role="bold">begin</emphasis>
	<emphasis role="bold">var</emphasis> LRow1 :=	<emphasis role="bold">row</emphasis> { 5 ID, "John" Name };
	<emphasis role="bold">var</emphasis> LRow2 :=	<emphasis role="bold">row</emphasis> { 5 ID, "Provo" City };
	<emphasis role="bold">var</emphasis> LRow3 :=	<emphasis role="bold">row</emphasis> { 6 ID, "Orem" City };
	<emphasis role="bold">var</emphasis> LRow4 : <emphasis role="bold">row</emphasis> { ID : Integer, Name : String, City : String };
	LRow4 := LRow1 <emphasis role="bold">join</emphasis> LRow2;
	LRow4 := LRow1 <emphasis role="bold">join</emphasis> LRow3; // this is an error
<emphasis role="bold">end</emphasis>;</programlisting></para> 
								</listitem> 
						  </itemizedlist></para> 
				</sect2> 
				<sect2 id="DDGModelingProcessLogic-ValuesandVariables-UsingTables">
					 
					 <title><indexterm> 
								<primary>Using Tables</primary> 
						  </indexterm><indexterm> 
								<primary>Process Logic</primary> 
								<secondary>Using Tables</secondary> 
						  </indexterm><indexterm> 
								<primary>Tables</primary> 
								<secondary>Using Tables</secondary> 
						  </indexterm>Using Table Values</title> 
					 <para>In addition to global and session-specific table
						  variables, D4 allows table types to be used in local table variable
						  declarations, as well as parameter types. This section discusses the usage of
						  table variables and values within the imperative context of the D4
						  language.</para> 
					 <para>Table values are sets of rows, each of the same type. A
						  table type specifier is used to specify the names and types of each column in
						  the table value. Table selectors are used to construct table values: 
						  <programlisting><emphasis role="bold">begin</emphasis>
	<emphasis role="bold">var</emphasis> LTable : <emphasis role="bold">table</emphasis> { ID : Integer };
	LTable := <emphasis role="bold">table</emphasis> { <emphasis role="bold">row</emphasis> { 1 ID }, <emphasis role="bold">row</emphasis> { 1 } };
<emphasis role="bold">end</emphasis>;</programlisting>Note that a table selector is simply a comma-delimited list of
						  row-valued expressions, of which row selectors are just one variety. In other
						  words, a table selector need not be constructed entirely from row selectors.
						  For example: 
						  <programlisting><emphasis role="bold">insert</emphasis>
	<emphasis role="bold">table</emphasis> {	RowValuedOperator(), LTable[1] }
	<emphasis role="bold">into</emphasis> LTable2;</programlisting>In addition, table selectors are simply another variety of
						  table-valued expression, and can be used anywhere a table-value is
						  required.</para> 
					 <para>As with all variable declaration statements, the type
						  specifier is optional if an initializer is provided: 
						  <programlisting><emphasis role="bold">var</emphasis> LTable := <emphasis role="bold">table</emphasis> { <emphasis role="bold">row</emphasis> { 1 ID } };</programlisting>When a type specifier is not given as part of a variable
						  declaration statement, the compiler infers the type of the variable based on
						  the type of the initializer expression.</para> 
					 <para>The various operators that can be performed on table
						  values have already been discussed in detail in 
						  <ulink type="olinka"
						  url="DDGRepresentingDataWithTablesAndViews.html"><citetitle>Representing Data
									 with Tables and Views</citetitle></ulink>. As mentioned previously, D4 also
						  allows for the definition of local table variables, and for parameters and
						  return values to be table-typed. There are several points to be made regarding
						  this functionality.</para> 
					 <para><indexterm> 
								<primary>Chunking Boundary</primary> 
						  </indexterm>First, local table variables are allocated
						  within the query processor directly, rather than as part of a device. As such,
						  they constitute a <emphasis>chunking boundary</emphasis>, or a point at which
						  the distributed query mechanisms of the query processor must take over. Because
						  data must be transferred into the query processor whenever a chunking boundary
						  is crossed, care should be taken to avoid excessive data copying.</para> 
					 <para>Second, local table variables exhibit the same copy
						  semantics that non-table variables do. They are values just like the integer
						  value 
						  <phrase role="code">5</phrase>, and while the query
						  processor is optimized to perform only the processing that is necessary, the
						  results of a local table variable assignment will be materialized fully.</para>
					 
					 <para>Third, the mechanism for declaring local table variables
						  does not allow for the definition of the other structural information
						  associated with global and session-specific table variables. The only
						  structural information that can be provided for local table variables is the
						  heading information, or the names and types of each column in the table value.
						  Specifically, keys, orders, metadata, constraints, references, etc.,. cannot be
						  provided for local table variables 
						  <footnote> 
								<para>This is a byproduct of the syntax of the table
									 type specifier in D4. Although it is strictly correct that the type specifier
									 only specify the type (keys, constraints, and other structural information are
									 part of the variable definition rather than the type definition) it has the
									 unfortunate side effect of limiting the functionality of local table variables.
									 We plan on addressing this problem in a future release of the product.</para> 
						  </footnote>.</para> 
					 <para>And finally, table operators in D4 are fully
						  <emphasis>pipelined</emphasis>. This means that whenever possible, table
						  operators evaluate a row-at-a-time as data is requested. User-defined
						  table-valued operators, while allowed, cannot be optimized in this way if they
						  are written in D4 
						  <footnote> 
								<para>Although the details of this behavior are beyond
									 the scope of this discussion, it suffices to say that the internal
									 representation of the table value is different for pipelined execution, and
									 that only host-implemented operators can access the pipelined representation of
									 a table value.</para> 
						  </footnote>. As a result, D4 implemented table-valued
						  operators cannot be pipelined, and the results of the entire operation will be
						  materialized on every invocation.</para> 
				</sect2> 
				<sect2
				id="DDGModelingProcessLogic-ValuesandVariables-UsingCursors"> 
					 <title><indexterm> 
								<primary>Using Cursors</primary> 
						  </indexterm><indexterm> 
								<primary>Process Logic</primary> 
								<secondary>Using Cursors</secondary> 
						  </indexterm><indexterm> 
								<primary>Cursors</primary> 
								<secondary>Using Cursors</secondary> 
						  </indexterm>Using Cursors</title> 
					 <para>This section describes the general usage of cursors in
						  D4. Many of the operations dealing with cursors are operators in the System
						  Library. These operators will be covered briefly. For a complete description of
						  each operator, refer to 
						  <ulink type="olinka"
						  url="O-System.CursorOperators.html">Cursor Operators</ulink>.</para> 
					 <para>Cursors in the Dataphor Server allow navigational access
						  to the results of a given table expression. A <emphasis>cursor
						  selector</emphasis> is used to declare and open a cursor. Declaring a cursor
						  allocates server resources which must be released. This is done using the 
						  <phrase role="code"><ulink type="olinka"
								url="O-System.Close.html">Close</ulink></phrase> operator. Note that the
						  resource protection block (<phrase role="code"><emphasis
								role="bold">try</emphasis>..<emphasis role="bold">finally</emphasis></phrase>)
						  should always be used to ensure that a cursor is closed.</para> 
					 <para>Cursors in the Dataphor Server are "cracked", meaning
						  that the cursor can be positioned before the first row (BOF), after the last
						  row (EOF), or on some row. It is an error to attempt a read or update operation
						  against a cursor that is positioned on a crack. The 
						  <phrase role="code"><ulink type="olinka"
								url="O-System.BOF.html">BOF</ulink></phrase> and 
						  <phrase role="code"><ulink type="olinka"
								url="O-System.EOF.html">EOF</ulink></phrase> operators return true if the
						  cursor is positioned on the BOF or EOF crack, respectively. If both BOF and EOF
						  are true, the cursor is ranging over an empty set.</para> 
					 <para>The functionality of a cursor is divided up into
						  <emphasis>capabilities</emphasis>. Capabilities are requested as part of the
						  cursor definition. For a complete description of 
						  <ulink type="link"
						  url="D4LGDataManipulation-SelectStatement-CursorCapabilities.html">cursor
								capabilities</ulink> and other cursor behaviors, refer to the D4 Language Guide
						  discussion of the 
						  <ulink type="xref"
						  url="D4LGDataManipulation-SelectStatement.html">Select
								Statement</ulink>.</para> 
					 <para>Once a cursor is open, all operations against it are done
						  using the cursor operators: 
						  <itemizedlist> 
								<listitem> 
									 <para><ulink type="olinka"
										  url="O-System.Select.html">Select</ulink></para> 
									 <para><phrase role="code">Select(<emphasis
												role="bold">const</emphasis> ACursor : <emphasis role="bold">cursor</emphasis>)
												: <emphasis role="bold">row</emphasis></phrase></para> 
									 <para><phrase role="code">Select(<emphasis
												role="bold">const</emphasis> ACursor : <emphasis role="bold">cursor</emphasis>,
												<emphasis role="bold">var</emphasis> ARow : <emphasis
												role="bold">row</emphasis>)</phrase></para> 
									 <para>Selects the current row from the cursor
										  specified by 
										  <phrase role="code">ACursor</phrase>. It is an
										  error to call 
										  <phrase role="code">Select</phrase> if either 
										  <phrase role="code">BOF</phrase> or 
										  <phrase role="code">EOF</phrase> is
										  true.</para> 
									 <para>If no row is provided, the 
										  <phrase role="code">Select</phrase> operator
										  returns a row. Otherwise, the values of the given row will be set to the values
										  of the current row in the cursor.</para> 
									 <para>The row specified by 
										  <phrase role="code">ARow</phrase> need not
										  conform to the heading for the table over which the cursor ranges. Columns are
										  matched by name with the given row.</para> 
								</listitem> 
								<listitem> 
									 <para><ulink type="olinka"
										  url="O-System.Insert.html">Insert</ulink></para> 
									 <para><phrase role="code">Insert(<emphasis
												role="bold">const</emphasis> ACursor : <emphasis role="bold">cursor</emphasis>,
												<emphasis role="bold">const</emphasis> ARow : <emphasis
												role="bold">row</emphasis>)</phrase></para> 
									 <para>Inserts the row given by 
										  <phrase role="code">ARow</phrase> into the
										  cursor specified by 
										  <phrase role="code">ACursor</phrase>. The
										  position of the cursor after the insert is determined by the cursor type
										  specified in the cursor definition. If the cursor is static, the newly inserted
										  row will not be visible in the cursor and the position of the cursor is
										  unaffected. If the cursor is dynamic, the newly inserted row will be visible,
										  and the cursor will attempt to be positioned on the new row. If the cursor is
										  searchable, the cursor will be positioned on the newly inserted row, otherwise,
										  it will be positioned as though 
										  <phrase role="code"><ulink type="olinka"
												url="O-System.Reset.html">Reset</ulink></phrase> had been called.</para> 
									 <para>The row specified by 
										  <phrase role="code">ARow</phrase> need not
										  conform to the heading for the table over which the cursor ranges. Columns are
										  matched by name with the given row.</para> 
								</listitem> 
								<listitem> 
									 <para><ulink type="olinka"
										  url="O-System.Update.html">Update</ulink></para> 
									 <para><phrase role="code">Update(<emphasis
												role="bold">const</emphasis> ACursor : <emphasis role="bold">cursor</emphasis>,
												<emphasis role="bold">const</emphasis> ARow : <emphasis
												role="bold">row</emphasis>)</phrase></para> 
									 <para>Updates the current row of the cursor
										  specified by 
										  <phrase role="code">ACursor</phrase> to the
										  values given by 
										  <phrase role="code">ARow</phrase>. It is an
										  error to call 
										  <phrase role="code">Update</phrase> if either 
										  <phrase role="code">BOF</phrase> or 
										  <phrase role="code">EOF</phrase> is true. The
										  position of the cursor after the update is determined by the cursor type
										  specified in the cursor definition. If the cursor is
										  <emphasis>static</emphasis>, the update will not be visible in the cursor and
										  the position of the cursor is unaffected. If the cursor is
										  <emphasis>dynamic</emphasis>, the update will be visible, and the cursor will
										  attempt to refresh to the updated row. If the cursor is searchable, the cursor
										  will be positioned on the updated row, otherwise, it will be positioned as
										  though a 
										  <phrase role="code"><ulink type="olinka"
												url="O-System.Reset.html">Reset</ulink></phrase> had been called.</para> 
									 <para>The row specified by 
										  <phrase role="code">ARow</phrase> need not
										  conform to the heading for the table over which the cursor ranges. Columns are
										  matched by name with the given row.</para> 
								</listitem> 
								<listitem> 
									 <para><ulink type="olinka"
										  url="O-System.Delete.html">Delete</ulink></para> 
									 <para><phrase role="code">Delete(<emphasis
												role="bold">const</emphasis> ACursor : <emphasis
												role="bold">cursor</emphasis>)</phrase></para> 
									 <para>Deletes the current row of the cursor
										  specified by 
										  <phrase role="code">ACursor</phrase>. It is an
										  error to call 
										  <phrase role="code">Delete</phrase> if either 
										  <phrase role="code">BOF</phrase> or 
										  <phrase role="code">EOF</phrase> is true. The
										  position of the cursor after the delete is determined by the cursor type
										  specified in the cursor definition. If the cursor is static, the delete will
										  not be visible in the cursor, and the position of the cursor is unaffected. If
										  the cursor is dynamic, the delete will be visible in the cursor, and the cursor
										  will attempt to be positioned as close as possible to the deleted row. If the
										  cursor is searchable, the cursor will be positioned as though a 
										  <phrase role="code">FindNearest</phrase> had
										  been called on the deleted row. Otherwise, it will be positioned as though a 
										  <phrase role="code"><ulink type="olinka"
												url="O-System.Reset.html">Reset</ulink></phrase> had been called.</para> 
									 <para>The row specified by 
										  <phrase role="code">ARow</phrase> need not
										  conform to the heading for the table over which the cursor ranges. Columns are
										  matched by name with the given row.</para> 
								</listitem> 
								<listitem> 
									 <para><ulink type="olinka"
										  url="O-System.BOF.html">BOF</ulink></para> 
									 <para><phrase role="code">BOF(<emphasis
												role="bold">const</emphasis> ACursor : <emphasis role="bold">cursor</emphasis>)
												: Boolean</phrase></para> 
									 <para>Returns true if the cursor specified by 
										  <phrase role="code">ACursor</phrase> is
										  positioned on the BOF crack, or before the first row in the result set, and
										  false otherwise.</para> 
								</listitem> 
								<listitem> 
									 <para><ulink type="olinka"
										  url="O-System.EOF.html">EOF</ulink></para> 
									 <para><phrase role="code">EOF(<emphasis
												role="bold">const</emphasis> ACursor : <emphasis role="bold">cursor</emphasis>)
												: Boolean</phrase></para> 
									 <para>Returns true if the cursor specified by 
										  <phrase role="code">ACursor</phrase> is
										  positioned on the EOF crack, or after the last row in the result set, and false
										  otherwise.</para> 
								</listitem> 
								<listitem> 
									 <para><ulink type="olinka"
										  url="O-System.First.html">First</ulink></para> 
									 <para><phrase role="code">First(<emphasis
												role="bold">const</emphasis> ACursor : <emphasis
												role="bold">cursor</emphasis>)</phrase></para> 
									 <para>Positions the cursor specified by 
										  <phrase role="code">ACursor</phrase> on the BOF
										  crack. 
										  <phrase role="code">BOF</phrase> is guaranteed
										  to be true after a call to 
										  <phrase role="code">First</phrase>.</para> 
								</listitem> 
								<listitem> 
									 <para><ulink type="olinka"
										  url="O-System.Prior.html">Prior</ulink></para> 
									 <para><phrase role="code">Prior(<emphasis
												role="bold">const</emphasis> ACursor : <emphasis role="bold">cursor</emphasis>)
												: Boolean</phrase></para> 
									 <para>Navigates the cursor specified by 
										  <phrase role="code">ACursor</phrase> to the
										  prior row in the result set. If the navigation is successful, i.e. the cursor
										  is positioned on a row, the operator returns true. Otherwise, the operator
										  returns false.</para> 
								</listitem> 
								<listitem> 
									 <para><ulink type="olinka"
										  url="O-System.Next.html">Next</ulink></para> 
									 <para><phrase role="code">Next(<emphasis
												role="bold">const</emphasis> ACursor : <emphasis role="bold">cursor</emphasis>)
												: Boolean</phrase></para> 
									 <para>Navigates the cursor specified by 
										  <phrase role="code">ACursor</phrase> to the
										  next row in the result set. If the navigation is successful, i.e. the cursor is
										  positioned on a row, the operator returns true. Otherwise, the operator returns
										  false.</para> 
								</listitem> 
								<listitem> 
									 <para><ulink type="olinka"
										  url="O-System.Last.html">Last</ulink></para> 
									 <para><phrase role="code">Last(<emphasis
												role="bold">const</emphasis> ACursor : <emphasis
												role="bold">cursor</emphasis>)</phrase></para> 
									 <para>Positions the cursor specified by 
										  <phrase role="code">ACursor</phrase> on the EOF
										  crack. 
										  <phrase role="code"><ulink type="olinka"
												url="O-System.EOF.html">EOF</ulink></phrase> is guaranteed to be true after a
										  call to 
										  <phrase role="code">Last</phrase>.</para> 
								</listitem> 
								<listitem> 
									 <para><ulink type="olinka"
										  url="O-System.Reset.html">Reset</ulink></para> 
									 <para><phrase role="code">Reset(<emphasis
												role="bold">const</emphasis> ACursor : <emphasis
												role="bold">cursor</emphasis>)</phrase></para> 
									 <para>Refreshes the result set for the cursor
										  specified by 
										  <phrase role="code">ACursor</phrase> from the
										  underlying database and positions the cursor on the BOF crack. Note that even a
										  static cursor will be refreshed after a call to 
										  <phrase role="code">Reset</phrase>. 
										  <phrase role="code"><ulink type="olinka"
												url="O-System.BOF.html">BOF</ulink></phrase> is guaranteed to be true after a
										  call to 
										  <phrase role="code">Reset</phrase>.</para> 
								</listitem> 
								<listitem> 
									 <para><ulink type="olinka"
										  url="O-System.GetKey.html">GetKey</ulink></para> 
									 <para><phrase role="code">GetKey(<emphasis
												role="bold">const</emphasis> ACursor : <emphasis role="bold">cursor</emphasis>)
												: <emphasis role="bold">row</emphasis></phrase></para> 
									 <para>Gets the key value for the current row of the
										  cursor specified by 
										  <phrase role="code">ACursor</phrase>. This row
										  can be used in subsequent calls to 
										  <phrase role="code"><ulink type="olinka"
												url="O-System.FindKey.html">FindKey</ulink></phrase> and 
										  <phrase role="code"><ulink type="olinka"
												url="O-System.FindNearest.html">FindNearest</ulink></phrase>.</para> 
								</listitem> 
								<listitem> 
									 <para><ulink type="olinka"
										  url="O-System.FindKey.html">FindKey</ulink></para> 
									 <para><phrase role="code">FindKey(<emphasis
												role="bold">const</emphasis> ACursor : <emphasis role="bold">cursor</emphasis>,
												ARow : <emphasis role="bold">row</emphasis>) : Boolean</phrase></para> 
									 <para>Finds the key value given by 
										  <phrase role="code">ARow</phrase> in the cursor
										  specified by 
										  <phrase role="code">ACursor</phrase>. If the
										  find is successful, the operator returns true, indicating that the cursor is
										  positioned on a row with a key value matching that specified by 
										  <phrase role="code">ARow</phrase>. Otherwise,
										  the operator returns false, and the position of the cursor is unaffected. Note
										  that if the key value specified by 
										  <phrase role="code">ARow</phrase> is a partial
										  key, then the cursor is not guaranteed to be on any particular row within the
										  set of rows matching the partial key.</para> 
								</listitem> 
								<listitem> 
									 <para><ulink type="olinka"
										  url="O-System.FindNearest.html">FindNearest</ulink></para> 
									 <para><phrase role="code">FindNearest(<emphasis
												role="bold">const</emphasis> ACursor : <emphasis role="bold">cursor</emphasis>,
												ARow : <emphasis role="bold">row</emphasis>)</phrase></para> 
									 <para>Finds the row most closely matching the key
										  value given by 
										  <phrase role="code">ARow</phrase> in the cursor
										  specified by 
										  <phrase role="code">ACursor</phrase>. No
										  guarantees are made about the position of the cursor after a call to 
										  <phrase role="code">FindNearest</phrase>. As
										  specified for the 
										  <phrase role="code">FindKey</phrase> operator,
										  if the key value given by 
										  <phrase role="code">ARow</phrase> is a partial
										  key, then the cursor is not guaranteed to be on any particular row within the
										  set of rows matching the partial key.</para> 
								</listitem> 
								<listitem> 
									 <para><ulink type="olinka"
										  url="O-System.Refresh.html">Refresh</ulink></para> 
									 <para><phrase role="code">Refresh(<emphasis
												role="bold">const</emphasis> ACursor : <emphasis role="bold">cursor</emphasis>,
												ARow : <emphasis role="bold">row</emphasis>)</phrase></para> 
									 <para>Refreshes the result set for the cursor
										  specified by 
										  <phrase role="code">ACursor</phrase> and
										  attempts to position the cursor on the row given by 
										  <phrase role="code">ARow</phrase>. This
										  operator is conceptually equivalent to calling 
										  <phrase role="code"><ulink type="olinka"
												url="O-System.Reset.html">Reset</ulink></phrase> followed by 
										  <phrase role="code"><ulink type="olinka"
												url="O-System.FindNearest.html">FindNearest</ulink></phrase>.</para> 
								</listitem> 
								<listitem> 
									 <para><ulink type="olinka"
										  url="O-System.GetBookmark.html">GetBookmark</ulink></para> 
									 <para><phrase role="code">GetBookmark(<emphasis
												role="bold">const</emphasis> ACursor : <emphasis role="bold">cursor</emphasis>)
												: <emphasis role="bold">row</emphasis></phrase></para> 
									 <para>Gets a bookmark for the current row of the
										  cursor specified by 
										  <phrase role="code">ACursor</phrase>. This
										  bookmark can then be used in subsequent calls to 
										  <phrase role="code"><ulink type="olinka"
												url="O-System.GotoBookmark.html">GotoBookmark</ulink></phrase> and 
										  <phrase role="code"><ulink type="olinka"
												url="O-System.CompareBookmarks.html">CompareBookmarks</ulink></phrase>. Note
										  that the structure of the row returned by 
										  <phrase role="code">GetBookmark</phrase> is
										  implementation defined and not guaranteed to be meaningful. A bookmark is only
										  guaranteed to be valid for the cursor from which it was retrieved.</para> 
								</listitem> 
								<listitem> 
									 <para><ulink type="olinka"
										  url="O-System.GotoBookmark.html">GotoBookmark</ulink></para> 
									 <para><phrase role="code">GotoBookmark(<emphasis
												role="bold">const</emphasis> ACursor : <emphasis role="bold">cursor</emphasis>,
												<emphasis role="bold">const</emphasis> ABookmark : <emphasis
												role="bold">row</emphasis>) : Boolean</phrase></para> 
									 <para>Positions the cursor specified by 
										  <phrase role="code">ACursor</phrase> on the row
										  corresponding to the bookmark given by 
										  <phrase role="code">ABookmark</phrase>. This
										  bookmark must have been previously retrieved with a call to 
										  <phrase role="code"><ulink type="olinka"
												url="O-System.GetBookmark.html">GetBookmark</ulink></phrase>. The operator
										  returns true if the bookmark is valid and the cursor is positioned on the
										  correct row. The operator returns false if the bookmark is invalid, or the row
										  could not be located. If the operator returns false, the position of the cursor
										  is unaffected.</para> 
								</listitem> 
								<listitem> 
									 <para><ulink type="olinka"
										  url="O-System.CompareBookmarks.html">CompareBookmarks</ulink></para> 
									 <para><phrase
										  role="code">CompareBookmarks(<emphasis role="bold">const</emphasis> ACursor :
												<emphasis role="bold">cursor</emphasis>, <emphasis role="bold">const</emphasis>
												ABookmark1 : <emphasis role="bold">row</emphasis>, <emphasis
												role="bold">const</emphasis> ABookmark2 : <emphasis role="bold">row</emphasis>)
												: Integer</phrase></para> 
									 <para>Compares the bookmarks given by 
										  <phrase role="code">ABookmark1</phrase> and 
										  <phrase role="code">ABookmark2</phrase> using
										  the cursor specified by 
										  <phrase role="code">ACursor</phrase>. The given
										  bookmarks must have been previously retrieved with a call to 
										  <phrase role="code"><ulink type="olinka"
												url="O-System.GetBookmark.html">GetBookmark</ulink></phrase>. The operator
										  returns -1 if 
										  <phrase role="code">ABookmark1</phrase> is less
										  than 
										  <phrase role="code">ABookmark2</phrase>, 0 if
										  they are equal, and 1 if 
										  <phrase role="code">ABookmark1</phrase> is
										  greater than 
										  <phrase role="code">ABookmark2</phrase>.</para>
									 
								</listitem> 
								<listitem> 
									 <para><ulink type="olinka"
										  url="O-System.Close.html">Close</ulink></para> 
									 <para><phrase role="code">Close(<emphasis
												role="bold">const</emphasis> ACursor : <emphasis
												role="bold">cursor</emphasis>)</phrase></para> 
									 <para>Closes the cursor specified by 
										  <phrase role="code">ACursor</phrase> and
										  deallocates any associated resources. All cursors opened using a cursor
										  selector must be closed with this operator.</para> 
								</listitem> 
						  </itemizedlist></para> 
					 <para>The following examples illustrate the use of cursors in
						  D4: 
						  <programlisting>// Use a cursor to build a list of names of objects in the system.
<emphasis role="bold">begin</emphasis>
	<emphasis role="bold">var</emphasis> LCursor : <emphasis role="bold">cursor</emphasis>(<emphasis role="bold">table</emphasis> { Name : Name }) := 
		<emphasis role="bold">cursor</emphasis>(Objects <emphasis role="bold">over</emphasis> { Name });
	<emphasis role="bold">var</emphasis> LNameList : String := "";
	<emphasis role="bold">try</emphasis>
		<emphasis role="bold">while</emphasis> LCursor.Next() <emphasis role="bold">do</emphasis>
		<emphasis role="bold">begin</emphasis>
			<emphasis role="bold">if</emphasis> LNameList.Length() &gt; 0 <emphasis role="bold">then</emphasis>
				LNameList := LNameList + ", ";
			LNameList := 
				LNameList + LCursor.Select().Name;
		<emphasis role="bold">end</emphasis>;
		<emphasis role="bold">if</emphasis> LNameList.Length() &gt; 0 <emphasis role="bold">then</emphasis>
			LNameList := LNameList + ".";
		<emphasis role="bold">raise</emphasis> Error("Object Names: " + LNameList);
	<emphasis role="bold">finally</emphasis>
		LCursor.Close();
	<emphasis role="bold">end</emphasis>;
<emphasis role="bold">end</emphasis>;</programlisting> 
						  <programlisting>// Find a specific object name in the system.
<emphasis role="bold">begin</emphasis>
	<emphasis role="bold">var</emphasis> LCursor : <emphasis role="bold">cursor</emphasis>(<emphasis role="bold">table</emphasis> { Name : Name }) :=
		<emphasis role="bold">cursor</emphasis>
		(
			Objects <emphasis role="bold">over</emphasis> { Name } 
				<emphasis role="bold">capabilities</emphasis> { Navigable, Searchable }
		);
	<emphasis role="bold">try</emphasis>
		<emphasis role="bold">if not</emphasis> LCursor.FindKey(<emphasis role="bold">row</emphasis> { Name("System.Integer") Name }) <emphasis role="bold">then</emphasis>
			<emphasis role="bold">raise</emphasis> Error("System.Integer data type not found");
	<emphasis role="bold">finally</emphasis>
		LCursor.Close();
	<emphasis role="bold">end</emphasis>;
<emphasis role="bold">end</emphasis>;</programlisting> 
						  <programlisting>// Find the closest match to a given name in the system
<emphasis role="bold">begin</emphasis>
	<emphasis role="bold">var</emphasis> LCursor : <emphasis role="bold">cursor</emphasis>(<emphasis role="bold">table</emphasis> { Name : Name }) :=
		<emphasis role="bold">cursor</emphasis>
		(
			Objects <emphasis role="bold">over</emphasis> { Name } 
				<emphasis role="bold">capabilities</emphasis> { Navigable, Searchable }
		);
	<emphasis role="bold">try</emphasis>
		LCursor.FindNearest(<emphasis role="bold">row</emphasis> { Name("System.FindKey") Name });
		<emphasis role="bold">raise</emphasis> Error(LCursor.Select().Name);
	<emphasis role="bold">finally</emphasis>
		LCursor.Close();
	<emphasis role="bold">end</emphasis>;
<emphasis role="bold">end</emphasis>;</programlisting> 
						  <programlisting>// Use bookmarks to reposition the cursor
<emphasis role="bold">begin</emphasis>
	<emphasis role="bold">var</emphasis> LCursor : <emphasis role="bold">cursor</emphasis>(<emphasis role="bold">table</emphasis> { Name : Name }) :=
		<emphasis role="bold">cursor</emphasis>
		(
			Objects <emphasis role="bold">over</emphasis> { Name } 
				<emphasis role="bold">capabilities</emphasis> { Navigable, Bookmarkable, Searchable }
		);
	<emphasis role="bold">try</emphasis>
		LCursor.FindKey(<emphasis role="bold">row</emphasis> { Name("System.Integer") Name });
		<emphasis role="bold">var</emphasis> LRow : <emphasis role="bold">row</emphasis> := LCursor.GetBookmark();
		LCursor.First();
		LCursor.GotoBookmark(LRow);
	<emphasis role="bold">finally</emphasis>
		LCursor.Close();
	<emphasis role="bold">end</emphasis>;
<emphasis role="bold">end</emphasis>;</programlisting></para> 
				</sect2> 
		  </sect1> 
		  <sect1 id="DDGModelingProcessLogic-Operators"> 
				<title><indexterm> 
						  <primary>Operators</primary> 
						  <secondary>Process Logic and</secondary> 
					 </indexterm><indexterm> 
						  <primary>Process Logic</primary> 
						  <secondary>Operators</secondary> 
					 </indexterm>Operators</title> 
				<para>Operators form the fundamental building blocks of any D4
					 program. Operators can be as simple as the definition of a multiplication
					 operator for some type, or as complex as a payroll calculation or inventory
					 adjustment. Operators can take any number of arguments (including zero) of any
					 type, and can optionally return a value of any type. Note specifically that
					 this includes table and row types.</para> 
				<para>At this point we note that the term
					 <emphasis>operator</emphasis> in D4 applies generally. The language makes no
					 distinction between functions, procedures, operators, subroutines, stored
					 procedures, triggers, etc.,. The built-in addition operator (<phrase
					 role="code">+</phrase>) is just as much an operator as the user-defined 
					 <phrase role="code">UpdateInventory(...)</phrase>.</para> 
				<para>Operators that do not return a value may be invoked anywhere
					 that a statement may appear in the D4 language, including in particular the
					 body of other operators. Operators that do return a value may be invoked
					 anywhere that an expression may appear in the D4 language. Operators thus form
					 the basis for abstracting over statements and expressions within D4.</para> 
				<para>D4 operators can be written in D4, or host-implemented. For
					 more information on host-implemented operators, refer to the 
					 <ulink
					 url="DDGImplementingDataTypes-Host-ImplementedTypesandOperators">Host-Implemented
						  Types And Operators</ulink> discussion in 
					 <citetitle>Implementing Data Types</citetitle>.</para> 
				<sect2 id="DDGModelingProcessLogic-Operators-OperatorInvocation"> 
					 <title>Operator Invocation</title> 
					 <para>Operators in D4 can be invoked in several ways. First,
						  the built-in 
						  <footnote> 
								<para>A built-in operator is an operator that is
									 recognized as a symbol of the language e.g. 
									 <phrase role="code">+</phrase>, rather than as an
									 identifier, e.g. 
									 <phrase role="code">Distance()</phrase>.</para> 
						  </footnote> operators of the D4 language can be invoked
						  using the parser-recognized symbol: 
						  <programlisting>2 + 2</programlisting> Second, an operator can be invoked using its name and passing
						  the required number of arguments: 
						  <programlisting>Distance(Coordinate(120.12, 87.6), Coordinate(110.13, 87.6));</programlisting> Finally, an operator can be invoked using the dot (<phrase
						  role="code">.</phrase>) operator: 
						  <programlisting>Coordinate(120.12, 87.6).Distance(Coordinate(110.13, 87.6));</programlisting>This last style of invocation allows object-oriented style
						  "method" invocation, and is provided as a syntactic convenience. In this style
						  of invocation, the compiler searches for an overload of the operator using the
						  left argument of the dot operator as the first argument. Note that any operator
						  (with at least one parameter) can be invoked in this way.</para> 
				</sect2> 
				<sect2 id="DDGModelingProcessLogic-Operators-OperatorPrecedence"> 
					 <title>Operator Precedence</title> 
					 <para>Because D4 allows chains of in-fix 
						  <footnote> 
								<para>For completeness, the term in-fix refers to the
									 syntactic style of placing the operator symbol between the arguments, e.g. 
									 <phrase role="code">2 + 2</phrase>. Note that the
									 term applies mainly to binary built-in operators.</para> 
						  </footnote> operators, operator precedence must be used to
						  determine the order of operations performed. Of course, order of operation can
						  always be explicitly specified using parentheses. For a complete discussion of
						  operator precedence, refer to 
						  <ulink type="olinnka"
						  url="D4LGLanguageElements-Expressions-OperatorPrecedence.html">Operator
								Precedence</ulink> in the D4 Language Guide.</para> 
				</sect2> 
				<sect2 id="DDGModelingProcessLogic-Operators-OperatorResolution"> 
					 <title>Operator Resolution</title> 
					 <para>D4 supports operator overloading, meaning that two
						  operators may have the same name as long as they have different signatures. For
						  example, the addition operator (<phrase role="code">+</phrase>) in D4 is
						  capable of adding two integers, as well as performing string concatenation. As
						  the following listing shows, the syntax for each expression is the same: 
						  <programlisting>1 + 1
"H" + "ello"</programlisting>Because of this, the compiler must be able to determine which
						  overload is being called. This process is called <emphasis>operator
						  resolution</emphasis>, and is done by comparing the number and types of the
						  arguments in the invocation with the number and types of the arguments in each
						  overload of the operator being called.</para> 
					 <para>During this process, the compiler will make use of
						  implicit conversions in attempting to resolve a particular overload. If the
						  compiler can unambiguously match a single overload signature with the calling
						  signature, the resolution is successful and the appropriate operator is
						  invoked. Otherwise, the compiler will report an error indicating why it was
						  unable to produce a match.</para> 
					 <para>For a more in-depth discussion of operator resolution,
						  refer to 
						  <ulink type="olinka"
						  url="D4LGCatalogElements-Operators-OperatorResolution.html">Operator
								Resolution</ulink> in the D4 Language Guide.</para> 
				</sect2> 
				<sect2 id="DDGModelingProcessLogic-Operators-AggregateOperators"> 
					 <title>Aggregate Operators</title> 
					 <para>Aggregate operators are D4 operators that are defined
						  with a special calling convention that allows them to be used to compute
						  aggregates of table values. Each aggregate operator has three sections:
						  <emphasis>initialization</emphasis>, <emphasis>aggregation</emphasis>, and
						  <emphasis>finalization</emphasis>. The initialization section is executed one
						  time at the beginning of the computation. The aggregation section is invoked
						  once for each row of the table value being aggregated, with the values for the
						  current row passed as the parameters defined in the signature of the aggregate
						  operator. The finalization section is executed one time at the end of the
						  computation to allow any final steps to be performed. Each of these sections
						  may be written in D4 or host-implemented.</para> 
					 <para>Note that variables declared within the initialization
						  section will be visible within the aggregation and finalization sections, but
						  variables declared within the aggregation section will not be visible within
						  the finalization section. In other words, the entire aggregate operator (all
						  three sections inclusive) form a single outer scope, with the aggregation
						  section forming its own nested scope.</para> 
					 <para>For a more in-depth discussion of aggregate operators,
						  refer to 
						  <ulink type="link"
						  url="D4LGCatalogElements-Operators-AggregateOperators.html">Aggregate
								Operators</ulink> in the D4 Language Guide.</para> 
				</sect2> 
		  </sect1> 
		  <sect1 id="DDGModelingProcessLogic-FlowControl"> 
				<title><indexterm> 
						  <primary>Flow Control</primary> 
						  <secondary>Process Logic and</secondary> 
					 </indexterm><indexterm> 
						  <primary>Process Logic</primary> 
						  <secondary>Flow Control</secondary> 
					 </indexterm>Flow Control</title> 
				<para>In an imperative language like D4, a program runs as a series
					 of statements that execute sequentially. Each of these statements may be either
					 a built-in D4 statement, or an invocation of some system or user-defined
					 operator. Each operator is itself a series of D4 statements, either built-in,
					 or user-defined.</para> 
				<para>In addition to statements like variable declaration or
					 assignment statements, D4 provides various flow control statements that allow
					 the path of execution within the program to be controlled. D4 provides two main
					 varieties of flow control statements: branching statements, and looping
					 statements.</para> 
				<sect2
				id="DDGModelingProcessLogic-FlowControl-BranchingConstructs"> 
					 <title><indexterm> 
								<primary>Branching Statements</primary> 
								<secondary>Process Logic and</secondary> 
						  </indexterm><indexterm> 
								<primary>Process Logic</primary> 
								<secondary>Branching Statements</secondary> 
						  </indexterm>Branching Statements</title> 
					 <para>Branching statements allow the selection of the next
						  statement to be executed based on the evaluation of some condition. There are
						  two different branching statements in D4: the 
						  <phrase role="code"><emphasis
								role="bold">if</emphasis></phrase> statement, and the 
						  <phrase role="code"><emphasis
								role="bold">case</emphasis></phrase> statement.</para> 
					 <para>The 
						  <phrase role="code"><emphasis
								role="bold">if</emphasis></phrase> statement provides a single condition to be
						  evaluated, and determines the next statement to be executed based on the result
						  of evaluating that condition. For example, the following D4 script illustrates
						  the conditional execution of a single statement: 
						  <programlisting><emphasis role="bold">if exists</emphasis> (Location <emphasis role="bold">where</emphasis> ID = '001') <emphasis role="bold">then</emphasis>
	<emphasis role="bold">update</emphasis> Location 
		<emphasis role="bold">set</emphasis> { Name := 'Location 001' } 
		<emphasis role="bold">where</emphasis> ID = '001';</programlisting></para> 
					 <para>The 
						  <phrase role="code"><emphasis
								role="bold">if</emphasis></phrase> statement also includes an optional 
						  <phrase role="code"><emphasis
								role="bold">else</emphasis></phrase> clause which allows an alternative
						  statement to be executed. To continue with the previous example: 
						  <programlisting><emphasis role="bold">if exists</emphasis> (Location <emphasis role="bold">where</emphasis> ID = '001') <emphasis role="bold">then</emphasis>
	<emphasis role="bold">update</emphasis> Location 
		<emphasis role="bold">set</emphasis> { Name := 'Location 001' } 
		<emphasis role="bold">where</emphasis> ID = '001'
<emphasis role="bold">else</emphasis>
	<emphasis role="bold">insert 
		table</emphasis> { <emphasis role="bold">row</emphasis> { '001' ID, 'Location 001' Name } } 
		<emphasis role="bold">into</emphasis> Location;</programlisting></para> 
					 <para>Note that in this example, there is no statement
						  terminator preceding the 
						  <phrase role="code"><emphasis
								role="bold">else</emphasis></phrase> keyword. This is because the D4 language
						  considers the entire 
						  <phrase role="code"><emphasis
								role="bold">if..then..else</emphasis></phrase> statement to be a single
						  statement.</para> 
					 <para>The 
						  <phrase role="code"><emphasis
								role="bold">case</emphasis></phrase> statement allows a single statement from
						  among a set of statements to be selected for execution, based on the evaluation
						  of some condition. There are two flavors of the case statement, one in which a
						  single value is tested against multiple values, and one in which multiple
						  conditions are evaluated. Both flavors allow a default condition to be
						  specified using the 
						  <phrase role="code"><emphasis
								role="bold">else</emphasis></phrase> keyword.</para> 
					 <para>The following program listing illustrates both of these
						  statements: 
						  <programlisting><emphasis role="bold">case</emphasis> LShape
	<emphasis role="bold">when</emphasis> 'Circle' <emphasis role="bold">then</emphasis> DrawCircle();
	<emphasis role="bold">when</emphasis> 'Square' <emphasis role="bold">then</emphasis> DrawSquare();
	<emphasis role="bold">else</emphasis> DrawLine();
<emphasis role="bold">end</emphasis>;

<emphasis role="bold">case</emphasis>
	<emphasis role="bold">when</emphasis> LShape = 'Circle' <emphasis role="bold">then</emphasis> DrawCircle();
	<emphasis role="bold">when</emphasis> LShape = 'Square' <emphasis role="bold">then</emphasis> DrawSquare();
	<emphasis role="bold">else</emphasis> DrawLine();
<emphasis role="bold">end</emphasis>;</programlisting></para> 
					 <para>Clearly, these two statements are logically equivalent.
						  D4 provides both statements for convenience.</para> 
				</sect2> 
				<sect2 id="DDGModelingProcessLogic-FlowControl-LoopingConstructs"> 
					 <title><indexterm> 
								<primary>Looping Statements</primary> 
								<secondary>Process Logic and</secondary> 
						  </indexterm><indexterm> 
								<primary>Process Logic</primary> 
								<secondary>Looping Statements</secondary> 
						  </indexterm>Looping Statements</title> 
					 <para>Looping statements allow a given statement to be executed
						  multiple times. D4 provides five different looping statements: the 
						  <phrase role="code"><emphasis
								role="bold">for</emphasis></phrase> loop, the 
						  <phrase role="code"><emphasis
								role="bold">while</emphasis></phrase> loop, the 
						  <phrase role="code"><emphasis
								role="bold">do..while</emphasis></phrase> loop, the 
						  <phrase role="code"><emphasis
								role="bold">repeat..until</emphasis></phrase> loop, and a specialized 
						  <phrase role="code"><emphasis
								role="bold">foreach</emphasis></phrase> statement.</para> 
					 <para>The 
						  <phrase role="code"><emphasis
								role="bold">for</emphasis></phrase> loop allows a given statement to be
						  executed a specified number of times: 
						  <programlisting><emphasis role="bold">for</emphasis> LIndex : Integer := 1 <emphasis role="bold">to</emphasis> 100 <emphasis role="bold">do</emphasis>
	<emphasis role="bold">insert table</emphasis> { <emphasis role="bold">row</emphasis> { LIndex X } } <emphasis role="bold">into</emphasis> Points;</programlisting>Note that the 
						  <phrase role="code"><emphasis
								role="bold">for</emphasis></phrase> loop allows for iterator variable
						  declaration within the statement itself, or referencing an existing variable
						  within the local scope. In addition, the 
						  <phrase role="code"><emphasis
								role="bold">var</emphasis></phrase> keyword can be used instead of a type
						  specifier as follows: 
						  <programlisting><emphasis role="bold">for var</emphasis> LIndex := 1 <emphasis role="bold">to</emphasis> 100 <emphasis role="bold">do</emphasis>
	<emphasis role="bold">insert table</emphasis> { <emphasis role="bold">row</emphasis> { LIndex X } } <emphasis role="bold">into</emphasis> Points;</programlisting>In this case, the type of the variable 
						  <phrase role="code">LIndex</phrase> is determined by the
						  type of the range expressions.</para> 
					 <para>The 
						  <phrase role="code"><emphasis
								role="bold">while</emphasis></phrase> loop allows a statement to be executed as
						  long as a specified condition remains true: 
						  <programlisting><emphasis role="bold">begin</emphasis>
	<emphasis role="bold">var</emphasis> LIndex := 1;
	<emphasis role="bold">while</emphasis> LIndex &lt;= 100 <emphasis role="bold">do</emphasis>
	<emphasis role="bold">begin</emphasis>
		<emphasis role="bold">insert table</emphasis> { <emphasis role="bold">row</emphasis> { LIndex X } } <emphasis role="bold">into</emphasis> Points;
		LIndex := LIndex + 1;
	<emphasis role="bold">end</emphasis>;</programlisting></para> 
					 <para>The 
						  <phrase role="code"><emphasis
								role="bold">do..while</emphasis></phrase> loop introduces a scope within the 
						  <phrase role="code"><emphasis
								role="bold">do</emphasis></phrase> and 
						  <phrase role="code"><emphasis
								role="bold">while</emphasis></phrase> keywords, and allows a set of statements
						  to be executed, with the test condition being evaluated after the statements
						  are executed: 
						  <programlisting><emphasis role="bold">begin</emphasis>
	<emphasis role="bold">var</emphasis> LIndex := 0;
	<emphasis role="bold">do</emphasis>
		LIndex := LIndex + 1;
		<emphasis role="bold">insert table</emphasis> { <emphasis role="bold">row</emphasis> { LIndex X } } <emphasis role="bold">into</emphasis> Points;
	<emphasis role="bold">while</emphasis> LIndex &lt; 100;</programlisting></para> 
					 <para>The 
						  <phrase role="code"><emphasis
								role="bold">repeat..until</emphasis></phrase> loop also introduces a scope, and
						  allows a set of statements to be executed <emphasis>until</emphasis> the
						  specified condition evaluates to true: 
						  <programlisting><emphasis role="bold">begin</emphasis>
	<emphasis role="bold">var</emphasis> LIndex := 1;
	<emphasis role="bold">repeat</emphasis>
		<emphasis role="bold">insert table</emphasis> { <emphasis role="bold">row</emphasis> { LIndex X } } <emphasis role="bold">into</emphasis> Points;
		LIndex := LIndex + 1;
	<emphasis role="bold">until</emphasis> LIndex &gt; 100;</programlisting></para> 
					 <para>The 
						  <phrase role="code"><emphasis
								role="bold">foreach</emphasis></phrase> statement is a specialized looping
						  statement that works as a shorthand for an equivalent loop to iterate over the
						  rows in a cursor, or the items in a list: 
						  <programlisting><emphasis role="bold">begin</emphasis>
	<emphasis role="bold">var</emphasis> LTotal := 0;
	<emphasis role="bold">foreach row in</emphasis> Points <emphasis role="bold">do</emphasis>
		LTotal := LTotal + X;
<emphasis role="bold">end;</emphasis></programlisting>Note that within the iteration block, the columns of the
						  current row are available by name.</para> 
					 <para>Each of these loops can of course be expressed in terms
						  of a simple while loop. D4 allows the various statements for
						  convenience.</para> 
					 <para>Within all the loops, the 
						  <phrase role="code"><emphasis
								role="bold">break</emphasis></phrase> statement may be used to unconditionally
						  terminate the loop in which the break is found, with execution resuming at the
						  first statement immediately following the loop. The 
						  <phrase role="code"><emphasis
								role="bold">continue</emphasis></phrase> statement may also be used to exit the
						  current iteration; the test condition is evaluated, and execution continues at
						  the first statement in the loop if the condition is satisfied.</para> 
					 <para>Note that a 
						  <phrase role="code"><emphasis
								role="bold">break</emphasis></phrase> or 
						  <phrase role="code"><emphasis
								role="bold">continue</emphasis></phrase> statement will
						  <emphasis>not</emphasis> skip a finally block.</para> 
				</sect2> 
		  </sect1> 
		  <sect1 id="DDGModelingProcessLogic-ExceptionHandling"> 
				<title><indexterm> 
						  <primary>Exception Handling</primary> 
						  <secondary>Process Logic and</secondary> 
					 </indexterm><indexterm> 
						  <primary>Process Logic</primary> 
						  <secondary>Exception Handling</secondary> 
					 </indexterm>Exception Handling</title> 
				<para>Exception handling statements in D4 allow for errors that may
					 occur at runtime to be handled within the program itself. D4 provides two
					 different exception handling statements: the 
					 <phrase role="code"><emphasis
						  role="bold">try..except</emphasis></phrase> statement, and the 
					 <phrase role="code"><emphasis
						  role="bold">try..finally</emphasis></phrase> statement.</para> 
				<para>Structured exception handling provides a vastly superior
					 mechanism for handling error conditions within imperative programs. Without
					 exception handling, the developer of an operator must provide some mechanism to
					 indicate to the caller that an error condition has occurred. It is then up to
					 the caller to check the return code of each invocation of an operator,
					 resulting in large amounts of error-handling code for even the most trivial of
					 operations.</para> 
				<para>In contrast, structured exception handling allows the user of
					 a particular operator to develop optimistically. In other words, code can be
					 written assuming everything will work. If necessary, an error handling block
					 can be introduced surrounding the code in question to handle any error
					 conditions without affecting the regular program logic.</para> 
				<para>Exception handling in D4 makes use of the system 
					 <phrase role="code">Error</phrase> type to provide information
					 about exceptions that occur within D4. The following program listing shows the
					 definition of this type: 
					 <programlisting>// System.Error
<emphasis role="bold">create type</emphasis> Error
{
	<emphasis role="bold">representation</emphasis> Error 
	{ 
		Severity : String,
		Code : Integer,
		Message : String,
		InnerError : Error
	}
};</programlisting></para> 
				<para>Each error value in D4 has a 
					 <phrase role="code">Severity</phrase>, a 
					 <phrase role="code">Code</phrase>, a 
					 <phrase role="code">Message</phrase>, and an 
					 <phrase role="code">InnerError</phrase>. The severity value for
					 an error is one of 
					 <phrase role="code">User</phrase>, 
					 <phrase role="code">Application</phrase>, 
					 <phrase role="code">Environment</phrase>, or 
					 <phrase role="code">System</phrase>, and indicates the relative
					 severity of the error.</para> 
				<para>Each error is also assigned a code, which is a six-digit
					 number representing both the source module of the error, as well as the
					 specific code of the error. The first three digits correspond to the source
					 module, such as the server subsystem, or the schema subsystem. For a complete
					 list of these module codes, refer to the Error Code Source Reference.<!--Reference to the error modules listing-->.
					 Application defined error codes should always be between 500000 and
					 999999.</para> 
				<para>The message for an error value contains the descriptive text
					 of the exception that occurred, and the 
					 <phrase role="code">InnerError</phrase> component provides
					 access to another 
					 <phrase role="code">Error</phrase> value that can be used to
					 nest errors as they occur. Note that the 
					 <phrase role="code">InnerError</phrase> component of an 
					 <phrase role="code">Error</phrase> will be 
					 <phrase role="code"><emphasis
						  role="bold">nil</emphasis></phrase> if no inner error is available.</para> 
				<para>The 
					 <phrase role="code"><emphasis
						  role="bold">raise</emphasis></phrase> statement is used to throw an exception
					 from a D4 program. There are two contexts in which a 
					 <phrase role="code"><emphasis
						  role="bold">raise</emphasis></phrase> can appear. First, as a raise statement,
					 the keyword is used to raise an error directly, and must be followed by an
					 expression of type 
					 <phrase role="code">Error</phrase>. This is most often an
					 invocation of the 
					 <phrase role="code">Error</phrase> selector, but does not have
					 to be.</para> 
				<para>Second, within an exception handler, the 
					 <phrase role="code"><emphasis
						  role="bold">raise</emphasis></phrase> keyword can be used stand-alone to
					 re-raise the exception being handled.</para> 
				<sect2 id="DDGModelingProcessLogic-ExceptionHandling-Try..Except"> 
					 <title>Try..Except</title> 
					 <para>The 
						  <phrase role="code"><emphasis
								role="bold">try..except</emphasis></phrase> statement is used to execute a set
						  of statements, and optionally handle any exception that is raised within those
						  statements. The 
						  <phrase role="code"><emphasis
								role="bold">except</emphasis></phrase> clause can be used in two different
						  ways. First, as a generic exception handler that traps any exception occurring.
						  The keyword 
						  <phrase role="code"><emphasis
								role="bold">raise</emphasis></phrase> can be used within the exception handler
						  portion of the statement to re-throw the exception: 
						  <programlisting><emphasis role="bold">try</emphasis>
	<emphasis role="bold">insert table</emphasis> { <emphasis role="bold">row</emphasis> { '001' ID, 'Location 001' Name } } <emphasis role="bold">into</emphasis> Location;
<emphasis role="bold">except</emphasis>
	<emphasis role="bold">update</emphasis> Location <emphasis role="bold">set</emphasis> { Name := 'Location 001' } <emphasis role="bold">where</emphasis> ID = '001';
	<emphasis role="bold">raise</emphasis>;
<emphasis role="bold">end</emphasis>;</programlisting></para> 
					 <para>Second, the 
						  <phrase role="code"><emphasis
								role="bold">except</emphasis></phrase> clause may specify a parameterized
						  handler so that the exception that occurred can be inspected within the
						  exception handler: 
						  <programlisting><emphasis role="bold">try</emphasis>
	<emphasis role="bold">insert table</emphasis> { <emphasis role="bold">row</emphasis> { '001' ID, 'Location 001' Name } } <emphasis role="bold">into</emphasis> Location;
<emphasis role="bold">except</emphasis>
	<emphasis role="bold">on</emphasis> E : Error <emphasis role="bold">do</emphasis>
	<emphasis role="bold">begin</emphasis>
		<emphasis role="bold">if</emphasis> E.Severity = 'User' <emphasis role="bold">then</emphasis>
			<emphasis role="bold">update</emphasis> Location <emphasis role="bold">set</emphasis> { Name := 'Location 001' } <emphasis role="bold">where</emphasis> ID = '001'
		<emphasis role="bold">else</emphasis>
			<emphasis role="bold">raise</emphasis> E;
	<emphasis role="bold">end</emphasis>;
<emphasis role="bold">end</emphasis>;</programlisting></para> 
				</sect2> 
				<sect2 id="DDGModelingProcessLogic-ExceptionHandling-Try..Finally">
					 
					 <title>Try..Finally</title> 
					 <para>The 
						  <phrase role="code"><emphasis
								role="bold">try..finally</emphasis></phrase> statement is used to protect a
						  given resource, ensuring that a specific block of statements will be executed
						  regardless of whether an exception is raised or not. Because this statement is
						  most often used to protect resources, it is often called a <emphasis>resource
						  protection block</emphasis>. The following example depicts the use of a 
						  <phrase role="code"><emphasis
								role="bold">try..finally</emphasis></phrase> statement: 
						  <programlisting><emphasis role="bold">begin</emphasis>
	<emphasis role="bold">var</emphasis> LCursor := <emphasis role="bold">cursor</emphasis>(BaseTableVars { Name });
	<emphasis role="bold">try</emphasis>
		...
	<emphasis role="bold">finally</emphasis>
		LCursor.Close();
	<emphasis role="bold">end</emphasis>;
<emphasis role="bold">end</emphasis>;</programlisting></para> 
				</sect2> 
		  </sect1> 
		  <sect1 id="DDGModelingProcessLogic-TransactionManagement"> 
				<title><indexterm> 
						  <primary>Transaction Management</primary> 
						  <secondary>Process Logic and</secondary> 
					 </indexterm><indexterm> 
						  <primary>Process Logic</primary> 
						  <secondary>Transaction Management</secondary> 
					 </indexterm>Transaction Management</title> 
				<para>As with any DBMS, the Dataphor Server must provide
					 transaction management services to allow applications to guarantee the
					 integrity and consistency of operations, especially in the presence of
					 concurrent access, and system failures.</para> 
				<para>To enable these capabilities, the Dataphor Server exposes two
					 different kinds of transaction management services: first, traditional
					 two-phase commit transaction management, and second, application
					 transactions.</para> 
				<para>For a complete discussion of transaction management issues,
					 refer to 
					 <ulink type="olinka"
					 url="DDGP1TransactionManagement.html">Transaction Management</ulink> in Part I
					 of this guide.</para> 
				<sect2
				id="DDGModelingProcessLogic-TransactionManagement-TransactionManagementServices">
					 
					 <title>Transaction Management Services</title> 
					 <para>The Dataphor Server exposes basic transaction management
						  services primarily through the Call-Level Interface, but the services are also
						  available within the D4 language by calling transaction management operators.
						  The following list details the available transaction management operators:<!--Change this to point to the Transaction Management operators in the System Library Reference?-->
						  <itemizedlist> 
								<listitem> 
									 <para><phrase
										  role="code">BeginTransaction()</phrase></para> 
									 <para>Begins a transaction on the current process
										  at the default isolation level for the process.</para> 
								</listitem> 
								<listitem> 
									 <para><phrase role="code">BeginTransaction(const
												AIsolationLevel : String)</phrase></para> 
									 <para>Begins a transaction on the current process
										  at the specified isolation level.</para> 
								</listitem> 
								<listitem> 
									 <para><phrase
										  role="code">PrepareTransaction()</phrase></para> 
									 <para>Prepares the current transaction for commit
										  by checking all deferred integrity constraints and invoking all deferred event
										  handlers. This call will be invoked internally if not called prior to
										  transaction commit. It is only exposed to allow the Dataphor Server to
										  participate in two-phase commit distributed transactions.</para> 
								</listitem> 
								<listitem> 
									 <para><phrase
										  role="code">CommitTransaction()</phrase></para> 
									 <para>Prepares the current transaction if
										  necessary, and commits it.</para> 
								</listitem> 
								<listitem> 
									 <para><phrase
										  role="code">RollbackTransaction()</phrase></para> 
									 <para>Rolls back the current transaction, undoing
										  any data modifications that were performed during the transaction.</para> 
								</listitem> 
								<listitem> 
									 <para><phrase
										  role="code">InTransaction()</phrase></para> 
									 <para>Indicates whether or not the current process
										  is participating in any transactions.</para> 
								</listitem> 
								<listitem> 
									 <para><phrase
										  role="code">TransactionCount()</phrase></para> 
									 <para>Returns the number of transactions currently
										  active on the current process.</para> 
								</listitem> 
						  </itemizedlist></para> 
					 <para>After calling 
						  <phrase role="code">BeginTransaction()</phrase>, the number
						  of active transactions on the current process is increased by one. If a
						  transaction is already in progress on the current process, this transaction is
						  a <emphasis>nested transaction</emphasis>. Transactions can be nested to any
						  degree, even if the target systems with which the Dataphor Server is
						  communicating do not support nested transactions. In this case, the Dataphor
						  Server will take over logging the nested transactions, while still taking
						  advantage of the transaction management capabilities of the target system for
						  the outer most transaction.</para> 
					 <para>After calling 
						  <phrase role="code">CommitTransaction()</phrase> or 
						  <phrase role="code">RollbackTransaction()</phrase>, the
						  number of active transactions on the current process is decreased by one. Note
						  that the scope of each transaction is the current process, and that, in
						  general, multiple processes may be running for a single session.</para> 
					 <para>In addition to explicit transaction management, the
						  Dataphor Server will implicitly manage transaction for calls crossing the CLI
						  boundary. This is called Transactional Call Protocol, and effectively ensures
						  that any call into the Dataphor Server is protected by a transaction. If the
						  call succeeds, the implicit transaction is committed. If an error occurs, the
						  implicit transaction is rolled back, and the error is returned to the caller.
						  This behavior can be controlled with the 
						  <phrase role="code">UseImplicitTransactions</phrase>
						  setting either through the CLI, or by updating the 
						  <phrase role="code">System.Processes</phrase> table
						  directly.</para> 
					 <para>Because the Dataphor Server may be communicating with
						  multiple devices on behalf of the current process, each of these devices must
						  be enlisted in the transaction. This is called a <emphasis>distributed
						  transaction</emphasis> and is either coordinated by the Dataphor Server, or
						  managed by the Microsoft Distributed Transaction Coordinator, depending on the
						  value of the 
						  <phrase role="code">UseDTC</phrase> setting for the current
						  process. This setting may be changed through the CLI, or by updating the 
						  <phrase role="code">System.Processes</phrase> table
						  directly.</para> 
					 <para>Because transaction management is such an integral part
						  of any application, the D4 language provides the 
						  <phrase role="code"><emphasis
								role="bold">try..commit</emphasis></phrase> statement as a convenient shorthand
						  for protecting operations with transactions and structured exception handling.
						  The following example depicts a typical use of this statement: 
						  <programlisting><emphasis role="bold">try</emphasis>
	ProcessInvoices();
<emphasis role="bold">commit</emphasis>;</programlisting></para> 
					 <para>This statement is equivalent to the following sequence of
						  statements: 
						  <programlisting><emphasis role="bold">begin</emphasis>
	BeginTransaction();
	<emphasis role="bold">try</emphasis>
		ProcessInvoices();
		CommitTransaction();
	<emphasis role="bold">except</emphasis>
		RollbackTransaction();
		<emphasis role="bold">raise</emphasis>;
	<emphasis role="bold">end</emphasis>;
<emphasis role="bold">end</emphasis>;</programlisting></para> 
				</sect2> 
				<sect2
				id="DDGModelingProcessLogic-TransactionManagement-ApplicationTransactionManagement">
					 
					 <title><indexterm> 
								<primary>Application Transactions</primary> 
						  </indexterm><indexterm> 
								<primary>Transaction Management</primary> 
								<secondary>Application Transactions</secondary> 
						  </indexterm>Application Transaction Management</title> 
					 <para>In addition to traditional transaction management, the
						  Dataphor Server exposes an application-targeted capability called
						  <emphasis>application transactions</emphasis>. Essentially, these are
						  long-running, optimistically concurrent transactions that are used by Dataphor
						  Frontend Clients to enable data entry in the presence of the business rules
						  being enforced on the server. For a complete discussion of application
						  transactions, refer to 
						  <ulink type="olinka"
						  url="DDGTheSpaceBetweentheData-ApplicationTransactions.html">Application
								Transactions</ulink> in the Presentation Layer part of this guide.</para> 
				</sect2> 
		  </sect1> 
		  <sect1 id="DDGModelingProcessLogic-Characteristics"> 
				<title><indexterm> 
						  <primary>Characteristics</primary> 
					 </indexterm><indexterm> 
						  <primary>Process Logic</primary> 
						  <secondary>Characteristics</secondary> 
					 </indexterm>Characteristics</title> 
				<para>Every expression and operator within the D4 language has
					 various characteristics that are inferred by the compiler. These
					 characteristics govern the contexts in which a given expression or operator may
					 be used, and help the optimizer perform expression transformations and make
					 distributed query processing decisions. The following list itemizes these
					 characteristics: 
					 <itemizedlist> 
						  <listitem> 
								<para>Literal</para> 
						  </listitem> 
						  <listitem> 
								<para>Remotable</para> 
						  </listitem> 
						  <listitem> 
								<para>Functional</para> 
						  </listitem> 
						  <listitem> 
								<para>Deterministic</para> 
						  </listitem> 
						  <listitem> 
								<para>Repeatable</para> 
						  </listitem> 
						  <listitem> 
								<para>Nilable</para> 
						  </listitem> 
						  <listitem> 
								<para>Context Literal</para> 
						  </listitem> 
						  <listitem> 
								<para>Order Preserving</para> 
						  </listitem> 
					 </itemizedlist></para> 
				<para>The following sections discuss each of these characteristics
					 in detail.</para> 
				<sect2 id="DDGModelingProcessLogic-Characteristics-Literal"> 
					 <title><indexterm> 
								<primary>Literal</primary> 
						  </indexterm><indexterm> 
								<primary>Characteristics</primary> 
								<secondary>Literal</secondary> 
						  </indexterm>Literal</title> 
					 <para>Broadly speaking, a literal expression in D4 is one that
						  can be evaluated at compile-time with the same results as an evaluation at
						  run-time. For example, the integer literal 
						  <phrase role="code">5</phrase> will always result in the
						  integer value 
						  <phrase role="code">5</phrase>. Clearly, any expression
						  that references a variable, regardless of scope, is not literal.</para> 
					 <para>An operator is considered literal if it makes no
						  reference to global state. An operator invocation is literal if the operator is
						  literal and all the arguments to the operator are literal. Of course, this
						  definition applies recursively, meaning that literal expressions are allowed to
						  be arbitrarily complex, so long as they do not reference any variables.</para> 
					 <para>Note that a local variable reference within an operator
						  does not mean the operator is not literal, only a global variable reference
						  will make an operator non-literal. For example, the following operator is
						  literal: 
						  <programlisting><emphasis role="bold">create operator</emphasis> LiteralOperator(<emphasis role="bold">const</emphasis> AInteger : Integer) : Integer
<emphasis role="bold">begin</emphasis>
	<emphasis role="bold">var</emphasis> LValue := AInteger * 2;
	<emphasis role="bold">result</emphasis> := LValue;
<emphasis role="bold">end</emphasis>;</programlisting>However, the following operator references a global table
						  variable, and is therefore not literal: 
						  <programlisting><emphasis role="bold">create operator</emphasis> NonLiteralOperator() : Integer
<emphasis role="bold">begin</emphasis>
	<emphasis role="bold">result</emphasis> := Count(TableVars);
<emphasis role="bold">end</emphasis>;</programlisting></para> 
					 <para>The optimizer uses the literal characteristic to
						  determine whether or not it can evaluate a given branch of an expression, and
						  examine the result at compile-time for use in determining access paths, or for
						  parameterization during distributed query processing.</para> 
					 <para>The following examples illustrate various literal and
						  non-literal expressions: 
						  <programlisting>// literal 
// Integer selector invocation
5;
 
// non-literal 
// invocation of non-literal operator DateTime()
DateTime(); 

// literal 
// DateTime selector invocation with literal arguments
Date(2004, 10, 20);</programlisting></para> 
				</sect2> 
				<sect2 id="DDGModelingProcessLogic-Characteristics-Remotable"> 
					 <title><indexterm> 
								<primary>Remotable</primary> 
						  </indexterm><indexterm> 
								<primary>Characteristics</primary> 
								<secondary>Remotable</secondary> 
						  </indexterm>Remotable</title> 
					 <para>The remotable characteristic allows the compiler to
						  distinguish between objects and statements that reference global state (objects
						  in the database), and ones that do not. Basically, an object or statement is
						  remotable if it can be executed or evaluated without accessing any objects in
						  the global catalog. Note that remotability is a characteristic not only of
						  expressions and operator but of all catalog objects.</para> 
					 <para>The compiler uses the remotable characteristic to
						  determine whether a particular operator invocation could take place within the
						  presentation layer without accessing data on the server. This is used in the
						  proposable interfaces to allow defaults, constraints, and other rules to be
						  enforced by the presentation layer.</para> 
					 <para>When the presentation layer opens a data entry form for a
						  table variable, for example, the first proposable call is the 
						  <phrase role="code">Default</phrase> call, which determines
						  the default values for each column in the new row. If the default definitions
						  are remotable, they are downloaded to the Frontend client as part of the
						  structure of the result set and evaluated there without the need for an
						  additional network round-trip.</para> 
				</sect2> 
				<sect2 id="DDGModelingProcessLogic-Characteristics-Functional"> 
					 <title><indexterm> 
								<primary>Functional</primary> 
						  </indexterm><indexterm> 
								<primary>Characteristics</primary> 
								<secondary>Functional</secondary> 
						  </indexterm>Functional</title> 
					 <para>The functional characteristic indicates whether an
						  operator or expression has changed global state, usually by executing a data
						  modification statement.</para> 
					 <para>Certain contexts such as constraint definitions require
						  functional expressions. This guarantees that the act of validating a constraint
						  will not change the state of the database.</para> 
					 <para>An operator is functional if it does not change global
						  state. In other words, an operator that changes data in the database, such as a
						  call to 
						  <phrase role="code">GetNextGenerator()</phrase>, is not
						  functional. An expression is functional if it does not contain any invocations
						  of non-functional operators.</para> 
				</sect2> 
				<sect2 id="DDGModelingProcessLogic-Characteristics-Deterministic"> 
					 <title><indexterm> 
								<primary>Deterministic</primary> 
						  </indexterm><indexterm> 
								<primary>Characteristics</primary> 
								<secondary>Deterministic</secondary> 
						  </indexterm>Deterministic</title> 
					 <para>The deterministic characteristic indicates whether
						  successive evaluations of the expression will result in the same value.</para> 
					 <para>Certain contexts such as constraint definitions require
						  deterministic expressions. This guarantees that once a constraint expression
						  has been validated, it will be valid so long as the input remains the
						  same.</para> 
					 <para>An operator is deterministic if it does not contain any
						  invocations of non-deterministic operators. Likewise, an expression is
						  deterministic if does not contain any invocations of non-deterministic
						  operators.</para> 
				</sect2> 
				<sect2 id="DDGModelingProcessLogic-Characteristics-Repeatable"> 
					 <title><indexterm> 
								<primary>Repeatable</primary> 
						  </indexterm><indexterm> 
								<primary>Characteristics</primary> 
								<secondary>Repeatable</secondary> 
						  </indexterm>Repeatable</title> 
					 <para>The repeatable characteristic indicates whether
						  successive evaluations of the expression within the same transactional context
						  will result in the same value. Repeatable is a stronger notion than
						  deterministic in that a given expression may be non-deterministic but
						  repeatable.</para> 
					 <para>For example, 
						  <phrase role="code">DateTime()</phrase> is
						  non-deterministic, but it is repeatable because successive invocations within
						  the same transactional context will return the same value, namely the start
						  time of the transaction. 
						  <phrase role="code">GetNextGenerator()</phrase>, however,
						  is not repeatable. Every invocation of the operator, regardless of
						  transactional context will return a different value.</para> 
					 <para>Clearly, if an expression is deterministic, it is by
						  definition repeatable.</para> 
					 <para>The repeatable characteristic is used by the compiler to
						  ensure that operations such as restriction are well-defined, and by the
						  optimizer to make distributed query processing decisions.</para> 
					 <para>An operator is repeatable if it does not contain any
						  invocations of non-repeatable operators. Likewise, an expression is repeatable
						  if it does not contain any invocations of non-repeatable operators.</para> 
				</sect2> 
				<sect2 id="DDGModelingProcessLogic-Characteristics-Nilable"> 
					 <title><indexterm> 
								<primary>Nilable</primary> 
						  </indexterm><indexterm> 
								<primary>Characteristics</primary> 
								<secondary>Nilable</secondary> 
						  </indexterm>Nilable</title> 
					 <para>The nilable characteristic indicates whether a given
						  expression or operator could evaluate to nil. Some expressions are nilable by
						  definition, for example the 
						  <phrase role="code"><emphasis
								role="bold">nil</emphasis></phrase> keyword will always evaluate to nil, and is
						  therefore nilable.</para> 
					 <para>Other expressions are nilable based on schema
						  definitions. For example, referencing a column of a row within a table is
						  nilable if the definition of that column is nilable.</para> 
					 <para>In general, an operator invocation is nilable if any of
						  its arguments are nilable. For example, the following invocation of 
						  <phrase role="code">+</phrase> is non-nilable: 
						  <programlisting>1 + 1;</programlisting>This is because the expressions involved are not nilable,
						  therefore the result could not be nil. The following addition expression,
						  however, is nilable: 
						  <programlisting><emphasis role="bold">begin</emphasis>
	<emphasis role="bold">var</emphasis> LX := <emphasis role="bold">nil</emphasis>;
	<emphasis role="bold">var</emphasis> LY := 2;
	LX + LY;
<emphasis role="bold">end</emphasis>;</programlisting>This is because the expressions involved in the addition are
						  variable references, which could contain a nil at run-time. The compiler
						  therefore infers that the result of the addition could be nil.</para> 
					 <para>Some expressions are non-nilable by definition, for
						  example the 
						  <phrase role="code">IsNil</phrase> operator will always
						  return 
						  <phrase role="code"><emphasis
								role="bold">true</emphasis></phrase>, or 
						  <phrase role="code"><emphasis
								role="bold">false</emphasis></phrase>, regardless of whether its arguments are
						  nil.</para> 
					 <para>The nilable characteristic is used by the compiler and
						  the query processor to perform various optimizations, and by the optimizer to
						  determine whether given expression transformations are valid.</para> 
				</sect2> 
				<sect2
				id="DDGModelingProcessLogic-Characteristics-Order-Preserving"> 
					 <title><indexterm> 
								<primary>Order-Preserving</primary> 
						  </indexterm><indexterm> 
								<primary>Characteristics</primary> 
								<secondary>Order-Preserving</secondary> 
						  </indexterm>Order-Preserving</title> 
					 <para>The order-preserving characteristic indicates whether a
						  given operator preserves the order semantics of its arguments. For example,
						  conversion from a 
						  <phrase role="code">Byte</phrase> to an 
						  <phrase role="code">Integer</phrase> is an order-preserving
						  operation.</para> 
					 <para>The order-preserving characteristic is used by the
						  compiler to determine whether or not a given expression affects the use of a
						  particular ordering during access path determination.</para> 
				</sect2> 
				<sect2
				id="DDGModelingProcessLogic-Characteristics-OverridingInferredCharacteristics">
					 
					 <title><indexterm> 
								<primary>Overriding Inferred Characteristics</primary> 
						  </indexterm><indexterm> 
								<primary>Characteristics</primary> 
								<secondary>Overriding Inferred
									 Characteristics</secondary> 
						  </indexterm>Overriding Inferred Characteristics</title> 
					 <para>In some cases, such as dynamic execution, it is not
						  possible for the compiler to determine at compile-time the characteristics of a
						  given expression or operator. In these cases, language modifiers can be used to
						  override the inferred characteristics. Note that these should be used with
						  extreme care, as incorrectly specifying the characteristics of an expression
						  can lead to invalid optimization decisions by the compiler.</para> 
					 <para><indexterm> 
								<primary>Language Modifiers</primary> 
								<secondary>Characteristic Modifiers</secondary> 
						  </indexterm>The following table lists the language
						  modifiers available for overriding characteristics within expressions: 
						  <informaltable> 
								<tgroup cols="2">
									 <colspec colname="col1" colnum="1" colwidth="*"/>
									 <colspec colname="col2" colnum="2" colwidth="*"/> 
									 <thead> 
										  <row> 
												<entry colname="col1">Modifier</entry> 
												<entry colname="col2">Description</entry> 
										  </row> 
									 </thead> 
									 <tbody> 
										  <row> 
												<entry colname="col1"><phrase
													 role="code">IsLiteral</phrase></entry> 
												<entry colname="col2">Overrides the
													 inferred literal characteristic for the expression.</entry> 
										  </row> 
										  <row> 
												<entry colname="col1"><phrase
													 role="code">IsFunctional</phrase></entry> 
												<entry colname="col2">Overrides the
													 inferred functional characteristic for the expression.</entry> 
										  </row> 
										  <row> 
												<entry colname="col1"><phrase
													 role="code">IsDeterministic</phrase></entry> 
												<entry colname="col2">Overrides the
													 inferred deterministic characteristic for the expression.</entry> 
										  </row> 
										  <row> 
												<entry colname="col1"><phrase
													 role="code">IsRepeatable</phrase></entry> 
												<entry colname="col2">Overrides the
													 inferred repeatable characteristic for the expression.</entry> 
										  </row> 
										  <row> 
												<entry colname="col1"><phrase
													 role="code">IsNilable</phrase></entry> 
												<entry colname="col2">Overrides the
													 inferred nilable characteristic for the expression.</entry> 
										  </row> 
									 </tbody> 
								</tgroup> 
						  </informaltable></para> 
					 <para>In addition to the ability to override the inferred
						  characteristics for an expression, the inferred characteristics for an operator
						  can be overridden using metadata tags. The following table lists tags available
						  for overriding operator characteristics: 
						  <informaltable> 
								<tgroup cols="2">
									 <colspec colname="col1" colnum="1" colwidth="*"/>
									 <colspec colname="col2" colnum="2" colwidth="*"/> 
									 <thead> 
										  <row> 
												<entry colname="col1">Tag</entry> 
												<entry colname="col2">Description</entry> 
										  </row> 
									 </thead> 
									 <tbody> 
										  <row> 
												<entry colname="col1"><phrase
													 role="code">DAE.IsRemotable</phrase></entry> 
												<entry colname="col2">Overrides the
													 inferred remotable characteristic for the operator.</entry> 
										  </row> 
										  <row> 
												<entry colname="col1"><phrase
													 role="code">DAE.IsLiteral</phrase></entry> 
												<entry colname="col2">Overrides the
													 inferred literal characteristic for the operator.</entry> 
										  </row> 
										  <row> 
												<entry colname="col1"><phrase
													 role="code">DAE.IsFunctional</phrase></entry> 
												<entry colname="col2">Overrides the
													 inferred functional characteristic for the operator.</entry> 
										  </row> 
										  <row> 
												<entry colname="col1"><phrase
													 role="code">DAE.IsDeterministic</phrase></entry> 
												<entry colname="col2">Overrides the
													 inferred deterministic characteristic for the operator.</entry> 
										  </row> 
										  <row> 
												<entry colname="col1"><phrase
													 role="code">DAE.IsRepeatable</phrase></entry> 
												<entry colname="col2">Overrides the
													 inferred repeatable characteristic for the operator.</entry> 
										  </row> 
										  <row> 
												<entry colname="col1"><phrase
													 role="code">DAE.IsNilable</phrase></entry> 
												<entry colname="col2">Overrides the
													 inferred nilable characteristic for the operator.</entry> 
										  </row> 
										  <row> 
												<entry colname="col1"><phrase
													 role="code">DAE.IsOrderPreserving</phrase></entry> 
												<entry colname="col2">Overrides the
													 inferred order-preserving characteristic for the operator.</entry> 
										  </row> 
									 </tbody> 
								</tgroup> 
						  </informaltable></para> 
					 <para>The following example illustrates the use of language
						  modifiers to set the characteristics of a dynamically evaluated expression: 
						  <programlisting><emphasis role="bold">create operator</emphasis> CurrentLocationID() : LocationID
<emphasis role="bold">begin</emphasis>
	<emphasis role="bold">result</emphasis> := 
		(
			Evaluate('CurrentLocation[].Location_ID')
				<emphasis role="bold">with</emphasis> 
				{
					IsFunctional = "true", 
					IsDeterministic = "true", 
					IsRepeatable = "true" 
				}
		)
			<emphasis role="bold">as</emphasis> LocationID;
<emphasis role="bold">end</emphasis>;</programlisting></para> 
					 <para>Note that for dynamic evaluation, the query processor
						  will verify that the characteristics of the dynamic expression match the
						  characteristics specified using the modifiers. In fact, this example is
						  somewhat contrived, because the default characteristics for dynamically
						  evaluated expressions are assumed to be: non-literal, functional,
						  deterministic, repeatable, and nilable. For dynamic execution, however, the
						  compiler assumes non-literal, non-functional, non-deterministic,
						  non-repeatable, and non-remotable, and the characteristic overrides will not be
						  verified at run-time.</para> 
					 <para>The following example depicts the use of a characteristic
						  override to allow the creation of a positive time-based constraint: 
						  <programlisting><emphasis role="bold">alter table</emphasis> Contact
{
	<emphasis role="bold">alter column</emphasis> NameSince 
	{ 
		<emphasis role="bold">create constraint</emphasis> IsValid 
			<emphasis role="bold">value</emphasis> &lt;= (DateTime() <emphasis role="bold">with</emphasis> { IsDeterministic = "true" }) 
	}
};</programlisting>Without the modifier, the compiler will disallow the creation
						  of this constraint because it involves an invocation of the non-deterministic
						  operator 
						  <phrase role="code">DateTime()</phrase>. However, because
						  the value is required to be less than or equal to the current date and time (an
						  ever-increasing value), we can safely inform the compiler that once this
						  expression evaluates to true for a given value, it will be true from that time
						  forward. Note that the opposite formulation of this constraint (<phrase
						  role="code"><emphasis role="bold">value</emphasis> &gt;= DateTime()</phrase>)
						  is not valid, because at some point, the constraint will be violated by data
						  that has already passed validation of the constraint 
						  <footnote> 
								<para>As an aside, we note that changing the value of
									 the system clock to a date and time prior to the date and time of some existing
									 row would also have the affect of invalidating previously validated data.
									 However, this is something outside the control of the system and falls more in
									 the category of outside tampering than logical constraint enforcement. For
									 example, one could just as easily rearrange bits on the physical drive without
									 the knowledge of the system in order to produce a violation of previously
									 validated data.</para> 
						  </footnote>.</para> 
					 <para>For more information on dynamic execution, see the 
						  <ulink type="olinka"
						  url="D4LGProgrammingTopics-DynamicExecution.html">Dynamic Execution</ulink>
						  section.</para> 
				</sect2> 
		  </sect1> 
		  <sect1 id="D4LGProgrammingTopics-DynamicExecution"> 
				<title><indexterm> 
						  <primary>Dynamic Execution</primary> 
					 </indexterm><indexterm> 
						  <primary>Process Logic</primary> 
						  <secondary>Dynamic Execution</secondary> 
					 </indexterm>Dynamic Execution</title> 
				<para>The Dataphor Server has system-provided operators which allow
					 for the dynamic execution of D4 statements. The 
					 <phrase role="code"><ulink type="olinka"
						  url="O-System.Execute.html">Execute</ulink></phrase> operator allows a given
					 statement to be executed, the 
					 <ulink type="olinka" url="O-System.Evaluate.html"><phrase
						  role="code">Evaluate</phrase></ulink> operator allows a given expression to be
					 evaluated, while the 
					 <phrase role="code"><ulink type="olinka"
						  url="O-System.Open.html">Open</ulink></phrase> operator allows a dynamic cursor
					 to be declared and opened. The following example illustrates the use of these
					 operators: 
					 <programlisting><emphasis role="bold">create table</emphasis> Data { ID : Integer, <emphasis role="bold">key</emphasis> { ID } };

<emphasis role="bold">begin</emphasis>
	<emphasis role="bold">var</emphasis> LData : Integer := 10;
	Execute("insert table { row { " + LData.ToString() + " ID } } into Data;");
<emphasis role="bold">end</emphasis>;

<emphasis role="bold">select</emphasis> Evaluate('Data[10].ID') <emphasis role="bold">as</emphasis> Integer;

<emphasis role="bold">begin</emphasis>
	<emphasis role="bold">var</emphasis> LSum : Integer := 0;
	<emphasis role="bold">var</emphasis> LCursor : <emphasis role="bold">cursor</emphasis>(<emphasis role="bold">table</emphasis> { ID : Integer }) := 
		Open("Data") <emphasis role="bold">as</emphasis> <emphasis role="bold">cursor</emphasis>(<emphasis role="bold">table</emphasis> { ID : Integer });
	<emphasis role="bold">try</emphasis>
		<emphasis role="bold">while</emphasis> LCursor.Next() <emphasis role="bold">do</emphasis>
			LSum := LSum + LCursor.Select().ID;
	<emphasis role="bold">finally</emphasis>
		LCursor.Close();
	<emphasis role="bold">end</emphasis>;
<emphasis role="bold">end</emphasis>;</programlisting></para> 
				<para>Note that when dynamically executing and evaluating D4, the
					 inference mechanisms of the compiler do not occur until runtime. As a result,
					 the Dataphor Server cannot determine the actual characteristics of a given
					 statement or expression. For a discussion of how to override these
					 characteristics at compiler-time, refer to the 
					 <ulink type="olinka"
					 url="D4LGProgrammingTopics-DynamicExecution.html">Dynamic Execution</ulink>
					 section.</para> 
		  </sect1> 
		  <sect1 id="DDGModelingProcessLogic-Session-SpecificObjects"> 
				<title><indexterm> 
						  <primary>Session-Specific Objects</primary> 
					 </indexterm><indexterm> 
						  <primary>Process Logic</primary> 
						  <secondary>Session-Specific Objects</secondary> 
					 </indexterm>Session-Specific Objects</title> 
				<para>In addition to the global catalog, the Dataphor Server allows
					 for session-specific objects to be created. These objects are visible only
					 within the session in which they were created, and are automatically dropped
					 when the session closes.</para> 
				<para>The Dataphor Server allows for the creation of
					 session-specific table variables, both base and derived, operators, and
					 constraints, including references. Because the lifetime of these objects is
					 limited to the current session, global catalog objects cannot reference
					 session-specific catalog objects, but session-specific catalog objects can
					 reference global objects.</para> 
				<para>Other than the restrictions on dependencies mentioned above,
					 session-specific objects behave exactly like their global counterparts. They
					 can be used as seeds for user-interface derivation in the Frontend, and they
					 can participate in application transactions, just like global objects.</para> 
				<para>To create a session-specific object, simply include the 
					 <phrase role="code"><emphasis
						  role="bold">session</emphasis></phrase> keyword as part of the create
					 statement. For example, the following statements create a session-specific
					 table, and a session-specific reference from that table to the 
					 <phrase role="code">Location</phrase> table: 
					 <programlisting><emphasis role="bold">create session table</emphasis> CurrentLocation 
{ 
	Location_ID : LocationID, 
	<emphasis role="bold">key</emphasis> { } 
};

<emphasis role="bold">create session reference</emphasis> CurrentLocation_Location 
	CurrentLocation { Location_ID } 
	<emphasis role="bold">references</emphasis> Location { ID }
	<emphasis role="bold">tags</emphasis> { Frontend.Lookup.Title = "Current Location" };</programlisting>Note that the default storage device for session-specific
					 tables is always the in-memory system device 
					 <phrase role="code">Temp</phrase>.</para> 
				<para>The Shipping application uses the 
					 <phrase role="code">CurrentLocation</phrase> session table to
					 track which location a user is currently logged into. When creating an invoice,
					 this location will be used as the location for the invoice.</para> 
				<para>In order to retrieve the current location, the following
					 operator is used: 
					 <programlisting>//* Operator: CurrentLocationID()
<emphasis role="bold">create operator</emphasis> CurrentLocationID() : LocationID
<emphasis role="bold">begin</emphasis>
	<emphasis role="bold">result</emphasis> := 
			Evaluate('CurrentLocation[].Location_ID')
			<emphasis role="bold">as</emphasis> LocationID;
<emphasis role="bold">end</emphasis>;</programlisting></para> 
				<para>Because the 
					 <phrase role="code">CurrentLocationID()</phrase> operator is a
					 global catalog object, the compiler will not allow it to reference the 
					 <phrase role="code">CurrentLocation</phrase> session table. As
					 a result, we must use dynamic evaluation to retrieve the current location for
					 the current session.</para> 
				<para>The declared result type of the 
					 <phrase role="code">Evaluate</phrase> call is 
					 <phrase role="code"><emphasis
						  role="bold">generic</emphasis></phrase>, because the compiler has no way of
					 determining at compile-time the result type of a dynamically evaluated
					 expression. We must therefore <emphasis>cast</emphasis> the resulting value as
					 the type we know it will be using the 
					 <phrase role="code"><emphasis
						  role="bold">as</emphasis></phrase> operator.</para> 
				<para>This operator can then be used to construct the views and
					 operators for the order entry user-interfaces. For a continued discussion of
					 these interfaces, refer to 
					 <ulink type="olinka"
					 url="DDGPuttingItAllTogether-InvoiceManagement.html">Invoice Management</ulink>
					 in the Presentation Layer part of this guide.</para> 
		  </sect1> 
		  <sect1 id="DDGModelingProcessLogic-InvoiceProcessingExample"> 
				<title><indexterm> 
						  <primary>Invoice Processing Example</primary> 
					 </indexterm><indexterm> 
						  <primary>Process Logic</primary> 
						  <secondary>Invoice Processing Example</secondary> 
					 </indexterm>Invoice Processing Example</title> 
				<para>As with any inventory management system, the Shipping
					 Application must maintain current inventory levels at each location in response
					 to sales and purchase orders, and shipping and receiving events. This is
					 handled in the Shipping Application with a series of operators and event
					 handlers. This section describes each of these operators, and how they are
					 exposed in the application.</para> 
				<para>The first operator, 
					 <phrase role="code">UpdateInventory</phrase>, is responsible
					 for updating the various inventory level indicators at a particular location.
					 The following program listing provides the definition of this operator: 
					 <programlisting><emphasis role="bold">create operator</emphasis> UpdateInventory
(
	<emphasis role="bold">const</emphasis> ALocationID : LocationID, 
	<emphasis role="bold">const</emphasis> AItemTypeID : ItemTypeID, 
	<emphasis role="bold">const</emphasis> ADeltaOnHand : Decimal, 
	<emphasis role="bold">const</emphasis> ADeltaOnPurchase : Decimal, 
	<emphasis role="bold">const</emphasis> ADeltaOnOrder : Decimal
)
<emphasis role="bold">begin</emphasis>
	<emphasis role="bold">if exists</emphasis> 
		(
			LocationItem 
				<emphasis role="bold">where</emphasis> Location_ID = ALocationID 
					<emphasis role="bold">and</emphasis> ItemType_ID = AItemTypeID
		) <emphasis role="bold">then</emphasis>
	<emphasis role="bold">begin</emphasis>
		<emphasis role="bold">update</emphasis> LocationItem
			<emphasis role="bold">set</emphasis>
			{
				OnHand := OnHand + ADeltaOnHand,
				OnPurchase := OnPurchase + ADeltaOnPurchase,
				OnOrder := OnOrder + ADeltaOnOrder
			}
			<emphasis role="bold">where</emphasis> Location_ID = ALocationID
				<emphasis role="bold">and</emphasis> ItemType_ID = AItemTypeID;
	<emphasis role="bold">end</emphasis>
	<emphasis role="bold">else</emphasis>
	<emphasis role="bold">begin</emphasis>
		<emphasis role="bold">insert</emphasis>
			<emphasis role="bold">table</emphasis>
			{
				<emphasis role="bold">row</emphasis>
				{
					ALocationID Location_ID,
					AItemTypeID ItemType_ID,
					ADeltaOnHand OnHand,
					ADeltaOnPurchase OnPurchase,
					ADeltaOnOrder OnOrder
				}
			}
			<emphasis role="bold">into</emphasis> LocationItem;
	<emphasis role="bold">end</emphasis>;
<emphasis role="bold">end</emphasis>;</programlisting>This operator simply updates the 
					 <phrase role="code">OnHand</phrase>, 
					 <phrase role="code">OnPurchase</phrase>, and 
					 <phrase role="code">OnOrder</phrase> levels for a given
					 location (<phrase role="code">ALocationID</phrase>) and a given item type
					 (<phrase role="code">AItemTypeID</phrase>). The creation of this operator
					 dramatically simplifies the expression of the next operator, 
					 <phrase role="code">UpdateInvoice</phrase>: 
					 <programlisting>//* Operator: UpdateInvoice
create operator UpdateInvoice
(
	<emphasis role="bold">const</emphasis> AOldRow : <emphasis role="bold">typeof</emphasis>(Invoice[]),
	<emphasis role="bold">const</emphasis> ANewRow : <emphasis role="bold">typeof</emphasis>(Invoice[])
)
<emphasis role="bold">begin</emphasis>
	<emphasis role="bold">if</emphasis> AOldRow.Status_ID &lt;&gt; ANewRow.Status_ID <emphasis role="bold">then</emphasis>
	<emphasis role="bold">begin</emphasis>
		<emphasis role="bold">var</emphasis> LRow : <emphasis role="bold">typeof</emphasis>(InvoiceItem[]);
		<emphasis role="bold">var</emphasis> LIsPurchase := 
			<emphasis role="bold">exists</emphasis> (PurchaseOrder <emphasis role="bold">where</emphasis> ID = ANewRow.ID);
		<emphasis role="bold">var</emphasis> LIsComplete := ANewRow.Status_ID = "COM";
		
		<emphasis role="bold">var</emphasis> LQuantity : Decimal;
		<emphasis role="bold">var</emphasis> LCursor := 
			<emphasis role="bold">cursor</emphasis>
			(
				InvoiceItem <emphasis role="bold">
					where</emphasis> Invoice_ID = ANewRow.ID
			);
		<emphasis role="bold">try</emphasis>
			<emphasis role="bold">while</emphasis> LCursor.Next() <emphasis role="bold">do</emphasis>
			<emphasis role="bold">begin</emphasis>
				LRow := LCursor.Select();
				LQuantity := LRow.Quantity;
				
				<emphasis role="bold">if</emphasis> LIsComplete <emphasis role="bold">then</emphasis>
				<emphasis role="bold">begin</emphasis>
					<emphasis role="bold">if</emphasis> LIsPurchase <emphasis role="bold">then</emphasis>
						// if this is a purchase order, 
						// add LQuantity to OnHand, 
						// and subtract it from OnPurchase
						UpdateInventory
						(
							ANewRow.Location_ID, 
							LRow.ItemType_ID, 
							LQuantity, 
							-LQuantity, 
							0
						)
					<emphasis role="bold">else</emphasis>
						// if this is a sales order, 
						// subtract LQuantity from OnHand, 
						// and subtract it from OnOrder
						UpdateInventory
						(
							ANewRow.Location_ID, 
							LRow.ItemType_ID, 
							-LQuantity, 
							0, 
							-LQuantity
						);
				<emphasis role="bold">end</emphasis>
				<emphasis role="bold">else</emphasis>
				<emphasis role="bold">begin</emphasis>
					<emphasis role="bold">if</emphasis> LIsPurchase <emphasis role="bold">then</emphasis>
						// If this is a purchase order, 
						// add LQuantity to OnPurchase
						UpdateInventory
						(
							ANewRow.Location_ID, 
							LRow.ItemType_ID, 
							0, 
							LQuantity, 
							0
						)
					<emphasis role="bold">else</emphasis>
						// If this is a sales order, 
						// add LQuantity to OnOrder
						UpdateInventory
						(
							ANewRow.Location_ID, 
							LRow.ItemType_ID, 
							0, 
							0, 
							LQuantity
						);
				<emphasis role="bold">end</emphasis>;
			<emphasis role="bold">end</emphasis>;
		<emphasis role="bold">finally</emphasis>
			LCursor.Close();
		<emphasis role="bold">end</emphasis>;
	<emphasis role="bold">end</emphasis>;
<emphasis role="bold">end</emphasis>;
<emphasis role="bold">attach operator</emphasis> UpdateInvoice 
	<emphasis role="bold">to</emphasis> Invoice <emphasis role="bold">on after update</emphasis>;</programlisting>This operator is attached as an event handler to the 
					 <phrase role="code">Invoice</phrase> table. It responds to
					 changes in the 
					 <phrase role="code">Status_ID</phrase> of the invoice by
					 updating inventory levels at each location as appropriate. The status of an
					 invoice can be one of 
					 <phrase role="code">NEW</phrase>, 
					 <phrase role="code">PRO</phrase>, or 
					 <phrase role="code">COM</phrase> (new, processed or complete).
					 In addition, there is a transaction constraint in the 
					 <phrase role="code">Invoice</phrase> table that prevents the
					 status from moving backwards. The status of an invoice may only move from new
					 to processed, to complete. These statuses correspond with placing an order,
					 either from a customer via a sales order, or to a vendor via a purchase order,
					 approving the order internally, and then either shipping the order to the
					 customer, or receiving it from the vendor.</para> 
				<para>When an invoice is processed, if it is a purchase order, the 
					 <phrase role="code">OnPurchase</phrase> level for the item type
					 is increased, otherwise the 
					 <phrase role="code">OnOrder</phrase> level for the item type is
					 increased. When an invoice is completed, if it is a purchase order, the 
					 <phrase role="code">OnPurchase</phrase> level for the item type
					 is decreased, and the 
					 <phrase role="code">OnHand</phrase> level is increased. For a
					 sales order, both the 
					 <phrase role="code">OnOrder</phrase> and 
					 <phrase role="code">OnHand</phrase> levels are
					 decreased.</para> 
				<para>Rather than allow the invoice status to be edited through a
					 user-interface, we simply provide an operator to perform the update, and then
					 expose the operator in the presentation layer of the application. We will build
					 the user-interfaces that do this in Part III. The following listing shows the
					 operators that perform the update: 
					 <programlisting>//* Operator: ProcessInvoice	
<emphasis role="bold">create operator</emphasis> ProcessInvoice(<emphasis role="bold">const</emphasis> AInvoiceID : InvoiceID)
<emphasis role="bold">begin</emphasis>
	<emphasis role="bold">update</emphasis> Invoice 
		<emphasis role="bold">set</emphasis> { Status_ID := "PRO" } 
		<emphasis role="bold">where</emphasis> ID = AInvoiceID;
<emphasis role="bold">end</emphasis>;

//* Operator: CompleteInvoice
<emphasis role="bold">create operator</emphasis> CompleteInvoice(<emphasis role="bold">const</emphasis> AInvoiceID : InvoiceID)
<emphasis role="bold">begin</emphasis>
	<emphasis role="bold">update</emphasis> Invoice 
		<emphasis role="bold">set</emphasis> { Status_ID := "COM" } 
		<emphasis role="bold">where</emphasis> ID = AInvoiceID;
<emphasis role="bold">end</emphasis>;</programlisting></para> 
		  </sect1> 
	 </chapter> 
	 <chapter id="DDGEnforcingStimulus-ResponseRules"> 
		  <title><indexterm> 
					 <primary>Stimulus-Response Rules</primary> 
				</indexterm><indexterm> 
					 <primary>Business Rules</primary> 
					 <secondary>Stimulus-Response Rules</secondary> 
				</indexterm><indexterm> 
					 <primary>Logical Application Design</primary> 
					 <secondary>Enforcing Stimulus-Response Rules</secondary> 
				</indexterm><indexterm> 
					 <primary>Events</primary> 
					 <secondary>As Business Rules</secondary> 
				</indexterm>Enforcing Stimulus-Response Rules</title> 
		  <para>Many business rules involve actions to be taken in response to
				some event occurring within the system. These types of rules can be modeled
				within a Dataphor application schema using <emphasis>event handlers</emphasis>.
				An event handler is a D4 operator that has been attached to a given event in
				order to take some specific action in response to the event.</para> 
		  <para>There are two main types of events: data modification events such
				as before insert, or after update, and proposable events, such as default,
				change, and validate.</para> 
		  <para>Each event has a specific invocation signature. In order for a
				given operator to be attached to an event, it must have the same signature as
				the event. Any number of operators can be attached to a given event. This is
				done using the 
				<phrase role="code"><emphasis
					 role="bold">attach</emphasis></phrase> and 
				<phrase role="code"><emphasis
					 role="bold">detach</emphasis></phrase> statements.</para> 
		  <para>When multiple handlers are attached to a single event, the order
				in which the handlers are invoked can be controlled using the 
				<phrase role="code"><emphasis
					 role="bold">invoke</emphasis></phrase> statement.</para> 
		  <para>The <emphasis>before</emphasis> table-level events occur just
				prior to an insert, update, or delete to a given table variable. For the insert
				and update events, handlers are allowed to modify the <emphasis>new</emphasis>
				row, which has the affect of replacing the value to be inserted or
				updated.</para> 
		  <para>In addition, for each of the before events, the signature
				includes a boolean-valued variable that can be used to indicate whether the
				modification should take place. By default, the value of this variable is true.
				Setting it to false within the event handler will prevent the modification from
				occurring. Of course, the handler could still perform the modification
				directly, but the initial modification that fired the event would not
				occur.</para> 
		  <para>The <emphasis>after</emphasis> table-level events occurs after an
				insert, update, or delete to a given table variable. These handlers are not
				allowed to modify the <emphasis>old</emphasis> or <emphasis>new</emphasis>
				rows.</para> 
		  <para>Note that the <emphasis>after</emphasis> table-level event
				handlers can all be deferred in the same way that constraint checks can be
				deferred. By default, these handlers are deferred if they reference global
				table variables. This behavior can be changed using the 
				<phrase role="code">DAE.IsDeferred</phrase> tag on the attach
				statement for the event handler.</para> 
		  <para>The <emphasis>proposable</emphasis> handlers occur in response to
				the various proposable calls, either from the CLI directly, or during a data
				modification. Note that the <emphasis>default</emphasis> event will only be
				fired for an insert, and the <emphasis>validate</emphasis> event will only be
				fired for an insert or update. The <emphasis>change</emphasis> event will never
				be fired for a data modification, it can only be invoked through the CLI, or by
				calling 
				<phrase role="code">Change</phrase> directly for a cursor. In
				addition, the <emphasis>validate</emphasis> event will only be called during
				variable assignment or its logical equivalent, not on expression
				evaluation.</para> 
		  <sect1 id="DDGEnforcingStimulus-ResponseRules-UsingEventHandlers"> 
				<title><indexterm> 
						  <primary>Using Event Handlers</primary> 
					 </indexterm><indexterm> 
						  <primary>Stimulus-Response Rules</primary> 
						  <secondary>Using Event Handlers</secondary> 
					 </indexterm>Using Event Handlers</title> 
				<para>As mentioned previously, event handlers provide another
					 mechanism for enforcing various types of business rules. In fact, because they
					 can be deferred until transaction commit time, event handlers can completely
					 enforce all the types of constraints that have been discussed so far, as well
					 as the stimulus response type rules that cannot be enforced using
					 constraints.</para> 
				<para>Because of this, it is natural to ask the question, which
					 method should be used to enforce a given business rule? The answer is, of
					 course, if it can be done with constraints, it should be. Event handlers are
					 intended to handle the imperative side of business rule enforcement.
					 Inevitably, some business rules require action to be taken by the system, such
					 as updating inventory levels, auditing changes, or simply changing the update
					 or client-side behavior of a particular view.</para> 
				<para>In the sections that follow, some examples of using event
					 handlers to enforce these types of business rules are given. It should be noted
					 that there are drawbacks to attaching event handlers in some cases. For
					 example, if an event handler were attached to the 
					 <phrase role="code">InvoiceItem</phrase> table to update
					 inventory levels, it would effectively remove the primitive operation of
					 inserting an invoice item for an invoice. In other words, there would be no way
					 to add an invoice (such as for an import) without affecting inventory levels.
					 Of course, this is not to say that attaching event handlers to base table
					 variables is always problematic, we simply point out that there are
					 implications to doing so that should be considered in each case.</para> 
		  </sect1> 
		  <sect1
		  id="DDGEnforcingStimulus-ResponseRules-UsingEventHandlersToAffectDataModifications">
				
				<title><indexterm> 
						  <primary>Stimulus-Response Rules</primary> 
						  <secondary>Affecting Data Modifications</secondary> 
					 </indexterm>Affecting Data Modifications</title> 
				<para>A common usage of event handlers is to provide a hook for
					 affecting data as it is entered. For example, in the Shipping Application, each
					 contact has notes for recording miscellaneous information. As the requirements
					 dictate, changes to these notes must be audited, rather than simply allowing
					 the user to update the entire notes column directly.</para> 
				<para>To do this, we will create a view of the 
					 <phrase role="code">ContactNotes</phrase> table, and attach two
					 event handlers to it to provide the specific behavior. The following listing
					 shows the view definition: 
					 <programlisting>//* View: EnterContactNotes	
// View used to enter contact notes
<emphasis role="bold">create view</emphasis> EnterContactNotes
	ContactNotes 
		<emphasis role="bold">add</emphasis> 
		{ 
			<emphasis role="bold">nil as</emphasis> Notes NewNotes 
				<emphasis role="bold">tags</emphasis> { DAE.IsComputed = "false" } 
		}
		<emphasis role="bold">over</emphasis> { Contact_ID, NewNotes, Notes }
		<emphasis role="bold">adorn</emphasis> 
		{ 
			NewNotes <emphasis role="bold">tags</emphasis> { Frontend.Title = "Enter Notes" },
			Notes <emphasis role="bold">tags</emphasis> { Frontend.ReadOnly = "true" }
		}
	<emphasis role="bold">tags</emphasis>
	{
		Frontend.Title = "Notes"
	};</programlisting></para> 
				<para>This view works by introducing a new column 
					 <phrase role="code">NewNotes</phrase> with an extension
					 operator. In addition to appearing in the result set, the 
					 <phrase role="code">DAE.IsComputed</phrase> tag will allow it
					 to be an editable column in the user-interface.</para> 
				<para>By default, update propagation for the extension operator
					 will simply discard the values for the extended columns and propagate the
					 update directly. To change this behavior, we use event handlers that will merge
					 the new notes with the existing notes, and record the extra auditing
					 information: 
					 <programlisting>
//* Operator: UpdateNotesRow
<emphasis role="bold">create operator</emphasis> UpdateNotesRow
(
	<emphasis role="bold">var</emphasis> ARow : <emphasis role="bold">typeof</emphasis>(EnterContactNotes[])
)
<emphasis role="bold">begin</emphasis>
	<emphasis role="bold">if not</emphasis>(IsNil(ARow.NewNotes)) <emphasis role="bold">then</emphasis>
	<emphasis role="bold">begin</emphasis>
		<emphasis role="bold">update</emphasis> ARow 
			<emphasis role="bold">set</emphasis> 
			{
				Notes := 
					UserID() + " wrote on " + DateTime().ToString() 
					+ " --&gt;" + Unicode({ 13, 10 }) + NewNotes
					+ 
					(
						<emphasis role="bold">if</emphasis> IsNil(Notes) <emphasis role="bold">then</emphasis> "" 
						<emphasis role="bold">else</emphasis> (Unicode({ 13, 10, 13, 10 }) + Notes)
					)
			};
	<emphasis role="bold">end</emphasis>;
<emphasis role="bold">end</emphasis>;

//* Operator: EnterContactNotesInsert	
<emphasis role="bold">create operator</emphasis> EnterContactNotesInsert
(
	<emphasis role="bold">var</emphasis> ARow : <emphasis role="bold">typeof</emphasis>(EnterContactNotes[]), 
	<emphasis role="bold">var</emphasis> APerformUpdate : Boolean
)
<emphasis role="bold">begin</emphasis>
	UpdateNotesRow(<emphasis role="bold">var</emphasis> ARow);
<emphasis role="bold">end</emphasis>;
<emphasis role="bold">attach</emphasis> EnterContactNotesInsert 
	<emphasis role="bold">to</emphasis> EnterContactNotes <emphasis role="bold">on before insert</emphasis>;

//* Operator: EnterContactNotesUpdate
<emphasis role="bold">create operator</emphasis> EnterContactNotesUpdate
(
	<emphasis role="bold">const</emphasis> AOldRow : <emphasis role="bold">typeof</emphasis>(EnterContactNotes[]), 
	<emphasis role="bold">var</emphasis> ANewRow : <emphasis role="bold">typeof</emphasis>(EnterContactNotes[]), 
	<emphasis role="bold">var</emphasis> APerformUpdate : Boolean
)
<emphasis role="bold">begin</emphasis>
	UpdateNotesRow(<emphasis role="bold">var</emphasis> ANewRow);
<emphasis role="bold">end</emphasis>;
<emphasis role="bold">attach</emphasis> EnterContactNotesUpdate 
	<emphasis role="bold">to</emphasis> EnterContactNotes <emphasis role="bold">on before update</emphasis>;</programlisting>Note the use of the 
					 <phrase role="code"><emphasis
						  role="bold">typeof</emphasis></phrase> operator to specify the type of the
					 parameters of these operators. Because the signature for table-level event
					 handlers is based on row type of the table firing the event, the use of this
					 operator allows the signature to be easily specified.</para> 
				<para>Note also that the table-indexer expression would normally
					 give a compile-time warning, but since it is contained within a 
					 <phrase role="code"><emphasis
						  role="bold">typeof</emphasis></phrase>, the compiler determines that the
					 expression will never be evaluated, and does not issue the warning.</para> 
				<para>The 
					 <phrase role="code">UpdateNotesRow</phrase> operator simply
					 updates the 
					 <phrase role="code">Notes</phrase> column of the 
					 <phrase role="code">ARow</phrase> variable with the new notes
					 entered, and records the current user, date, and time information, appending
					 any existing notes to the end of the new notes. In this way, a reverse
					 chronological history is maintained for the notes.</para> 
				<para>The 
					 <phrase role="code">UpdateNotesRow</phrase> operator is then
					 called from an insert and update event handler attached to the 
					 <phrase role="code">EnterContactNotes</phrase> view.</para> 
		  </sect1> 
		  <sect1
		  id="DDGEnforcingStimulus-ResponseRules-UsingEventHandlersToAuditDataChanges"> 
				<title><indexterm> 
						  <primary>Stimulus-Response Rules</primary> 
						  <secondary>Auditing Data Changes</secondary> 
					 </indexterm>Auditing Data Changes</title> 
				<para>One of the initial requirements of the Shipping application
					 is that changes to demographic information be tracked for Customers and
					 Vendors. The contact structures are specifically designed to handle this
					 problem. For a complete discussion of the design aspects of this solution,
					 refer to the 
					 <ulink type="link"
					 url="DDGDatabaseDesignTechniques.html"><citetitle>Database Design
								Techniques</citetitle></ulink> chapter later in this part.</para> 
				<para>The following diagram details the main 
					 <phrase role="code">Contact</phrase> table, and the 
					 <phrase role="code">ContactNameDuring</phrase> table that will
					 track changes to the 
					 <phrase role="code">Name</phrase> column of the 
					 <phrase role="code">Contact</phrase> table: 
					 <figure> 
						  <title><indexterm> 
									 <primary>Shipping Database Design</primary> 
									 <secondary>Contact Name During</secondary> 
								</indexterm>Shipping Database Design: Contact Name
								During</title> 
						  <mediaobject> 
								<imageobject role="fo">
									 <imagedata fileref="Images\ContactNameDuringDiagram.svg" format="SVG"
									 scalefit="1"/> 
								</imageobject> 
								<imageobject role="html">
									 <imagedata fileref="Images\ContactNameDuringDiagram.emf" scalefit="1"/> 
								</imageobject> 
						  </mediaobject> 
					 </figure></para> 
				<para>In order to track the changes, we will attach three event
					 handlers to the 
					 <phrase role="code">Contact</phrase> table. The first handler,
					 a before update handler, simply updates the value of the 
					 <phrase role="code">NameSince</phrase> and 
					 <phrase role="code">NameBy</phrase> columns for the row being
					 updated, recording when the update was made, and the user making the change: 
					 <programlisting><emphasis role="bold">create operator</emphasis> ContactBeforeUpdate
(
	<emphasis role="bold">const</emphasis> AOldRow : <emphasis role="bold">typeof</emphasis>(Contact[]), 
	<emphasis role="bold">var</emphasis> ANewRow : <emphasis role="bold">typeof</emphasis>(Contact[]), 
	<emphasis role="bold">var</emphasis> APerformUpdate : Boolean
)
<emphasis role="bold">begin</emphasis>
	<emphasis role="bold">if</emphasis> AOldRow.Name &lt;&gt; ANewRow.Name <emphasis role="bold">then</emphasis>
		<emphasis role="bold">update</emphasis> ANewRow 
			<emphasis role="bold">set</emphasis> 
			{ 
				NameSince := DateTime(), 
				NameBy := UserID() 
			};
<emphasis role="bold">end</emphasis>;
<emphasis role="bold">attach</emphasis> ContactBeforeUpdate 
	<emphasis role="bold">to</emphasis> Contact <emphasis role="bold">on before update</emphasis>;</programlisting>Note that this example illustrates that before modification
					 handlers can change the values of the row being inserted or updated.</para> 
				<para>The second handler, an after update handler, records the name
					 change in the 
					 <phrase role="code">ContactNameDuring</phrase> table, noting
					 the user that recorded the name, and the dates during which that name was
					 recorded: 
					 <programlisting><emphasis role="bold">create operator</emphasis> ContactAfterUpdate
(
	<emphasis role="bold">const</emphasis> AOldRow : <emphasis role="bold">typeof</emphasis>(Contact[]), 
	<emphasis role="bold">const</emphasis> ANewRow : <emphasis role="bold">typeof</emphasis>(Contact[]))
<emphasis role="bold">begin</emphasis>
	<emphasis role="bold">if</emphasis> (AOldRow { ID, Name }) &lt;&gt; (ANewRow { ID, Name }) <emphasis role="bold">then</emphasis>
		<emphasis role="bold">insert</emphasis> 
			<emphasis role="bold">table</emphasis>
			{
				AOldRow 
				{ 
					ID Contact_ID, 
					Name, 
					NameSince From, 
					DateTime() To, 
					NameBy By 
				}
			}
			<emphasis role="bold">into</emphasis> ContactNameDuring;
<emphasis role="bold">end</emphasis>;
<emphasis role="bold">attach</emphasis> ContactAfterUpdate 
	<emphasis role="bold">to</emphasis> Contact <emphasis role="bold">on after update</emphasis>;</programlisting></para> 
				<para>The third handler, an after delete hander, records the name
					 of the deleted contact in the 
					 <phrase role="code">ContactNameDuring</phrase> table: 
					 <programlisting><emphasis role="bold">create operator</emphasis> ContactAfterDelete
(
	<emphasis role="bold">const</emphasis> ARow : <emphasis role="bold">typeof</emphasis>(Contact[])
)
<emphasis role="bold">begin</emphasis>
	<emphasis role="bold">insert</emphasis>
		<emphasis role="bold">table</emphasis>
		{
			ARow 
			{ 
				ID Contact_ID, 
				Name, 
				NameSince From, 
				DateTime() To, 
				NameBy By 
			}
		}
		<emphasis role="bold">into</emphasis> ContactNameDuring;
<emphasis role="bold">end</emphasis>;
<emphasis role="bold">attach</emphasis> ContactAfterDelete 
	<emphasis role="bold">to</emphasis> Contact <emphasis role="bold">on after delete</emphasis>;</programlisting></para> 
				<para>Note that these handlers occur after the modification has
					 already taken place, so they cannot change the values of the rows being
					 modified. However, they do have access to the values of the rows when the
					 modification was performed, meaning in this case that the modified 
					 <phrase role="code">NameSince</phrase> and 
					 <phrase role="code">NameBy</phrase> values from the before
					 update handler will be visible in the after update handler.</para> 
				<para><emphasis>During</emphasis> tables for the phone number and
					 address history are maintained with similar handlers on the 
					 <phrase role="code">ContactPhone</phrase> and 
					 <phrase role="code">ContactAddress</phrase> tables. For a
					 complete listing, refer to the 
					 <phrase role="code">ContactTables</phrase> d4 script in the 
					 <phrase role="code">Sample.Shipping</phrase> library.</para> 
		  </sect1> 
		  <sect1
		  id="DDGEnforcingStimulus-ResponseRules-ControllingViewUpdatabilityUsingEventHandlers">
				
				<title><indexterm> 
						  <primary>Stimulus-Response Rules</primary> 
						  <secondary>Controlling View Updatability</secondary> 
					 </indexterm>Controlling View Updatability</title> 
				<para>In some cases, the default view updatability behavior may not
					 provide the desired behavior. An example of this in the Shipping Application is
					 the user-interface to select contact categories. The following diagram depicts
					 the base table variables involved: 
					 <figure> 
						  <title><indexterm> 
									 <primary>Shipping Database Design</primary> 
									 <secondary>Contact Categories</secondary> 
								</indexterm>Shipping Database Design: Contact
								Categories</title> 
						  <mediaobject> 
								<imageobject role="fo">
									 <imagedata fileref="Images\ContactCategoryDiagram.svg" format="SVG"
									 scalefit="1"/> 
								</imageobject> 
								<imageobject role="html">
									 <imagedata fileref="Images\ContactCategoryDiagram.emf" scalefit="1"/> 
								</imageobject> 
						  </mediaobject> 
					 </figure></para> 
				<para>Rather than utilizing the default user-interfaces, the
					 application would be much more user-friendly if the list of categories to which
					 a contact belonged could be entered as a comma-separated list. To achieve this,
					 we define a view, 
					 <phrase role="code">ContactCategories</phrase>, and attach an
					 event handler to replace the default update behavior of the view.</para> 
				<para>These types of event handlers are often referred to as
					 "instead-of" handlers because they dictate the operation to be performed
					 "instead-of" the actual modification. We note that in practice, these types of
					 event handlers are rarely required, given the level of view updatability
					 provided by the D4 language.</para> 
				<para>We begin with the view definition itself, which uses the 
					 <phrase role="code">Concat</phrase> system aggregate operator
					 to produce the comma-separated list of categories to which a given contact
					 belongs: 
					 <programlisting>//* View: ContactCategories
<emphasis role="bold">create view</emphasis> ContactCategories
	Contact { ID } 
		<emphasis role="bold">add</emphasis> 
		{ 
			Concat
			(
				{ Description, Delimiter } <emphasis role="bold">from</emphasis> 
				(
					ContactCategory <emphasis role="bold">where</emphasis> Contact_ID = ID 
						<emphasis role="bold">join</emphasis> (Category { ID Category_ID, Description }) 
						<emphasis role="bold">add</emphasis> { ', ' Delimiter }
				)
			) Categories <emphasis role="bold">tags</emphasis> { DAE.IsComputed = "false" }
		}
		<emphasis role="bold">rename</emphasis> { ID Contact_ID }
	<emphasis role="bold">tags</emphasis> { Frontend.Title = "Categories"	};</programlisting></para> 
				<para>The default update behavior for this view definition is
					 simply to propagate the update to the 
					 <phrase role="code">ID</phrase> column of the 
					 <phrase role="code">Contact</phrase> table. The following
					 operator and attach statement will change this behavior, allowing the list of
					 categories to be edited directly: 
					 <programlisting>//* Operator: ContactCategoriesUpdate
<emphasis role="bold">create operator</emphasis> ContactCategoriesUpdate
(
	<emphasis role="bold">const</emphasis> AOldRow : <emphasis role="bold">typeof</emphasis>(ContactCategories[]), 
	<emphasis role="bold">var</emphasis> ANewRow : <emphasis role="bold">typeof</emphasis>(ContactCategories[]), 
	<emphasis role="bold">var</emphasis> APerformUpdate : Boolean
)
<emphasis role="bold">begin</emphasis>
	APerformUpdate := false;
	<emphasis role="bold">delete</emphasis> ContactCategory 
		<emphasis role="bold">where</emphasis> Contact_ID = AOldRow.Contact_ID;
	<emphasis role="bold">var</emphasis> LCategories := ANewRow.Categories.Split();
	<emphasis role="bold">for</emphasis> LIndex : Integer := 0 <emphasis role="bold">to</emphasis> LCategories.Count() - 1 <emphasis role="bold">do</emphasis>
	<emphasis role="bold">begin</emphasis>
		<emphasis role="bold">var</emphasis> LCategory := LCategories[LIndex].Trim();

		<emphasis role="bold">if</emphasis> IfNil(LCategory.Length(), 0) &gt; 0 <emphasis role="bold">then</emphasis>
		<emphasis role="bold">begin</emphasis>
			<emphasis role="bold">var</emphasis> LCategoryID := Category[LCategory].ID;
			<emphasis role="bold">if</emphasis> IsNil(LCategoryID) <emphasis role="bold">then</emphasis>
			<emphasis role="bold">begin</emphasis>
				LCategoryID := GetNextGenerator("Shipping.Category.ID");
				<emphasis role="bold">insert 
					table</emphasis> { <emphasis role="bold">row</emphasis> { LCategoryID ID, LCategory Description } } 
					<emphasis role="bold">into</emphasis> Category;
			<emphasis role="bold">end</emphasis>;

			<emphasis role="bold">insert</emphasis> 
				<emphasis role="bold">table</emphasis> 
				{ 
					<emphasis role="bold">row</emphasis> 
					{ 
						ANewRow.Contact_ID Contact_ID, 
						LCategoryID Category_ID 
					} 
				}
				<emphasis role="bold">into</emphasis> ContactCategory <emphasis role="bold">adorn with</emphasis> { PropagateInsert = "Ignore" };
		<emphasis role="bold">end</emphasis>;
	<emphasis role="bold">end</emphasis>;
<emphasis role="bold">end</emphasis>;
<emphasis role="bold">attach operator</emphasis> ContactCategoriesUpdate 
	<emphasis role="bold">to</emphasis> ContactCategories <emphasis role="bold">on before update</emphasis>;</programlisting>Setting the value of the 
					 <phrase role="code">APerformUpdate</phrase> variable to 
					 <phrase role="code">false</phrase> indicates that the event
					 handler will take over update processing, and the query processor should stop
					 processing the update. The 
					 <phrase role="code">Split</phrase> system string operator is
					 then invoked to separate the categories into a list of string values. Each of
					 these values is then added as a category for the given contact, adding new
					 categories as necessary.</para> 
		  </sect1> 
		  <sect1
		  id="DDGEnforcingStimulus-ResponseRules-UsingEventHandlersToUpdateValuesDuringDataEntry">
				
				<title><indexterm> 
						  <primary>Stimulus-Response Rules</primary> 
						  <secondary>Affecting Client-Side Data Entry</secondary> 
					 </indexterm><indexterm> 
						  <primary>Proposables</primary> 
					 </indexterm>Affecting Client-Side Data Entry</title> 
				<para>In addition to using event handlers to handle server-side
					 tasks such as auditing and updatability processing, event handlers provide the
					 ability to modify client-side behavior through the
					 <emphasis>proposable</emphasis> interfaces. Although these interfaces will be
					 discussed in greater detail in part III, this section will cover the use of
					 these handlers to update values during data entry.</para> 
				<para>As the motivating example, consider the user-interface for
					 recording the address of a 
					 <phrase role="code">Location</phrase>, with 
					 <phrase role="code">City</phrase>, 
					 <phrase role="code">State_ID</phrase>, and 
					 <phrase role="code">ZipCode</phrase> columns. We would like the
					 user-interface to auto-populate the city and state values based on the current
					 contents of the 
					 <phrase role="code">ZipCode</phrase> table for the selected
					 zipcode.</para> 
				<para>To allow for this type of client-side behavior modeling, the
					 Dataphor Server provides proposable interfaces that enable Dataphor Frontend
					 Clients to participate in the enforcement of business rules declared on the
					 server. In this particular instance, we will make use of the
					 <emphasis>change</emphasis> proposable, which corresponds to the question:
					 "What would happen if I changed the value of this column?"</para> 
				<para>The following program listing depicts the event handler that
					 provides this behavior: 
					 <programlisting>//* Operator: LocationZipCodeChange
<emphasis role="bold">create operator</emphasis> LocationZipCodeChange
(
	<emphasis role="bold">var</emphasis> ARow : <emphasis role="bold">typeof</emphasis>(Location[])
) : Boolean
<emphasis role="bold">begin</emphasis>
	<emphasis role="bold">result</emphasis> := <emphasis role="bold">false</emphasis>;
	<emphasis role="bold">if</emphasis> 
		<emphasis role="bold">not</emphasis>(IsNil(ARow.ZipCode)) 
			<emphasis role="bold">and</emphasis> IsNil(ARow.City) 
			<emphasis role="bold">and</emphasis> IsNil(ARow.State_ID) <emphasis role="bold">then</emphasis>
	<emphasis role="bold">begin</emphasis>
		<emphasis role="bold">result</emphasis> := <emphasis role="bold">true</emphasis>;
		<emphasis role="bold">var</emphasis> LZipRow := 
			ZipCode[ARow.ZipCode] { ZipCode, City, State_ID };
		<emphasis role="bold">update</emphasis> ARow 
			<emphasis role="bold">set</emphasis> 
			{ 
				City := LZipRow.City, 
				State_ID := LZipRow.State_ID 
			};
	<emphasis role="bold">end</emphasis>;
<emphasis role="bold">end</emphasis>;
<emphasis role="bold">attach</emphasis> LocationZipCodeChange 
	<emphasis role="bold">to</emphasis> ZipCode <emphasis role="bold">in</emphasis> Location <emphasis role="bold">on change</emphasis>;</programlisting>This operator is called with the current values of the 
					 <phrase role="code">Location</phrase> row being entered. This
					 means that in general the row will be only partially filled out when this
					 operator is invoked. As such, the operator first checks to see if the zipcode
					 has been entered, and that the city and state are empty. This ensures that the
					 change call will not overwrite data the user has already entered.</para> 
				<para>Using the value of the 
					 <phrase role="code">ZipCode</phrase> column, the city and state
					 for that zipcode are looked up in the 
					 <phrase role="code">ZipCode</phrase> table, and the city and
					 state columns in 
					 <phrase role="code">ARow</phrase> are updated.</para> 
				<para>Note that the 
					 <phrase role="code"><emphasis
						  role="bold">result</emphasis></phrase> variable is set to 
					 <phrase role="code"><emphasis
						  role="bold">true</emphasis></phrase> when the values of 
					 <phrase role="code">ARow</phrase> have been changed. To prevent
					 unnecessary copying, the effects of a proposable call will only be apparent if
					 the result of calling the event handler is true, so it is very important to set
					 the result appropriately in all proposable event handlers.</para> 
		  </sect1> 
	 </chapter> 
	 <chapter id="DDGEnforcingSecurity"> 
		  <title><indexterm> 
					 <primary>Security</primary> 
				</indexterm><indexterm> 
					 <primary>Logical Application Design</primary> 
					 <secondary>Security</secondary> 
				</indexterm>Enforcing Security</title> 
		  <para>This chapter discusses the Dataphor security model from a
				development perspective. It covers the basic concepts involved in the security
				model, and the mechanisms designed for use by application developers to expose
				security management points to application administrators.</para> 
		  <sect1 id="DDGEnforcingSecurity-DataphorSecurityModel"> 
				<title><indexterm> 
						  <primary>Dataphor Security Model</primary> 
					 </indexterm><indexterm> 
						  <primary>Security</primary> 
						  <secondary>Dataphor Security Model</secondary> 
					 </indexterm>Dataphor Security Model</title> 
				<para>The Dataphor Security Model consists of the following three
					 primitives: 
					 <itemizedlist> 
						  <listitem> 
								<para>Rights</para> 
						  </listitem> 
						  <listitem> 
								<para>Roles</para> 
						  </listitem> 
						  <listitem> 
								<para>Users</para> 
						  </listitem> 
					 </itemizedlist></para> 
				<para><indexterm> 
						  <primary>Security</primary> 
						  <secondary>Rights</secondary> 
					 </indexterm><indexterm> 
						  <primary>Rights</primary> 
					 </indexterm>Rights form the basic unit of permission for
					 granting or revoking access to particular areas of a Dataphor application
					 schema. Any capability that needs to be protected from a security standpoint
					 should have an associated Right.</para> 
				<para><indexterm> 
						  <primary>Roles</primary> 
					 </indexterm><indexterm> 
						  <primary>Security</primary> 
						  <secondary>Roles</secondary> 
					 </indexterm>Roles provide a mechanism for managing groups of
					 right assignments, and form the basis of security management in a Dataphor
					 application schema.</para> 
				<para><indexterm> 
						  <primary>Users</primary> 
					 </indexterm><indexterm> 
						  <primary>Security</primary> 
						  <secondary>Users</secondary> 
					 </indexterm>Users provide the basic mechanism for
					 authentication and authorization within a Dataphor Server. Each user is
					 assigned a unique 
					 <phrase role="code">UserID</phrase>, and given a user-specified
					 password.</para> 
				<para><indexterm> 
						  <primary>Ownership</primary> 
					 </indexterm><indexterm> 
						  <primary>Catalog Objects</primary> 
						  <secondary>Ownership</secondary> 
					 </indexterm><indexterm> 
						  <primary>Security</primary> 
						  <secondary>Ownership</secondary> 
					 </indexterm>In addition to these basic elements, objects in the
					 D4 catalog are <emphasis>owned</emphasis> by a specific user. By default, this
					 is the user that created the object, but ownership can be transferred with the
					 security API.</para> 
				<para><indexterm> 
						  <primary>Catalog Objects</primary> 
						  <secondary>Rights</secondary> 
					 </indexterm><indexterm> 
						  <primary>Security</primary> 
						  <secondary>Catalog Object Rights</secondary> 
					 </indexterm>Each object in the catalog has an associated set of
					 rights that are automatically created and maintained to protect access to the
					 various operations available on that object such as alteration, execution, or
					 manipulation. All these rights are implicitly granted to the object
					 owner.</para> 
				<para><indexterm> 
						  <primary>Right Assignments</primary> 
					 </indexterm><indexterm> 
						  <primary>Security</primary> 
						  <secondary>Right Assignments</secondary> 
					 </indexterm>Users can have any number of <emphasis>right
					 assignments</emphasis>. Each right assignment indicates whether a given user is
					 granted or revoked a specific right.</para> 
				<para>Roles are sets of right assignments that can then be assigned
					 all at once to a particular user. Roles are catalog objects that are defined
					 with a library by the developer of the application.</para> 
				<para>Each user can be a member of any number of roles. As a member
					 of a given role, the user has all the right assignments associated with that
					 role. Note that in the event of conflicting right assignments, the most
					 restrictive right assignment of any role is used.</para> 
				<para><indexterm> 
						  <primary>Security</primary> 
						  <secondary>Rights Determination</secondary> 
					 </indexterm><indexterm> 
						  <primary>Rights Determination</primary> 
					 </indexterm>When a specific right is requested, the following
					 steps are taken to discover whether the right is granted or revoked: 
					 <itemizedlist> 
						  <listitem> 
								<para>If the user has an explicit assignment for the
									 right, the right is granted or revoked according to the right
									 assignment.</para> 
						  </listitem> 
						  <listitem> 
								<para>If the roles which the user is a member of have
									 an explicit assignment for the right, the right is granted or revoked according
									 to the most restrictive right assignment of any role.</para> 
						  </listitem> 
						  <listitem> 
								<para>If the user is the owner of the right, or the
									 catalog object the right is associated with, the right is considered
									 granted.</para> 
						  </listitem> 
					 </itemizedlist></para> 
				<para>For more detailed information on the Dataphor Security Model,
					 refer to 
					 <ulink type="olinka"
					 url="DUGP3Security.html"><citetitle>Security</citetitle></ulink> chapter in the
					 Dataphor User's Guide.</para> 
		  </sect1> 
		  <sect1 id="DDGEnforcingSecurity-DesigningForSecurity"> 
				<title><indexterm> 
						  <primary>Designing For Security</primary> 
					 </indexterm><indexterm> 
						  <primary>Security</primary> 
						  <secondary>Design Guidelines</secondary> 
					 </indexterm>Designing For Security</title> 
				<para>Rights and roles are catalog objects, belonging to a specific
					 library and owned by some user of the Dataphor Server. Users, on the other
					 hand, are global to the Dataphor Server, and are managed by the administrator
					 of the server instance. As such, applications should make no assumptions about
					 the users that will be available on a given system. Security from the
					 developer's perspective is a matter of ensuring that the appropriate rights and
					 roles are available to the administrator to enforce security simply and
					 effectively.</para> 
				<para>Ideally, the administrator of a Dataphor application should
					 not need to deal with managing specific right assignments to users. Rather, the
					 administrator should be concerned with managing the users of the Dataphor
					 Server, and with associating roles with those users.</para> 
				<para>This architecture leads to several important guidelines for
					 developing secure and manageable applications with Dataphor: 
					 <itemizedlist> 
						  <listitem> 
								<para>Create roles for every anticipated usage pattern
									 of the application.</para> 
						  </listitem> 
						  <listitem> 
								<para>Rights for every object should be granted to some
									 role.</para> 
						  </listitem> 
						  <listitem> 
								<para>Roles should be intuitive and clearly
									 named.</para> 
						  </listitem> 
						  <listitem> 
								<para>Roles should be as flat as possible, with as
									 little overlap in functionality as possible.</para> 
						  </listitem> 
					 </itemizedlist></para> 
		  </sect1> 
		  <sect1 id="DDGEnforcingSecurity-SecurityintheShippingApplication"> 
				<title><indexterm> 
						  <primary>Shipping Application</primary> 
						  <secondary>Security</secondary> 
					 </indexterm><indexterm> 
						  <primary>Security</primary> 
						  <secondary>In the Shipping Application</secondary> 
					 </indexterm>Security in the Shipping Application</title> 
				<para>In this section we describe the security implementation in
					 place in the Shipping Application as an example of using the security features
					 of the Dataphor platform. Recall from the requirements for the application that
					 there are three main categories of users: Management, Customer Service, and
					 Inventory Clerk.</para> 
				<para>Management users are responsible for managing other users,
					 and maintaining their access rights to the application. Fortunately, this role
					 is already handled by the Dataphor 
					 <phrase role="code">Security</phrase> library. The 
					 <phrase role="code">Security</phrase> library provides
					 user-interfaces for administering security in a Dataphor Server, and exposes
					 the 
					 <phrase role="code">SecurityUser</phrase> role. Any user that
					 is a member of this role will have access to all the objects required to use
					 the user-interfaces exposed in the 
					 <phrase role="code">Security</phrase> library.</para> 
				<para>To handle Customer Service users, the Shipping Application
					 introduces the 
					 <phrase role="code">CustomerService</phrase> role. This role is
					 granted access to table variables such as 
					 <phrase role="code">CustomerDetail</phrase> and 
					 <phrase role="code">SaleOrderEntry</phrase>, as well as select
					 access to 
					 <phrase role="code">Location</phrase> and 
					 <phrase role="code">ItemType</phrase>.</para> 
				<para>For the Inventory Clerk users, the Shipping Application
					 introduces the 
					 <phrase role="code">InventoryClerk</phrase> role, which is
					 granted access to table variables such as 
					 <phrase role="code">VendorDetail</phrase> and 
					 <phrase role="code">PurchaseOrder</phrase>. Inventory clerks
					 are also given access to the 
					 <phrase role="code">Location</phrase> and 
					 <phrase role="code">ItemType</phrase> tables so that they can
					 manage inventory and par levels.</para> 
				<para>In addition, the Shipping application defines the 
					 <phrase role="code">ShippingUser</phrase> role, which is
					 granted access to all the common areas of the system. This role is used to
					 prevent overlap among the other roles.</para> 
				<para>By defining these roles, the application developer has
					 identified the areas of the application that can be configured from a security
					 standpoint. These roles can then be used by Dataphor Server Administrators to
					 deploy secure applications with very little configuration involved.</para> 
		  </sect1> 
	 </chapter> 
	 <chapter id="DDGWorkingWithLibraries"> 
		  <title><indexterm> 
					 <primary>Libraries</primary> 
				</indexterm>Working With Libraries</title> 
		  <para>Libraries provide a mechanism for managing groups of catalog
				objects in the Dataphor Server. They also provide the fundamental deployment
				mechanism for Dataphor applications. A library in the Dataphor Server is
				defined as a named and versioned set of catalog objects, a set of library
				dependencies, a set of library files, and an optional registration script. A
				library may also specify a default device name to be used as the default
				storage device for table variables created in the library.</para> 
		  <para>Each session running within the Dataphor Server has a
				<emphasis>current library</emphasis>. This library can be specified as part of
				the session information given when connecting to the Dataphor Server, and can
				be controlled using the 
				<phrase role="code"><ulink type="olinka"
					 url="O-System.SetLibrary.html">SetLibrary</ulink></phrase> operator. The
				current library is used for several purposes in the Dataphor Server such as
				default device resolution, 
				<ulink type="olinka"
				url="D4LGCatalogElements-Libraries-LibrariesandNamespaces.html">name
					 resolution</ulink>, and is the default library for all newly created
				objects.</para> 
		  <sect1 id="D4LGCatalogElements-Libraries"> 
				<title><indexterm> 
						  <primary>Libraries</primary> 
						  <secondary>Status</secondary> 
					 </indexterm>Status</title> 
				<para><indexterm> 
						  <primary>Available Libraries</primary> 
					 </indexterm><indexterm> 
						  <primary>Registered Libraries</primary> 
					 </indexterm><indexterm> 
						  <primary>Suspect Libraries</primary> 
					 </indexterm>Each library in the Dataphor Server is either 
					 <ulink type="olinka"
					 url="DUGP1Dataphoria-DataphorExplorer-Libraries.html"><emphasis>available</emphasis>,
						  <emphasis>registered</emphasis>, or <emphasis>suspect</emphasis></ulink>. An
					 available library is simply the definition of the library. A registered library
					 is an active catalog repository in the Dataphor Server. A suspect library is
					 one that has encountered some error while attempting to load the library. The
					 Dataphor Server uses the catalog directory specified at startup to persist
					 which libraries have been registered, and the catalog state for each
					 library.</para> 
		  </sect1> 
		  <sect1 id="DDGWorkingWithLibraries-Versioning"> 
				<title><indexterm> 
						  <primary>Versioning</primary> 
					 </indexterm><indexterm> 
						  <primary>Libraries</primary> 
						  <secondary>Versioning</secondary> 
					 </indexterm>Versioning</title> 
				<para>The version of a library is specified using the 
					 <phrase role="code"><ulink type="olinkb"
						  url="T-System.VersionNumber.html">System.VersionNumber</ulink></phrase> data
					 type. By default, the version of a library is the special value 
					 <phrase role="code"><ulink type="olinka"
						  url="T-System.VersionNumber.html">VersionNumberUndefined</ulink></phrase>. When
					 a library is referenced as a dependency by another library, the version number
					 may also be specified, allowing libraries to require not only other libraries,
					 but specific versions of those libraries. The notion of version compatibility
					 is used to allow library references to target any granularity of the version
					 number desired. For example, a library could reference version 
					 <phrase role="code">2.0.*</phrase> of the 
					 <phrase role="code">System</phrase> library, meaning that the
					 library is compatible with any 
					 <phrase role="code">System</phrase> library that has major
					 version 
					 <phrase role="code">2</phrase>, and minor version 
					 <phrase role="code">0</phrase>.</para> 
		  </sect1> 
		  <sect1 id="DDGWorkingWithLibraries-Files"> 
				<title><indexterm> 
						  <primary>Libraries</primary> 
						  <secondary>Files</secondary> 
					 </indexterm>Files</title> 
				<para>A library specifies a set of files to be included with the
					 library. These are files that will be copied into the run-time directory of the
					 Dataphor Server, and optionally registered as an assembly. Libraries are the
					 only mechanism for registering assemblies with the Dataphor Server. This allows
					 libraries to function as extensibility packages. For example, the 
					 <phrase role="code">Frontend</phrase> and 
					 <phrase role="code">SimpleDevice</phrase> are libraries that
					 extend the functionality of the Dataphor Server.</para> 
		  </sect1> 
		  <sect1 id="DDGWorkingWithLibraries-DefaultDeviceResolution"> 
				<title><indexterm> 
						  <primary>Default Device Resolution</primary> 
					 </indexterm><indexterm> 
						  <primary>Libraries</primary> 
						  <secondary>Default Device Resolution</secondary> 
					 </indexterm>Default Device Resolution</title> 
				<para>The default device name for a library is used to specify the
					 storage device for table variables created in the library if no storage device
					 is specified as part of the create table statement. If the current library does
					 not specify a default device name, the default device is the first
					 unambiguously specified default device name in a breadth-first traversal of the
					 library dependency graph above the current library.</para> 
		  </sect1> 
		  <sect1 id="DDGWorkingWithLibraries-LibrariesandNamespaces"> 
				<title><indexterm> 
						  <primary>Libraries and Namespaces</primary> 
					 </indexterm><indexterm> 
						  <primary>Libraries</primary> 
						  <secondary>Libraries and Namespaces</secondary> 
					 </indexterm><indexterm> 
						  <primary>Name Resolution</primary> 
					 </indexterm>Libraries and Namespaces</title> 
				<para>When an object is created within a library, it will be
					 namespaced by the name of the library. For example, if the current library is 
					 <phrase role="code">General</phrase>, the statement: 
					 <programlisting><emphasis role="bold">create table</emphasis> Employee { ID : Integer, Name : String, <emphasis role="bold">key</emphasis> { ID } };</programlisting>will create a table called 
					 <phrase role="code">General.Employee</phrase>. Identifier
					 resolution in the D4 language then allows this table to be referenced by its
					 unqualified name 
					 <phrase role="code">Employee</phrase>, even if other libraries
					 have a table with the same unqualified name. This process is called
					 <emphasis>name resolution</emphasis> and is somewhat analogous to the
					 <emphasis>namespace</emphasis> concept in some object-oriented
					 languages.</para> 
				<para>The current library, and the library dependency graph of the
					 current library are used to create a <emphasis>name resolution path</emphasis>.
					 This path consists of a series of steps, where each step is the set of
					 libraries at the same depth in the dependency graph. The name resolution
					 process then uses the names of the libraries in each step as a default
					 namespace to attempt to resolve the identifier. The steps are considered in
					 order from the first step, which contains only the name of the current library,
					 to the root of the dependency graph.</para> 
				<para>If a given identifier resolves to more than one name at any
					 step of the name resolution path, the identifier is considered ambiguous, and
					 an error is thrown. Otherwise, the name referenced in the first step in which
					 the identifier resolves is returned as the resulting reference for the
					 identifier. If the steps of the name resolution path are exhausted without
					 resolving the identifier, the identifier is considered unknown and an error is
					 thrown.</para> 
		  </sect1> 
		  <sect1 id="DDGWorkingWithLibraries-Dependencies"> 
				<title><indexterm> 
						  <primary>Dependencies</primary> 
					 </indexterm><indexterm> 
						  <primary>Libraries</primary> 
						  <secondary>Dependencies</secondary> 
					 </indexterm>Dependencies</title> 
				<para>All catalog objects in the Dataphor Server are members of one
					 and only one library. In order for an object to depend on another object it
					 must either be in the same library as the object, or in some library that
					 requires the library of the target object. For example in order for a table in
					 library A to be referenced by a constraint in library B, library B must require
					 library A.</para> 
		  </sect1> 
		  <sect1 id="DDGWorkingWithLibraries-Settings"> 
				<title><indexterm> 
						  <primary>Libraries</primary> 
						  <secondary>Settings</secondary> 
					 </indexterm>Settings</title> 
				<para>Library settings provide a mechanism for associating
					 information with a library definition. This information is then available to
					 the library at any time, including during the registration process. This allows
					 library settings to be used as configuration options for Dataphor libraries and
					 applications.</para> 
				<para>Library settings are stored as part of the definition of the
					 library, and are available either by explicitly accessing the 
					 <phrase role="code">System.LibrarySettings</phrase> catalog
					 table, or by invoking the 
					 <ulink type="olinka" url="O-System.LibrarySetting.html"><phrase
						  role="code">LibrarySetting</phrase></ulink> operator.</para> 
		  </sect1> 
		  <sect1 id="DDGWorkingWithLibraries-LibraryImplementation"> 
				<title><indexterm> 
						  <primary>Libraries</primary> 
						  <secondary>Library Implementation</secondary> 
					 </indexterm>Library Implementation</title> 
				<para>Physically, a library in the Dataphor Server is a file system
					 directory accessible by the server instance. On startup, the Dataphor Server
					 scans the configured library directories for available libraries. In addition,
					 existing libraries can be made available within the Dataphor Server by
					 attaching them to the server instance, either through the user-interfaces
					 available in the Dataphor Explorer, or using the library management operators
					 in the system library. Available libraries may also be detached from the
					 Dataphor Server, however if the library definition is within a library
					 directory of the server, it will be available the next time the server instance
					 is started.</para> 
				<para>Each available library is listed in the system catalog. When
					 a library is registered, the following sequence of steps is taken: 
					 <itemizedlist> 
						  <listitem> 
								<para>The Dataphor Server ensures that the required
									 version of each requisite library is registered.</para> 
						  </listitem> 
						  <listitem> 
								<para>Each file listed in the library is copied into
									 the run-time directory of the Dataphor Server. Copy errors are ignored so that
									 assemblies that are already registered will not prevent the library from being
									 registered. (Note that this means the Dataphor Server must be restarted to
									 update assemblies which have been changed.)</para> 
						  </listitem> 
						  <listitem> 
								<para>Each file that is marked as an assembly is
									 registered with the Dataphor Server.</para> 
						  </listitem> 
						  <listitem> 
								<para>The library is set as the current library for the
									 session.</para> 
						  </listitem> 
						  <listitem> 
								<para>If there is a file called Documents\Register.d4
									 in the library directory, it is run as the registration script for the
									 library.</para> 
						  </listitem> 
					 </itemizedlist></para> 
				<para>Registered libraries may also be unregistered, which is
					 essentially the reverse of the registration process. Both registering and
					 unregistering a library may be done with or without reconciliation. The
					 reconciliation option controls the following behaviors: 
					 <itemizedlist> 
						  <listitem> 
								<para>Data Definition Language (DDL) Statements</para> 
						  </listitem> 
						  <listitem> 
								<para>Data Manipulation Language (DML)
									 Statements</para> 
						  </listitem> 
						  <listitem> 
								<para>Constraint Validation</para> 
						  </listitem> 
					 </itemizedlist></para> 
				<para>If reconciliation is enabled, each of these items will issue
					 the corresponding statements in mapped devices as normal. If reconciliation is
					 disabled, communication with the mapped devices will not take place. For
					 example, if a library contains a create table statement, registering with
					 reconciliation will cause the corresponding create table statement statement to
					 be issued against the device, while registering without reconciliation will
					 only create the table definition in the Dataphor Server catalog.</para> 
		  </sect1> 
		  <sect1 id="DDGWorkingWithLibraries-DeploymentandMaintenance"> 
				<title><indexterm> 
						  <primary>Deployment</primary> 
					 </indexterm><indexterm> 
						  <primary>Maintenance</primary> 
					 </indexterm><indexterm> 
						  <primary>Libraries</primary> 
						  <secondary>Deployment and Maintenance</secondary> 
					 </indexterm>Deployment and Maintenance</title> 
				<para>Deploying libraries is simply a matter of copying the entire
					 contents of the library directory into one of the library directories of the
					 target Dataphor Server, and registering the library. Adjustments for the target
					 environment such as device and user settings should be made by the Dataphor
					 Server Administrator prior to registering the library. Once the required set of
					 libraries for a given application has been registered, an application can be
					 created in the usual manner by the Dataphor Administrator.</para> 
				<para><ulink type="olinka"
					 url="DUGP1UpgradingLibraries.html">Upgrading libraries</ulink> is accomplished
					 by 
					 <ulink type="olinka"
					 url="D4LGCatalogElements-Libraries-Versioning.html">versioning</ulink> the
					 library. Each library contains a set of upgrade scripts which, when applied in
					 order to a given deployed library, will bring the deployment up to the current
					 version of the library. Each change to the schema of a given library should be
					 recorded as a DDL script, and injected into the library. Note that the library
					 version must be specified to at least the revision number to track upgrades in
					 this manner. Each injection will automatically increment the revision number of
					 the library version, and save the injected script as an upgrade with that
					 version number. The upgrade scripts are saved as d4 files in the Upgrades
					 folder of the library. The new version of the library can then be copied into
					 the Libraries directory of the target Dataphor Server.</para>

      <!--This section must be updated to deal with the new persistent catalog paradigm.<para>The libraries to be upgraded must first be unloaded (either
      explicitly, or by shutting down the Dataphor Server). When the libraries
      are next loaded, the Dataphor Server will detect the version difference
      and indicate that the library or libraries need to be upgraded. The
      <phrase role="code"><ulink type="olinkb" url="O-System.UpgradeLibrary.html">UpgradeLibrary</ulink></phrase>
      command can then be used to begin the upgrade process. This process
      takes place by incrementally applying each version found in the upgrade
      scripts. Each upgrade is performed within a single transaction, and the
      library catalog is checkpointed after each successful upgrade. If an
      exception occurs during an upgrade script, only the script causing the
      error is rolled back. The library catalog is returned to the state it
      was prior to attempting the upgrade step, and the library is left at the
      version number of the last successful upgrade application. The next time
      the upgrade process is attempted, the process will begin from this
      version number.</para>-->
		  </sect1> 
		  <sect1 id="D4LGCatalogElements-SystemLibraries"> 
				<title><indexterm> 
						  <primary>System Libraries</primary> 
					 </indexterm><indexterm> 
						  <primary>Libraries</primary> 
						  <secondary>System Libraries</secondary> 
					 </indexterm>System Libraries</title> 
				<para>The Dataphor Server provides two system libraries: 
					 <phrase role="code">System</phrase> and 
					 <phrase role="code">General</phrase>. The 
					 <phrase role="code">System</phrase> library contains all the
					 catalog objects required to run the Dataphor Server including the
					 system-provided data types and operators, host-implementation structures, and
					 the system catalog tables. The 
					 <phrase role="code">General</phrase> library is the default
					 workspace for sessions that do not specify a current library. These libraries
					 are owned by the system user, and cannot be modified or unregistered.</para> 
		  </sect1> 
	 </chapter> 
	 <chapter id="DDGDatabaseDesignTechniques"> 
		  <title><indexterm> 
					 <primary>Database Design Techniques</primary> 
				</indexterm><indexterm> 
					 <primary>Logical Application Design</primary> 
					 <secondary>Database Design Techniques</secondary> 
				</indexterm>Database Design Techniques</title> 
		  <para>As we have seen in the previous chapters, a large part of
				Dataphor Application development is simply database design. In fact, the
				Dataphor platform tends to magnify artifacts of bad database design. If a given
				database design requires a large amount of supporting hand-written code, the
				developer should take a step back and consider an alternate solution to the
				problem that may lend itself more easily to implementation within the Dataphor
				framework.</para> 
		  <para>That being said, it is worth noting that database design is both
				an art, and a science. While there are some objective principles such as
				normalization theory that can be used as guidelines when designing a database,
				by and large the process takes practice and experience.</para> 
		  <para>This chapter brings together various discussions on a broad range
				of database design topics, with the intent of providing the developer with some
				high-level database design guidelines. The discussions are necessarily abstract
				in places, but we attempt to make them concrete by utilizing some of the design
				decisions that were made while building the Shipping application.</para> 
		  <para>The discussion begins with a description of the modeling notation
				that has been used throughout this part for visualizing database designs, and
				then turns to a broad overview of what database design is and why it plays such
				an important role in the Dataphor product. The remainder of the chapter then
				discusses specific database design issues.</para> 
		  <sect1 id="DDGDatabaseDesignTechniques-ModelingNotation"> 
				<title><indexterm> 
						  <primary>Modeling Notation</primary> 
					 </indexterm>Modeling Notation</title> 
				<para>While there are many different modeling notations available
					 today, we feel that none have effectively and simply captured the essence of
					 relational database design. As such, we have adopted a simple visual notation
					 for representing database designs. The notation makes no attempt at capturing
					 constraint definitions other than keys and references, and is not intended as a
					 complete notation for database design.</para> 
				<para>The only elements that are represented by the notation are
					 base table variables, columns, keys, and references. This simplicity renders
					 the notation an effective tool for sketching database designs, while capturing
					 enough detail to communicate the major components of a given design.</para> 
				<para>Base table variables are represented as a labeled box, the
					 label is the name of the base table variable being depicted. The columns of the
					 table are listed vertically within the box.</para> 
				<para>An asterisk to the left of a column indicates that it
					 participates in a key constraint. Any number of key constraints can be
					 represented, with multiple columns of asterisks to the left of the column
					 list.</para> 
				<para>Reference constraints are depicted as directed lines
					 connecting tables. The lines originate in the source table, directly from the
					 source column, with multiple columns depicted as multiple leading lines into
					 the main reference line. The lines terminate at the target table, directly into
					 the target column, with multiple columns depicted as multiple lines leading
					 into the target table. Arrow heads terminate each lead line of the
					 reference.</para> 
				<para>The following example diagram illustrates each of these
					 design notations: 
					 <figure> 
						  <title><indexterm> 
									 <primary>Modeling Notation Diagram</primary> 
								</indexterm>Modeling Notation Diagram</title> 
						  <mediaobject> 
								<imageobject role="fo">
									 <imagedata fileref="Images\ModelingNotationDiagram.svg" format="SVG"
									 scalefit="1"/> 
								</imageobject> 
								<imageobject role="html">
									 <imagedata fileref="Images\ModelingNotationDiagram.emf" scalefit="1"/> 
								</imageobject> 
						  </mediaobject> 
					 </figure></para> 
		  </sect1> 
		  <sect1 id="DDGDatabaseDesignTechniques-DatabaseDesign"> 
				<title><indexterm> 
						  <primary>Database Design</primary> 
					 </indexterm>Database Design</title> 
				<para>Any serious discussion of database design must begin by
					 answering a simple question: Just what exactly <emphasis>is</emphasis> database
					 design? Intuitively, the answer is simply the process of modeling some aspect
					 of reality within a database. But how exactly is this accomplished? What
					 elements of an application schema correspond with the concepts and entities of
					 the real world? Perhaps the simplest answer is an observation by Hugh Darwen,
					 paraphrasing slightly, that types are the concepts we want to talk about, and
					 relations are the things we want to say about those concepts [3].</para> 
				<para>To put it another way, every table in the database carries
					 some meaning that can be directly interpreted in terms of objects in the real
					 world. In a properly designed database, every table will correspond one-to-one
					 with some statement about that segment of the real world that is being
					 modeled.</para> 
				<para>Another approach to determining just what database design
					 really is involves taking a step back and asking the question: What exactly is
					 a database? What purpose does a database application serve? The textbook
					 answer, of course, is that a database is an organized collection of facts. But
					 what does this mean in terms of solving a real-world problem? The answer lies
					 in the fundamental motivation behind the creation of database applications in
					 the first place: <emphasis>automation</emphasis>.</para> 
				<para>Computers have given us a wonderful tool for solving
					 problems. They are absolutely analytical, and completely obedient. They perform
					 whatever task is demanded without question, and give us an efficient mechanism
					 for performing mundane or complicated tasks, simply by instructing the system.
					 So the answer is, we build applications in order to automate the tasks we would
					 otherwise have to perform manually. In many cases, the resulting automation
					 enables us to perform tasks that would be impossible to complete.</para> 
				<sect2 id="DDGDatabaseDesignTechniques-DatabaseDesign-Meaning"> 
					 <title><indexterm> 
								<primary>Database Design</primary> 
								<secondary>Meaning</secondary> 
						  </indexterm>Meaning</title> 
					 <para>In order to enable this automation, we need three things:
						  first, a general purpose framework for describing the real world; second, a
						  model built within this framework that describes that segment of the real world
						  we are interested in, and third, a language for manipulating that model, and
						  asking questions about it. The relational model provides us with this general
						  purpose framework, application schemas provide the description of the real
						  world, and a database language based on the relational model provides us with
						  the ability to manipulate the data in that model, and ask questions about that
						  data.</para> 
					 <para>For example, in the Shipping application, that segment of
						  the real world we are interested in is the day-to-day operations of a
						  fictitious distribution business. Obviously, the system has no idea what a
						  shipping location is, or why it is important. But as users of the system, we
						  understand that the existence of a row in the 
						  <phrase role="code">Location</phrase> table means that the
						  organization has a shipping location.</para> 
					 <para>In addition to modeling the existence of entities in the
						  real world, we can model relationships between those entities. For example, the
						  
						  <phrase role="code">Invoice</phrase> table has a 
						  <phrase role="code">Location_ID</phrase> column. The value
						  of this column for a particular row indicates that a given invoice originated
						  at the specified location. Again, the system has no idea what an invoice is, or
						  why it would originate at a location. But by enforcing the reference constraint
						  that a value in the 
						  <phrase role="code">Location_ID</phrase> column must exist
						  as a value in the 
						  <phrase role="code">ID</phrase> column of the 
						  <phrase role="code">Location</phrase> row, we allow the
						  system to enforce that every invoice must originate in some location.</para> 
					 <para>This simple example illustrates one of the most important
						  overall principles of database design: that the sum total of constraints in the
						  database are the best approximation of the <emphasis>meaning</emphasis> of that
						  data to the system.</para> 
				</sect2> 
				<sect2 id="DDGDatabaseDesignTechniques-DatabaseDesign-Predicates"> 
					 <title><indexterm> 
								<primary>Predicates</primary> 
						  </indexterm><indexterm> 
								<primary>Database Design</primary> 
								<secondary>Predicates</secondary> 
						  </indexterm>Predicates</title> 
					 <para>So the basic elements available in an application schema,
						  namely types, table variables, and constraints, correspond roughly to the
						  concepts of nouns, statements, and rules. For instance, to return to the
						  example of shipping locations, we need to talk about location identifiers,
						  phone numbers, and addresses. We want to say, "There is a shipping location
						  with a unique identifier, that has some phone number, and some address."</para>
					 
					 <para>The nouns in this sentence are modeled by various types
						  within the application schema. For example, in order to talk about location
						  identifiers, the Shipping application schema has a type 
						  <phrase role="code">LocationID</phrase>. Valid values for
						  this type are well-formed location identifiers, according to the rules for
						  building location identifiers set out by the organization.</para> 
					 <para>By replacing the "variables" within the statement above
						  with the values of the corresponding columns for some row in the 
						  <phrase role="code">Location</phrase> table, we obtain the
						  fact, "There is a shipping location with identifier '001', that has phone
						  number '555-0990', and address '123 West Frontage Rd., Provo, UT
						  84604'."</para> 
					 <para>This simple relationship between tables in the database
						  and statements about the real world lies at the heart of the simplicity and
						  power of the relational model. Consequently, understanding that every table
						  actually corresponds to some facet of reality lies at the heart of good
						  database design.</para> 
				</sect2> 
		  </sect1> 
		  <sect1 id="DDGDatabaseDesignTechniques-ScalarTypes"> 
				<title><indexterm> 
						  <primary>Scalar Types</primary> 
						  <secondary>Design Guidelines</secondary> 
					 </indexterm><indexterm> 
						  <primary>Database Design Techniques</primary> 
						  <secondary>Scalar Types</secondary> 
					 </indexterm>Scalar Types</title> 
				<para>Because scalar types describe the domains of discourse for
					 the application, they are a crucial element of the design effort. If done
					 properly, type design can isolate and prevent many design flaws before they
					 occur. Proper type design is the first step in ensuring that the data for an
					 application is represented correctly and completely. This section discusses
					 some of the issues that arise in connection with designing scalar types for use
					 in a relational database application.</para> 
				<sect2
				id="DDGDatabaseDesignTechniques-ScalarTypes-UsingScalarTypes"> 
					 <title><indexterm> 
								<primary>Scalar Types</primary> 
								<secondary>Using Scalar Types</secondary> 
						  </indexterm>Using Scalar Types</title> 
					 <para>The first point to be made in connection with scalar
						  types is that they should be <emphasis>used</emphasis>. This sounds like a
						  trivial observation, but the fact is that type design is an often neglected
						  facet of database design. For example, the set of values for a 
						  <phrase role="code">Gender</phrase> column is often simply
						  defined as a character string of length one (allowing any alphanumeric
						  character) when in fact, a 
						  <phrase role="code">Gender</phrase> type with possible
						  values representing <emphasis>male</emphasis> and <emphasis>female</emphasis>
						  is the more accurate description of the data for the column.</para> 
					 <para>Failure to enforce these types of constraints leads
						  directly to a lack of integrity in the application data. In many cases, this
						  lack of integrity translates directly to program failures. For example, a query
						  writer may reasonably assume that the only valid values for the 
						  <phrase role="code">Gender</phrase> column are in fact 
						  <phrase role="code">M</phrase> and 
						  <phrase role="code">F</phrase>, and proceed to construct an
						  incorrect query based on that reasonable, but false, assumption.</para> 
				</sect2> 
				<sect2
				id="DDGDatabaseDesignTechniques-ScalarTypes-VerifyingSemantics"> 
					 <title><indexterm> 
								<primary>Scalar Types</primary> 
								<secondary>Verifying Semantics</secondary> 
						  </indexterm>Verifying Semantics</title> 
					 <para>One of the most significant benefits of defining types is
						  that it helps the compiler understand and verify the semantics of any given D4
						  program. For example, given the 
						  <phrase role="code">LocationItem</phrase> table: 
						  <programlisting><emphasis role="bold">create table</emphasis> LocationItem
{
	Location_ID : LocationID,
	ItemType_ID : ItemTypeID,
	Price : Money,
	...,
	<emphasis role="bold">key</emphasis> { Location_ID, ItemType_ID }
};</programlisting>the compiler can resolve table-indexer expressions like the
						  one appearing in the operator below: 
						  <programlisting><emphasis role="bold">create operator</emphasis> InvoiceItemChangeItemTypeID(<emphasis role="bold">var</emphasis> ARow : <emphasis role="bold">typeof</emphasis>(InvoiceItem[])) : Boolean
<emphasis role="bold">begin</emphasis>
	<emphasis role="bold">result</emphasis> := <emphasis role="bold">false</emphasis>;
	<emphasis role="bold">if not</emphasis>(IsNil(ARow.ItemType_ID)) <emphasis role="bold">then</emphasis>
	<emphasis role="bold">begin</emphasis>
		<emphasis role="bold">update</emphasis> ARow 
			<emphasis role="bold">set</emphasis> 
			{ 
				Amount := 
					LocationItem[CurrentLocationID(), ARow.ItemType_ID].Price 
			};
		<emphasis role="bold">result</emphasis> := <emphasis role="bold">true</emphasis>;
	<emphasis role="bold">end</emphasis>;
<emphasis role="bold">end</emphasis>;</programlisting>If the 
						  <phrase role="code">Location_ID</phrase> and 
						  <phrase role="code">ItemType_ID</phrase> columns were both
						  defined to be of type 
						  <phrase role="code">String</phrase>, the compiler would
						  have no way of resolving the index terms to the corresponding key columns.
						  Clearly, this is just one example of the compiler facilitating development as a
						  direct result of using types. Anywhere that operator resolution occurs will
						  also benefit from this usage.</para> 
				</sect2> 
				<sect2
				id="DDGDatabaseDesignTechniques-ScalarTypes-ScalarTypesasaLevelofIndirection"> 
					 <title><indexterm> 
								<primary>Scalar Types</primary> 
								<secondary>Indirection and</secondary> 
						  </indexterm>Scalar Types as a Level of Indirection</title> 
					 <para>One of the key benefits of using types within an
						  application is that they provide a logical layer of indirection between the
						  definition of the set of values, and the usage of those values within table and
						  variable definitions in the application. For example, suppose we have defined a
						  
						  <phrase role="code">Description</phrase> type that is the
						  set of all strings less than or equal to fifty characters in length. If the
						  application subsequently needs to expand that constraint, only the definition
						  of the 
						  <phrase role="code">Description</phrase> type needs to
						  change.</para> 
					 <para>In addition, types form a common repository for metadata
						  about values of that type. For example, the type of control to be used in the
						  presentation layer can be specified with the type definition. The title,
						  display width, and other presentation layer information, as well as storage
						  definitions can all be associated at the type level.</para> 
					 <para>That being said, it must be noted that metadata is by
						  default <emphasis>dynamic</emphasis>, meaning that will be
						  <emphasis>inherited</emphasis> or inferred by any reference to it. For example,
						  a column defined in terms of a given scalar type will inherit the dynamic tags
						  from that scalar type. Depending on the type of information being presented,
						  this can be good or bad.</para> 
					 <para>For control-level information such as the
						  <emphasis>element type</emphasis>, or <emphasis>display width</emphasis>, this
						  is useful because regardless of the context, this information will be relevant.
						  For visual indicators such as the <emphasis>title</emphasis>, this information
						  may be relevant, but it may not.</para> 
					 <para>For example, given a general purpose type such as 
						  <phrase role="code">Description</phrase>, a generic title
						  specified at the scalar type level will usually make sense no matter the
						  context in which a value of that type appears. For specific-use types such as 
						  <phrase role="code">ContactID</phrase>, however, a generic
						  title at the scalar type level may be too presumptuous. For the 
						  <phrase role="code">ID</phrase> column of the 
						  <phrase role="code">Contact</phrase> table, the title may
						  be <emphasis>ID</emphasis>, but for the 
						  <phrase role="code">Contact_ID</phrase> column within the 
						  <phrase role="code">ContactAddress</phrase> table, the type
						  is obviously still 
						  <phrase role="code">ContactID</phrase>, but the title may
						  be <emphasis>Contact ID</emphasis>. Taking these types of issues into
						  consideration as part of the design process can simplify presentation layer
						  development later.</para> 
				</sect2> 
				<sect2
				id="DDGDatabaseDesignTechniques-ScalarTypes-ScalarTypesVersusTableVariables"> 
					 <title><indexterm> 
								<primary>Scalar Types</primary> 
								<secondary>Vs. Table Variables</secondary> 
						  </indexterm><indexterm> 
								<primary>Table Variables</primary> 
								<secondary>vs. Scalar Types</secondary> 
						  </indexterm>Scalar Types Versus Table Variables</title> 
					 <para>Given that the logical representations for scalar types
						  are structurally identical to row type definitions, it is natural to ask the
						  question: What is the difference? In other words, if scalar types can be
						  arbitrarily complex, to the point that any table type definition could in fact
						  serve as the definition for a possible representation of a scalar type, what
						  justification is there for defining table variables? Why not just define
						  everything in terms of scalar types? We may also take the opposite extreme and
						  ask: why not just define everything in terms of table variables, why allow for
						  scalar types of arbitrary complexity? This section addresses these issues 
						  <footnote> 
								<para>This section is largely a summary of Appendix C:
									 A Design Dilemma of The Third Manifesto [3]. The interested reader is referred
									 to that discussion for a more exhaustive treatment of this issue.</para> 
						  </footnote>.</para> 
					 <para>To make the problem concrete, consider the following
						  simplified 
						  <phrase role="code">Contact</phrase> table: 
						  <programlisting><emphasis role="bold">create table</emphasis> Contact
{
	ID : ContactID,
	Name : ProperName,
	Phone : Phone,
	<emphasis role="bold">key</emphasis> { ID }
};</programlisting>Couldn't we also define a 
						  <phrase role="code">Contact</phrase> type that would be
						  capable of representing the same information: 
						  <programlisting><emphasis role="bold">create type</emphasis> Contact
{
	<emphasis role="bold">representation</emphasis> Contact
	{
		ID : ContactID,
		Name : ProperName,
		Phone : Phone
	}
};</programlisting>The answer, of course, is yes, but begs the question, What
						  would be gained by doing so? The first disadvantage of this approach is that in
						  order to actually store any contact information, we must still define a table
						  variable: 
						  <programlisting><emphasis role="bold">create table</emphasis> Contact
{
	Contact : Contact,
	<emphasis role="bold">key</emphasis> { Contact }
};</programlisting>But now, in order to access any of the information about a
						  given contact, we must first access the components of the representation: 
						  <programlisting><emphasis role="bold">select</emphasis> Contact <emphasis role="bold">where</emphasis> Contact.ID = 1;</programlisting>Of course, we could define a view to expose the original
						  version of the 
						  <phrase role="code">Contact</phrase> table: 
						  <programlisting><emphasis role="bold">create view</emphasis> ContactDetail
	Contact { Contact.ID ID, Contact.Name Name, Contact.Phone Phone };</programlisting>but now we are back to the original definition of the 
						  <phrase role="code">Contact</phrase> table without gaining
						  any expressive power, but having added significant complexity.</para> 
					 <para>To take the opposite extreme, consider the 
						  <phrase role="code">Coordinate</phrase> type: 
						  <programlisting><emphasis role="bold">create type</emphasis> Coordinate 
{ 
	Coordinate
	{ 
		Latitude : Degree, 
		Longitude : Degree 
	} 
};</programlisting>Obviously, rather than define this type, we could define a
						  table variable containing columns for the 
						  <phrase role="code">Latitude</phrase> and 
						  <phrase role="code">Longitude</phrase> components: 
						  <programlisting><emphasis role="bold">create table</emphasis> ZipCode
{
	ZipCode : Zip,
	...
	Latitude : Degree,
	Longitude : Degree,
	<emphasis role="bold">key</emphasis> { ZipCode }
};</programlisting>With this design however, we lose the ability to discuss the
						  coordinate as a single piece of information. This forces all operators that
						  would more naturally be defined in terms of coordinates, to be defined in terms
						  of the components of a coordinate. For example: 
						  <programlisting><emphasis role="bold">create operator</emphasis> Distance
(
	Latitude1 : Degree,
	Longitude1 : Degree,
	Latitude2 : Degree,
	Longitude2 : Degree
) : Distance;</programlisting>rather than the more natural: 
						  <programlisting><emphasis role="bold">create operator</emphasis> Distance
(
	Coordinate1 : Coordinate,
	Coordinate2 : Coordinate
) : Distance;</programlisting></para> 
					 <para>Clearly, neither extreme provides the ideal solution for
						  all cases. The key insight is that types and tables are both required, and that
						  only by combining the two elements do we take advantage of the flexibility and
						  expressive power provided by the D4 language. The answer to all these questions
						  then lies in the simple observation that scalar types should be provided at the
						  level of detail required by the application in question. Although this
						  guideline is rather subjective, the examples provided in this section should
						  illustrate the effects of moving too far in either direction.</para> 
				</sect2> 
		  </sect1> 
		  <sect1 id="DDGDatabaseDesignTechniques-Operators"> 
				<title><indexterm> 
						  <primary>Operators</primary> 
						  <secondary>Design Guidelines</secondary> 
					 </indexterm><indexterm> 
						  <primary>Database Design Techniques</primary> 
						  <secondary>Operators</secondary> 
					 </indexterm>Operators</title> 
				<para>Because operators provide the primary mechanism for modeling
					 the behavior of an application, they must also be considered as a significant
					 part of database design. Broadly, there are at least two different categories
					 of operators to be considered: operators that are provided as part of a type
					 definition in order to manipulate values of that type, and high-level operators
					 that model the process logic of the application, either as event handlers, or
					 directly invoked processes. This section discusses the various issues
					 encountered when designing and implementing operators in D4 both for
					 manipulation of user-defined types, and for modeling process logic.</para> 
				<sect2 id="DDGDatabaseDesignTechniques-Operators-Overloading"> 
					 <title><indexterm> 
								<primary>Overloading</primary> 
						  </indexterm><indexterm> 
								<primary>Operators</primary> 
								<secondary>Overloading</secondary> 
						  </indexterm>Overloading</title> 
					 <para>Operators in D4 can be <emphasis>overloaded</emphasis>.
						  In other words, two operators can share the same operator name, so long as they
						  have different signatures. The natural question then becomes: When should
						  overloads be used?</para> 
					 <para>The answer to this question is that, as a general rule,
						  the semantics of an operator should be reflected in the name of the operator.
						  By implication, the different overloads of an operator should all have the same
						  semantics.</para> 
					 <para>Operator overloading is particularly useful when defining
						  scalar types such as 
						  <phrase role="code">Distance</phrase> in the Shipping
						  application. In this case, the following overload of the multiplication
						  operator is used: 
						  <programlisting><emphasis role="bold">create operator</emphasis> iMultiplication
(
	<emphasis role="bold">const</emphasis> ADistance : Distance, 
	<emphasis role="bold">const</emphasis> ARate : ShippingRate
) : Money
<emphasis role="bold">begin</emphasis>
	<emphasis role="bold">result</emphasis> := ADistance.Miles * ARate.Rate;
<emphasis role="bold">end</emphasis>;</programlisting></para> 
					 <para>This overload enables multiplication to be used with the 
						  <phrase role="code">Distance</phrase> type just as we would
						  expect: 
						  <programlisting><emphasis role="bold">select</emphasis> Miles(12) * DollarsPerMile(10);</programlisting></para> 
					 <para>Another use for overloads is to provide defaults for
						  parameters of a given operator. For example, consider the following 
						  <phrase role="code">DateTime</phrase> overloads: 
						  <programlisting><emphasis role="bold">create operator</emphasis> DateTime
(
	<emphasis role="bold">const</emphasis> AYear : Integer,
	<emphasis role="bold">const</emphasis> AMonth : Integer,
	<emphasis role="bold">const</emphasis> ADay : Integer,
	<emphasis role="bold">const</emphasis> AHour : Integer,
	<emphasis role="bold">const</emphasis> AMinute : Integer,
	<emphasis role="bold">const</emphasis> ASecond : Integer
) : DateTime;

<emphasis role="bold">create operator</emphasis> DateTime
(
	<emphasis role="bold">const</emphasis> AYear : Integer,
	<emphasis role="bold">const</emphasis> AMonth : Integer,
	<emphasis role="bold">const</emphasis> ADay : Integer
) : DateTime
<emphasis role="bold">begin</emphasis>
	<emphasis role="bold">result</emphasis> := DateTime(AYear, AMonth, ADay, 12, 0, 0);
<emphasis role="bold">end</emphasis>;</programlisting></para> 
					 <para>The second overload simply invokes the first, providing
						  defaults for the last three parameters.</para> 
				</sect2>

      <!--<sect2>
    <title>Intuitive Error Handling</title>
    <para>Check, Is, Ensure pattern</para><para>Don't throw results</para><para>Optimistic processing (returning a list of errors during batch processing)</para>
</sect2><sect2>
    <title>Using D4 Functionally</title>
    <para>Code should be functional</para><para>Use if, case, and add expressions</para><para>Think sets, and avoid cursors</para><para>When using cursors, perform as little imperative processing as possible</para>
</sect2><sect2>
    <title>Writing Efficient Processing Code</title>
    <para>Innermost variable declarations</para><para>Declare variables to store the results of expressions rather than recalculating the results</para>
</sect2>-->
				<sect2
				id="DDGDatabaseDesignTechniques-Operators-Method-StyleInvocation"> 
					 <title><indexterm> 
								<primary>Method-Style Invocation</primary> 
						  </indexterm><indexterm> 
								<primary>Operators</primary> 
								<secondary>Method-Style Invocation</secondary> 
						  </indexterm>Method-Style Invocation</title> 
					 <para>For any given operator, D4 allows standard invocation, as
						  well as object-oriented style "method" invocation using the dot (<phrase
						  role="code">.</phrase>) operator. Because of this we may reasonably ask: Which
						  one is better? When should one be used over the other?</para> 
					 <para>The reason that both styles are included in the language
						  is to allow for personal taste to dictate usage. That being said, conventions
						  should be put in place once an invocation style is agreed upon within an
						  organization.</para> 
					 <para>However, it should be noted that the different invocation
						  styles tend to change the conceptual meaning of the invocation. Taking a step
						  back, the reason that we have computer languages in the first place is to
						  enable us as humans to express formal instructions in a way that is as close to
						  our native language as possible. In other words, we would like the code we
						  write to be as readable as possible, while still understood by the compiler. To
						  this end, we choose names for the objects we reference in our expressions that
						  match the intended meaning.</para> 
					 <para>For example, we provide the 
						  <phrase role="code">Split</phrase> operator to
						  <emphasis>split</emphasis> a string into components, based on some set of
						  delimiters. Naming the operator in this way we intuitively know what it does
						  when we read an invocation in some expression: 
						  <programlisting><emphasis role="bold">var</emphasis> LStrings := Split(AString, ',');</programlisting>This is in contrast to the absurd: 
						  <programlisting><emphasis role="bold">var</emphasis> LVar1 := StringOperator1(AString, ',');</programlisting>Not to belabor the point, but the importance of choosing names
						  carefully cannot be overstated. In object-oriented style invocation, we have: 
						  <programlisting><emphasis role="bold">var</emphasis> LStrings := AString.Split(',');</programlisting>In this case the meaning is still abundantly clear, but some
						  would argue that this style of invocation is more intuitive, or at the very
						  least, more familiar to someone with a background in today's programming
						  languages. But consider what happens when we use a different operator in this
						  way: 
						  <programlisting><emphasis role="bold">var</emphasis> LIndex := Pos(',', AString);</programlisting>Using this style of invocation, the 
						  <phrase role="code">Pos</phrase> operator intuitively
						  reads: The position of <emphasis>this</emphasis> (<phrase
						  role="code">','</phrase>) string in <emphasis>that</emphasis> (<phrase
						  role="code">AString</phrase>) string. Using method-style invocation however, we
						  have: 
						  <programlisting><emphasis role="bold">var</emphasis> LIndex := ','.Pos(AString);</programlisting>which is completely the opposite of what we would intuitively
						  want to express. To this end, the D4 string library actually includes 
						  <phrase role="code">IndexOf</phrase>, which reverses the
						  order of the arguments to allow for this style of invocation: 
						  <programlisting><emphasis role="bold">var</emphasis> LIndex := AString.IndexOf(',');</programlisting>which reads: Given the string (<phrase
						  role="code">AString</phrase>), find the index of this string (<phrase
						  role="code">','</phrase>). Clearly, then, the choice of invocation style
						  affects how we intuitively read operator invocations within expressions, and
						  hence the names that will be chosen for a given operator. To this end, we
						  recommend that the naming convention for operators be consistent with the
						  convention for invocation style.</para> 
				</sect2> 
		  </sect1> 
		  <sect1 id="DDGDatabaseDesignTechniques-TableVariables"> 
				<title><indexterm> 
						  <primary>Table Variables</primary> 
						  <secondary>Design Guidelines</secondary> 
					 </indexterm><indexterm> 
						  <primary>Database Design Techniques</primary> 
						  <secondary>Table Variables</secondary> 
					 </indexterm>Table Variables</title> 
				<para>Table variables are arguably the most important product of
					 database design. They correspond to the concepts of the problem domain being
					 modeled, and the statements we wish to make about them. In addition, through
					 table-valued expressions, they provide the mechanism for answering questions
					 about the problem domain based on the current state of the database. This
					 section contains several discussions relating to the design of table variables
					 in a database.</para> 
				<sect2
				 id="DDGDatabaseDesignTechniques-TableVariables-Normalization"> 
					 <title><indexterm> 
								<primary>Normalization</primary> 
						  </indexterm><indexterm> 
								<primary>Table Variables</primary> 
								<secondary>Normalization</secondary> 
						  </indexterm>Normalization</title> 
					 <para>Any discussion of database design will inevitably arrive
						  at the concept of <emphasis>normalization</emphasis>. Normalization is the
						  process of producing a set of table variable definitions that are in some
						  <emphasis>normal form</emphasis>. <emphasis>Normalization theory</emphasis> is
						  the formal basis for this process and an active branch of database
						  theory.</para> 
					 <para>An exhaustive treatment of normalization is beyond the
						  scope of this guide, but the discussion will attempt to provide a general
						  overview of the process, and why it is important.</para> 
					 <para>Intuitively, normalization simply involves identifying
						  the key concepts, and ensuring that each table variable definition corresponds
						  with one, and only one, concept in the problem domain. To put it another way,
						  every column in a fully normalized table definition depends on the key, the
						  whole key, and nothing but the key.</para> 
					 <para>As a discipline, normalization seeks to identify certain
						  types of redundancy with the intention of providing a formal basis for removing
						  it. In general, redundancy in database design leads to <emphasis>update
						  anomalies</emphasis>, or inconsistencies in the data due to updates that affect
						  only part of a redundant set of information. Normalization removes these
						  certain types of redundancies, and avoids the resulting update
						  anomalies.</para> 
					 <para>At this point it should be noted that redundancy in and
						  of itself is not necessarily a problem. Representing the same information in
						  different ways can be useful for a variety of practical reasons. The problem is
						  <emphasis>uncontrolled</emphasis> redundancy. If the same information is
						  represented in different ways, and an update operation changes only one of the
						  representations, the database is inconsistent.</para> 
					 <para>As long as redundancy is controlled, either with a
						  constraint, or using event handlers to synchronize different representations,
						  the system remains consistent.</para> 
					 <para>For more information on normalization, refer to the
						  recommended reading section at the end of this chapter.</para> 
				</sect2> 
				<sect2
				 id="DDGDatabaseDesignTechniques-TableVariables-PhysicalConsiderations"> 
					 <title><indexterm> 
								<primary>Physical Considerations</primary> 
						  </indexterm><indexterm> 
								<primary>Table Variables</primary> 
								<secondary>Physical Considerations</secondary> 
						  </indexterm><indexterm> 
								<primary>Denormalization</primary> 
						  </indexterm>Physical Considerations</title> 
					 <para>Generally speaking, fully normalized database designs are
						  the most desirable. They do not suffer from the various update anomalies that
						  arise in connection with storing redundant information, and therefore do not
						  require special constraint enforcement or update propagation to control the
						  redundancy.</para> 
					 <para>In many ways, Dataphor enables, and even encourages, more
						  normalized designs. However, the Dataphor platform is not immune from the
						  physical characteristics of existing systems. Usage patterns in each
						  application will be different and performance issues may arise as applications
						  scale in terms of number of users, and data volume.</para> 
					 <para>The process of <emphasis>denormalization</emphasis>
						  refers to the deliberate introduction of redundancy in order to improve the
						  performance of certain queries against the database. While there are practical
						  cases for denormalization, there is <emphasis>always</emphasis> a trade-off to
						  be made.</para> 
					 <para>That trade-off is the additional performance cost and
						  development complexity of controlling the redundancy introduced by the
						  denormalization. If the redundancy is not controlled, the database will
						  inevitably be updated in such a way that the data becomes inconsistent, and any
						  performance gains that may have been achieved by the denormalization are far
						  outweighed by the fact that the database is now incorrect, and will in general
						  produce wrong answers.</para> 
					 <para>In addition, any performance gains achieved by the
						  denormalization, usually for retrieval based queries, will be offset by the
						  performance cost associated with controlling the redundancy, usually for
						  modification operations.</para> 
					 <para>In short, denormalization should always be used
						  carefully, and only when the costs and benefits are fully understood. We
						  therefore recommend starting with a fully normalized design, and only
						  introducing controlled redundancy when it is absolutely necessary. In addition,
						  each denormalization decision should be documented fully with the
						  application.</para> 
					 <para>For more information on denormalization, refer to the
						  recommended reading section at the end of this chapter.</para> 
				</sect2>

      <!--<sect2>
    <title>Views</title>
    <para>Take advantage of syntactic optimization (chunking)</para><para>Views constitute APIs, sort of</para><para>Views can be used to enforce security</para><para>Column naming issues</para><para>Avoid natural outer joins (needs to be said somewhere, not necessarily here)</para><para>Use projections (only get what you need, insulates you from change, as well as potential for performance)</para>
</sect2><sect2>
    <title>Metadata</title>
    <para>table-level tags should be static? presentation layer discussion?</para></sect2>-->
		  </sect1> 
		  <sect1 id="DDGDatabaseDesignTechniques-Constraints"> 
				<title><indexterm> 
						  <primary>Constraints</primary> 
						  <secondary>Design Guidelines</secondary> 
					 </indexterm><indexterm> 
						  <primary>Database Design Techniques</primary> 
						  <secondary>Constraints</secondary> 
					 </indexterm>Constraints</title> 
				<para>The various types of constraints available within the D4
					 language provide an extremely powerful medium for enforcing the business rules
					 of an application. Perhaps the most important point to be made in conjunction
					 with constraints is that they should be used as much as possible.</para> 
				<para>Whenever a business requirement can be expressed as a
					 constraint, it should be. Not only will the constraint definition serve to
					 ensure that the data in the database conforms to established business policies,
					 each constraint definition provides the system with more information about the
					 meaning of the data.</para> 
				<para>This section discusses some of the issues that arise in
					 connection with defining constraints in a Dataphor application.</para> 
				<sect2
				 id="DDGDatabaseDesignTechniques-Constraints-TypeVersusColumnandRowConstraints">
					 
					 <title><indexterm> 
								<primary>Type Constraints</primary> 
								<secondary>vs. Column and Row Constraints</secondary> 
						  </indexterm><indexterm> 
								<primary>Constraints</primary> 
								<secondary>Type Vs. Column and Row
									 Constraints</secondary> 
						  </indexterm><indexterm> 
								<primary>Row Constraints</primary> 
								<secondary>vs. Type Constraints</secondary> 
						  </indexterm><indexterm> 
								<primary>Column Constraints</primary> 
								<secondary>vs. Type Constraints</secondary> 
						  </indexterm>Type Versus Column and Row Constraints</title> 
					 <para>Because D4 provides for several different levels of
						  constraints, a natural question to ask is: when should each type of constraint
						  be used? For keys and references, the answer is trivial, but for type-,
						  column-, and row-level constraints, the answer is not as obvious.</para> 
					 <para>For example, we may ask: what is the benefit of defining
						  a constraint on a type, rather than a column? Conversely, we may wonder whether
						  there is ever a reason to define a constraint on a column, rather than a type.
						  The answer to this question lies in the observation that type constraints and
						  column constraints are fundamentally different things.</para> 
					 <para>A type constraint specifies the set of valid values for a
						  given type, whereas a column constraint restricts the values that may be
						  assigned to a particular variable, namely the column of each row within a table
						  variable. In other words, the column-level constraint, like all the other
						  categories of constraints, involves a <emphasis>variable</emphasis> within the
						  database. The type constraint does not.</para> 
					 <para>With this insight, we can easily distinguish between
						  constraints that describe the valid set of values for a type, and constraints
						  that would restrict the values for a variable. For example, the 
						  <phrase role="code">NameSince</phrase> column in the 
						  <phrase role="code">Contact</phrase> table in the Shipping
						  application includes a constraint that requires the value of the column to be
						  less than or equal to the current date and time. Clearly, this is not a
						  restriction on the valid values for the type, rather it is a restriction on the
						  values that constitute valid data for the variable in question.</para> 
					 <para>To differentiate between the usage of column and row
						  constraints, several points should be made: 
						  <itemizedlist> 
								<listitem> 
									 <para>Column constraints cannot reference global
										  state.</para> 
									 <para>As a result, row constraints are more
										  powerful in terms of the business rules that can be enforced with them. To put
										  it another way, row constraints can always be used to enforce column
										  constraints, but the reverse is not true in general.</para> 
								</listitem> 
								<listitem> 
									 <para>Column constraints cannot be transition
										  constraints.</para> 
									 <para>Again, only row-level constraints can specify
										  transitions.</para> 
								</listitem> 
								<listitem> 
									 <para>Column constraints will be checked
										  immediately during data entry, providing the user with immediate feedback if
										  something is wrong. Row-level constraints, by contrast, will be checked as part
										  of a validation phase when accepting the entire entry.</para> 
								</listitem> 
						  </itemizedlist></para> 
					 <para>With these points in mind, a general guideline emerges,
						  namely that constraints should be specified at the most specific point
						  possible. In other words, if a constraint can be expressed as a type-level
						  constraint, it should be. Similarly, if it can be expressed as a column-level
						  constraint, it should be. Only if the constraint expression references multiple
						  columns in the table, or multiple tables, should row-level or higher
						  constraints be used.</para> 
				</sect2> 
				<sect2
				 id="DDGDatabaseDesignTechniques-Constraints-User-FriendlyConstraints"> 
					 <title><indexterm> 
								<primary>User-Friendly Constraints</primary> 
						  </indexterm><indexterm> 
								<primary>Constraints</primary> 
								<secondary>User-Friendly Constraints</secondary> 
						  </indexterm>User-Friendly Constraints</title> 
					 <para>From a development standpoint, constraints are critical
						  mechanisms for ensuring the integrity of the data in the database. From the
						  end-user's standpoint, however, constraints are seen largely as a nuisance.
						  There are at least two ways to minimize the perceived negative impact of
						  constraint enforcement by the user's of an application.</para> 
					 <para>First, constraint definitions in D4 can include a custom
						  violation message that will be displayed to the user when the constraint is
						  violated. Take advantage of this feature. Clear and concise error messages can
						  be the difference between a good user-interface experience, and a frustrated
						  user. Along these same lines, constraint expressions consisting of multiple
						  conditions should be broken out into multiple constraint definitions, each with
						  a specific message describing the condition. This will help the user identify
						  which part of the constraint has been violated.</para> 
					 <para>Second, business rules can be enforced
						  <emphasis>actively</emphasis> by the system using event handlers. Active
						  enforcement for a constraint means that the system will take steps to ensure
						  that a constraint is satisfied, rather than raising an error and requiring the
						  user to resolve the issue.</para> 
					 <para>For example, suppose a contact must always have a primary
						  phone number specified among the list of phone numbers for that contact. The
						  user-interface to satisfy this requirement may involve simply providing an
						  editable indicator for each phone number showing whether or not it is the
						  primary phone number for the contact. Rather than require the user to select a
						  phone number as primary by raising an error, the system could simply select
						  one. In this way, the constraint is enforced, but the user is not required to
						  take any extra action.</para> 
				</sect2> 
				<sect2 id="DDGDatabaseDesignTechniques-Constraints-Keys"> 
					 <title><indexterm> 
								<primary>Keys</primary> 
								<secondary>Design Techniques</secondary> 
						  </indexterm>Keys</title> 
					 <para>Keys form the basis for identity in the database. They
						  form the sole logical addressing mechanism within the D4 language. In addition,
						  keys are one of the primary means of declaring the meaning of the data in the
						  database to the system. Key inference is one of the primary enabling factors in
						  the advanced capabilities of the Dataphor platform such as view updatability
						  and query elaboration.</para> 
					 <para>Because of this importance, it is critical to specify
						  <emphasis>all</emphasis> keys completely. We note for emphasis that D4 does not
						  have the concept of a primary key, and that multiple keys can and should be
						  declared where appropriate.</para> 
					 <sect3 id="DDGSurrogateVersusNaturalKeys"> 
						  <title><indexterm> 
									 <primary>Surrogate Keys</primary> 
									 <secondary>Vs. Natural Keys</secondary> 
								</indexterm><indexterm> 
									 <primary>Natural Keys</primary> 
									 <secondary>Vs. Surrogate Keys</secondary> 
								</indexterm><indexterm> 
									 <primary>Keys</primary> 
									 <secondary>Surrogate Vs. Natural Keys</secondary> 
								</indexterm>Surrogate Versus Natural Keys</title> 
						  <para>A <emphasis>natural</emphasis> key is one that occurs
								naturally within the problem domain, such as Social Security Number 
								<footnote> 
									 <para>It may be immediately argued that SSN is not
										  a very good natural key for a variety of reasons, not the least of which is
										  that not everyone has one, and even among those that do, they are not
										  necessarily unique. Nevertheless, the point is clear, and the example useful
										  for that reason.</para> 
								</footnote>. A <emphasis>surrogate</emphasis> key, by
								contrast, is one in which the unique identifiers are generated in some way,
								usually by the system.</para> 
						  <para>It should be noted that natural keys are extremely
								rare in practice. This is not to say that they do not exist, nor to imply that
								surrogate keys should always be used. We simply note that natural keys should
								be selected with extreme caution. In addition, we stress that the selection of
								keys, especially the choice between surrogate and natural keys, is somewhat
								subjective and situational. The following list details some general guidelines
								that can be useful in the process of selecting a key: 
								<itemizedlist> 
									 <listitem> 
										  <para>Keys should be static</para> 
										  <para>Key values should be fixed for all time.
												If some attribute of a given entity is unique, but is constantly changing, it
												is probably not a good choice for a key.</para> 
									 </listitem> 
									 <listitem> 
										  <para>Keys should be stable</para> 
										  <para>The real world definition should be
												commonly used and accepted, from an authoritative body (i.e. a standards body,
												government, or industry convention), and unlikely to change definition within
												the life of the system.</para> 
									 </listitem> 
									 <listitem> 
										  <para>Keys should be unique</para> 
										  <para>Of course this sounds like a trivial
												observation, but before a natural key is selected, it should be an absolute
												guarantee that the values in question will always be unique. If there is even a
												possibility that the values will be duplicate, use a surrogate key.</para> 
									 </listitem> 
									 <listitem> 
										  <para>Keys should be simple</para> 
										  <para>Even though a combination of several
												attributes of a given entity may constitute a unique identifier, it may be
												desirable to select a more simple key. This is of course subjective, and the
												next section will discuss some issues surrounding the compound versus surrogate
												key choice.</para> 
									 </listitem> 
									 <listitem> 
										  <para>Keys should be digestible</para> 
										  <para>Remember that even surrogate keys will be
												viewed by humans. If not by the users of the application directly, at least by
												administrators or other developers. While GUIDs (Globally Unique Identifiers
												usually represented as 36 character strings) do provide a simple generator for
												unique identifiers, in practice they are extremely cumbersome to work with if
												the need arises.</para> 
									 </listitem> 
								</itemizedlist></para> 
					 </sect3> 
					 <sect3 id="DDGSurrogateVersusCompoundKeys"> 
						  <title><indexterm> 
									 <primary>Surrogate Keys</primary> 
									 <secondary>Vs. Compound Keys</secondary> 
								</indexterm><indexterm> 
									 <primary>Compound Keys</primary> 
									 <secondary>Vs. Surrogate Keys</secondary> 
								</indexterm><indexterm> 
									 <primary>Keys</primary> 
									 <secondary>Surrogate Vs. Compound Keys</secondary> 
								</indexterm>Surrogate Versus Compound Keys</title> 
						  <para>Another issue surrounding the selection of keys is
								the choice between using a <emphasis>compound</emphasis>, or multi-column, key,
								and using a surrogate key. Database designs will almost always include
								<emphasis>detail</emphasis> tables that associate multiple rows of information
								with every row of a particular <emphasis>master</emphasis> table.</para> 
						  <para>In these types of relationships, there is usually a
								reference from the detail table to the master table to enforce referential
								integrity. When there is no natural key to be had for the detail table,
								selecting the surrogate can be done in two different ways.</para> 
						  <para>First, a new surrogate key can be defined using a
								generator for the detail table as though it were a stand-alone entity. Second,
								a detail-specific generator can be introduced that is unique only within the
								master key.</para> 
						  <para>Here is an example of using surrogate keys for detail
								tables: 
								<programlisting><emphasis role="bold">create table</emphasis> ContactAddress
{
	ID : ContactAddressID,
	Contact_ID : ContactID,
	...,
	<emphasis role="bold">key</emphasis> { ID }
};</programlisting></para> 
						  <para>In this design, 
								<phrase role="code">ID</phrase> is unique for all 
								<phrase role="code">ContactAddress</phrase>
								rows.</para> 
						  <para>Here is an alternate design for the 
								<phrase role="code">ContactAddress</phrase> table
								utilizing a compound key: 
								<programlisting><emphasis role="bold">create table</emphasis> ContactAddress
{
	Contact_ID : ContactID,
	Number : Integer,
	...,
	<emphasis role="bold">key</emphasis> { Contact_ID, Number }
};</programlisting></para> 
						  <para>In this design, 
								<phrase role="code">Number</phrase> is only unique
								within a given contact, i.e. multiple contacts may have an address numbered 
								<phrase role="code">1</phrase>.</para> 
						  <para>The following sections will consider some of the
								advantages and disadvantages of each design with respect to implementation,
								expression queries, and enforcing constraints.</para> 
						  <sect4 id="DDGImplementingGenerators"> 
								<title>Implementing Generators</title> 
								<para>The first difference between the two approaches
									 appears in the implementation of the generator. For the surrogate key design,
									 the new key value is not required to be unique within the selected master key,
									 so the surrogate can be generated in the same way that other surrogates are
									 generated.</para> 
								<para>For the compound key approach, the 
									 <phrase role="code">Number</phrase> column must be
									 unique within the given 
									 <phrase role="code">Contact_ID</phrase>, and so a
									 special-purpose generator must be provided. This can be done either by building
									 a specific generator table, as is the case with the 
									 <phrase role="code">InvoiceItem</phrase> table in
									 the Shipping application, or by using the current maximum number plus one, as
									 is the case with the 
									 <phrase role="code">ContactAddress</phrase> table
									 in the Shipping application.</para> 
								<para>Note that both of these approaches to the
									 implementation of a compound key generator have concurrency implications.
									 However, this is usually not an issue, as the master key generally coincides
									 with the desired granularity for concurrency.</para> 
						  </sect4> 
						  <sect4 id="DDGExpressingQueries"> 
								<title>Expressing Queries</title> 
								<para>The second difference between the two approaches
									 is that some queries are expressed more easily against one, and some are
									 expressed more easily against the other. For example, suppose each item on an
									 order could be shipped to a separate address: 
									 <programlisting><emphasis role="bold">create table</emphasis> OrderItem
{
	ID : OrderItemID,
	Order_ID : OrderID,
	...,
	ContactAddress_ID : ContactAddressID,
	<emphasis role="bold">key</emphasis> { ID }
};</programlisting></para> 
								<para>Given this design, the following query could be
									 used to retrieve the name of the contact: 
									 <programlisting><emphasis role="bold">select</emphasis> OrderItem 
	<emphasis role="bold">join</emphasis> (Order { ID Order_ID, Contact_ID }) 
		<emphasis role="bold">join</emphasis> (Contact { ID Contact_ID, Name });</programlisting>The equivalent design using compound keys: 
									 <programlisting><emphasis role="bold">create table</emphasis> OrderItem
{
	Order_ID : OrderID,
	Number : Integer,
	Contact_ID,
	Address_Number,
	...,
	<emphasis role="bold">key</emphasis> { Order_ID, Number }
};</programlisting>allows the query to be written: 
									 <programlisting><emphasis role="bold">select</emphasis> OrderItem
	<emphasis role="bold">join</emphasis> (Contact { ID Contact_ID, Name });</programlisting></para> 
								<para>Using these same designs, queries using
									 conditioned joins are easier to express in the surrogate key approach: 
									 <programlisting><emphasis role="bold">select</emphasis> OrderItem <emphasis role="bold">rename</emphasis> OI
	<emphasis role="bold">join</emphasis> (ContactAddress <emphasis role="bold">rename</emphasis> CA)
		<emphasis role="bold">by</emphasis> OI.ContactAddress_ID = CA.ID;</programlisting>And the compound key formulation: 
									 <programlisting><emphasis role="bold">select</emphasis> OrderItem <emphasis role="bold">rename</emphasis> OI
	<emphasis role="bold">join</emphasis> (ContactAddress <emphasis role="bold">rename</emphasis> CA)
		<emphasis role="bold">by</emphasis> OI.Contact_ID = CA.Contact_ID
			<emphasis role="bold">and</emphasis> OI.Address_Number = CA.Number</programlisting></para> 
						  </sect4> 
						  <sect4 id="DDGEnforcingReferences"> 
								<title>Enforcing References</title> 
								<para>Another significant different between the two
									 approaches is that using the surrogate key design, there is reduced dependency
									 on the data being referenced. This can be both an advantage and a disadvantage,
									 depending on the specific circumstances involved.</para> 
								<para>For example, using the surrogate 
									 <phrase role="code">ContactAddress</phrase> design,
									 because the key value is independent of the contact, a given address may be
									 "moved" to a different contact without affecting references to that contact
									 address.</para> 
								<para>However, using the compound key approach, there
									 is more information present in the key, which allows certain reference
									 constraints to be enforced more easily. For example, consider the following
									 table definition: 
									 <programlisting><emphasis role="bold">create table</emphasis> Order
{
	ID : OrderID,
	Contact_ID : ContactID,
	Address_Number : Integer,
	<emphasis role="bold">key</emphasis> { ID }
};</programlisting>In this design, an order is placed by a particular contact,
									 and the shipping address is selected, presumably from the set of addresses for
									 that contact. With the compound key design, the reference already enforces that
									 the address is for the contact placing the order.</para> 
								<para>With the surrogate key design, we must declare an
									 additional constraint to ensure that the address being selected is an address
									 of the contact placing the order. Note that this can be accomplished in this
									 case with a reference because references can target superkeys, but this
									 information is not always readily available, as in the previous 
									 <phrase role="code">OrderItem</phrase> design for
									 example.</para> 
								<para>Ultimately, the choice must be made by weighing
									 the relative advantages and disadvantages of each approach for the specific
									 circumstances. Any decision should consider the implications not only for
									 development and system implementation, but for query expression and usability
									 of the resulting design.</para> 
						  </sect4> 
					 </sect3> 
				</sect2> 
				<sect2 id="DDGDatabaseDesignTechniques-Constraints-References"> 
					 <title><indexterm> 
								<primary>References</primary> 
								<secondary>Design Techniques</secondary> 
						  </indexterm>References</title> 
					 <para>In addition to keys, references form a critical component
						  of the design of any database. Next to keys, they are perhaps the most common
						  type of constraint, and are used not only to enforce referential integrity, but
						  to enable the more sophisticated features of the Dataphor Frontend such as
						  query elaboration and user-interface derivation.</para> 
					 <para>As a result, references should
						  <emphasis>always</emphasis> be declared. Note that this does not necessarily
						  imply enforcement, as we shall discuss in the following sections.</para> 
					 <sect3 id="DDGReferencingSuperkeys"> 
						  <title><indexterm> 
									 <primary>References</primary> 
									 <secondary>Referencing Superkeys</secondary> 
								</indexterm>Referencing Superkeys</title> 
						  <para>An important aspect of references is that they are
								allowed to target <emphasis>superkeys</emphasis>. In other words, as long as
								the target columns of the reference completely include some key of the target
								table variable, the reference is allowed. This fact is useful for enforcing
								additional constraints that would otherwise require hand-written transition
								constraints to enforce. For example, consider the following table definitions: 
								<programlisting><emphasis role="bold">create table</emphasis> LocationItemType
{
	Location_ID : LocationID,
	ItemType_ID : ItemTypeID,
	<emphasis role="bold">key</emphasis> { Location_ID, ItemType_ID },
	<emphasis role="bold">reference</emphasis> LocationItemType_Location { Location_ID }
		<emphasis role="bold">references</emphasis> Location { ID },
	<emphasis role="bold">reference</emphasis> LocationItemType_ItemType { ItemType_ID }
		<emphasis role="bold">references</emphasis> ItemType { ID }
};

<emphasis role="bold">create table</emphasis> Invoice
{
	ID : InvoiceID,
	Location_ID : LocationID,
	...,
	<emphasis role="bold">key</emphasis> { ID },
	<emphasis role="bold">reference</emphasis> Invoice_Location { Location_ID }
		<emphasis role="bold">references</emphasis> Location { ID }
};

<emphasis role="bold">create table</emphasis> InvoiceItem
{
	Invoice_ID : InvoiceID,
	Location_ID : LocationID,
	ItemType_ID : ItemTypeID,
	...,
	<emphasis role="bold">key</emphasis> { Invoice_ID, ItemType_ID },
	<emphasis role="bold">reference</emphasis> InvoiceItem_Invoice { Invoice_ID, Location_ID }
		<emphasis role="bold">references</emphasis> Invoice { ID, Location_ID },
	<emphasis role="bold">reference</emphasis> InvoiceItem_LocationItemType { Location_ID, ItemType_ID }
		<emphasis role="bold">references</emphasis> LocationItem { Location_ID, ItemType_ID }
};</programlisting></para> 
						  <para>In this design, the invoice items are required to be
								specified at a particular location. Obviously, the constraint should be
								enforced that the items on an invoice are available at the location at which
								the invoice is being placed. This constraint is enforced by the 
								<phrase role="code">InvoiceItem_Invoice</phrase>
								reference, which targets the superkey 
								<phrase role="code">{ ID, Location_ID }</phrase> of the
								
								<phrase role="code">Invoice</phrase> table.</para> 
					 </sect3> 
					 <sect3 id="DDGUsingReferentialActions"> 
						  <title><indexterm> 
									 <primary>Referential Actions</primary> 
								</indexterm><indexterm> 
									 <primary>References</primary> 
									 <secondary>Referential Actions</secondary> 
								</indexterm>Using Referential Actions</title> 
						  <para>Referential actions provide an
								<emphasis>active</emphasis> enforcement option for referential integrity
								constraints, but care should be taken when using these features. As a general
								rule, cascading updates and deletes should only be used in cases where the
								cascading action will affect only pure detail and extension data for the target
								of the reference.</para> 
						  <para>In other words, if the information in the detail or
								extension table has no independent identity, cascading actions may be
								appropriate. For example, given the following table definitions: 
								<programlisting><emphasis role="bold">create table</emphasis> EmployeeType
{
	ID : EmployeeTypeID,
	...,
	<emphasis role="bold">key</emphasis> { ID }
};

<emphasis role="bold">create table</emphasis> Employee
{
	ID : EmployeeID,
	Type_ID : EmployeeTypeID,
	...,
	<emphasis role="bold">key</emphasis> { ID },
	<emphasis role="bold">reference</emphasis> Employee_EmployeeType { Type_ID }
		<emphasis role="bold">references</emphasis> EmployeeType { ID }
};

<emphasis role="bold">create table</emphasis> EmployeeAddress
{
	Employee_ID : EmployeeID,
	...,
	<emphasis role="bold">key</emphasis> { Employee_ID },
	<emphasis role="bold">reference</emphasis> EmployeeAddress_Employee { Employee_ID }
		<emphasis role="bold">references</emphasis> Employee { ID }
		<emphasis role="bold">update cascade delete cascade</emphasis>
}

<emphasis role="bold">create table</emphasis> EmployeePhone
{
	Employee_ID : EmployeeID,
	Phone : Phone,
	...,
	<emphasis role="bold">key</emphasis> { Employee_ID, Phone },
	<emphasis role="bold">reference</emphasis> EmployeePhone_Employee { Employee_ID }
		<emphasis role="bold">references</emphasis> Employee { ID }
		<emphasis role="bold">update cascade delete cascade</emphasis>
};</programlisting></para> 
					 </sect3> 
					 <sect3 id="DDGUnenforcedReferences"> 
						  <title><indexterm> 
									 <primary>Unenforced References</primary> 
								</indexterm><indexterm> 
									 <primary>References</primary> 
									 <secondary>Unenforced References</secondary> 
								</indexterm>Unenforced References</title> 
						  <para>Because references form the basis for user-interface
								derivation in the Frontend, references can be used simply to guide derivation,
								rather than enforcing an actual constraint.</para> 
						  <para>For example, consider the following table
								definitions: 
								<programlisting><emphasis role="bold">create table</emphasis> ContactDescription
{
	Description : Description,
	<emphasis role="bold">key</emphasis> { Description }
};

<emphasis role="bold">create table</emphasis> Contact
{
	ID : ContactID,
	Description : Description,
	...,
	<emphasis role="bold">key</emphasis> { ID }
};</programlisting>In this design the 
								<phrase role="code">Description</phrase> column of the 
								<phrase role="code">Contact</phrase> table may or may
								not draw its value from the 
								<phrase role="code">ContactDescription</phrase> table.
								The lookup list is merely a convenience for data entry for the end-users.
								Rather than build the user-interface for this manually in the Frontend, we can
								simply declare an unenforced reference: 
								<programlisting><emphasis role="bold">create reference</emphasis> Contact_ContactDescription
	Contact { Description }
	<emphasis role="bold">references</emphasis> ContactDescription { Description }
	<emphasis role="bold">tags</emphasis> { DAE.Enforced = "false" };</programlisting>With the 
								<phrase role="code">DAE.Enforced</phrase> tag set to
								false, the Dataphor Server will not enforce the constraint. Regardless of this
								setting, the reference is still part of the application schema and will be
								inferred just as any other reference would.</para> 
						  <para>This pattern is particularly useful for exposing
								relationships between views defined in the application schema. So much so that
								by default, references involving views are not enforced by the Dataphor
								Server.</para>

          <!--Transitive references???-->
						  <para>Another usage for an unenforced reference is to allow
								the target system to enforce the constraint. For example, if an existing
								database schema has foreign keys declared, the references can still be defined
								in the Dataphor Server, but enforced by the target system. Note that this
								strategy would be subject to deferred constraint checking in the target system,
								and that not all DBMSs support this functionality.</para> 
					 </sect3> 
					 <sect3 id="DDGImmediateVersusDeferredChecking"> 
						  <title><indexterm> 
									 <primary>Immediate Vs. Deferred Checking</primary> 
								</indexterm><indexterm> 
									 <primary>References</primary> 
									 <secondary>Immediate Vs. Deferred
										  Checking</secondary> 
								</indexterm>Immediate Versus Deferred Checking</title> 
						  <para>References, like any database-level constraint, will
								be checked <emphasis>deferred</emphasis> by default. Rather than evaluating the
								constraint enforcement expression immediately, the Dataphor Server records the
								row causing the constraint check, and actually performs the check as part of a
								validation phase during transaction commit.</para> 
						  <para>This deferred checking is necessary in general with
								references because there is no guarantee that the updates involved will be
								performed in the correct order. For example, when inserting a 
								<phrase role="code">ContactPhone</phrase> row, the 
								<phrase role="code">Contact</phrase> row that it
								references must already be present in the system.</para> 
						  <para>However, for lookup references, this deferred
								checking is unnecessary. For example, consider the following table definitions:
								
								<programlisting><emphasis role="bold">create table</emphasis> EmployeeType
{
	ID : EmployeeTypeID,
	Description,
	<emphasis role="bold">key</emphasis> { ID }
};

<emphasis role="bold">create table</emphasis> Employee
{
	ID : EmployeeID,
	Type_ID : EmployeeTypeID,
	...,
	<emphasis role="bold">key</emphasis> { ID },
	<emphasis role="bold">reference</emphasis> Employee_EmployeeType { Type_ID }
		<emphasis role="bold">references</emphasis> EmployeeType { ID }
		<emphasis role="bold">tags</emphasis> { DAE.IsDeferred = "false" }
};</programlisting>When entering an 
								<phrase role="code">Employee</phrase>, the
								corresponding 
								<phrase role="code">EmployeeType</phrase> will already
								be present in the database when the entry is posted. In this case, the
								constraint can be checked immediately. This is done by setting the 
								<phrase role="code">DAE.IsDeferred</phrase> tag to
								false. Note that this is only valid if the 
								<phrase role="code">Employee</phrase> row will always
								be entered after the 
								<phrase role="code">EmployeeType</phrase> row. In other
								words, this enforcement strategy depends on certain user-interface
								patterns.</para> 
					 </sect3> 
				</sect2> 
		  </sect1> 
		  <sect1 id="DDGDatabaseDesignTechniques-RepresentingTemporalData"> 
				<title><indexterm> 
						  <primary>Temporal Data</primary> 
					 </indexterm><indexterm> 
						  <primary>Database Design Techniques</primary> 
						  <secondary>Temporal Data</secondary> 
					 </indexterm>Representing Temporal Data</title> 
				<para>The problem of representing temporal, or time-related, data
					 is surprisingly complex and has been the subject of much research. This section
					 discusses some of these issues, and some of the design guidelines that have
					 been proposed in the book 
					 <citetitle>Temporal Data and the Relational Model</citetitle>
					 [19]. In fact, the discussion that follows is largely a summary of the database
					 design proposals in this reference, and is necessarily lacking in detail. For
					 an exhaustive treatment of these issues, the interested reader is referred to
					 that work.</para> 
				<para>One of the key insights of the approach identified in
					 reference [19] is that databases are variables, i.e. time-varying, and
					 therefore the idea of <emphasis>temporalization</emphasis> as it has been
					 called in the literature applies generally to any data that may be stored in a
					 database, not just to historical information.</para> 
				<para><indexterm> 
						  <primary>Semitemporalized</primary> 
					 </indexterm><indexterm> 
						  <primary>Fully Temporalized</primary> 
					 </indexterm>With this in mind, the authors approach the problem
					 of storing information <emphasis>semitemporalized</emphasis> (i.e. Some fact
					 has been true <emphasis>since</emphasis> some time), and <emphasis>fully
					 temporalized</emphasis> (i.e. Some fact was true <emphasis>during</emphasis>
					 some interval).</para> 
				<para>The obvious approach to storing these
					 <emphasis>timestamped</emphasis> propositions is to add the appropriate columns
					 to every table that we wish to store the extra information for. For example,
					 consider the following simplified 
					 <phrase role="code">Contact</phrase> table: 
					 <programlisting><emphasis role="bold">create table</emphasis> Contact
{
	ID : ContactID,
	Name : ProperName,
	City : City,
	Since : DateTime,
	<emphasis role="bold">key</emphasis> { ID }
};</programlisting></para> 
				<para>In this design the 
					 <phrase role="code">Since</phrase> column indicates that the
					 proposition recorded by the given row is true and has been
					 <emphasis>since</emphasis> the given time, and we have a semitemporal table
					 definition.</para> 
				<para>To record the information historically, we could use the
					 following definition: 
					 <programlisting><emphasis role="bold">create table</emphasis> Contact
{
	ID : ContactID,
	Name : ProperName,
	City : City,
	From : DateTime,
	To : DateTime,
	<emphasis role="bold">key</emphasis> { ID, From }
};</programlisting></para> 
				<para>In this design the 
					 <phrase role="code">From</phrase> and 
					 <phrase role="code">To</phrase> columns record the interval
					 <emphasis>during</emphasis> which the information was recorded, and we have a
					 fully temporal table definition. However, there are two major problems with
					 both of these approaches.</para> 
				<para>First, neither design fully captures the idea of time-varying
					 information. The semitemporal design is incapable of representing information
					 historically. In other words, the information <emphasis>before</emphasis> the 
					 <phrase role="code">Since</phrase> time cannot be represented.
					 However, the fully temporal design is incapable of representing current
					 information, because the 
					 <phrase role="code">To</phrase> column must represent the
					 <emphasis>moving point "now."</emphasis></para> 
				<para>Second, both designs ignore the fact that the various
					 attributes of an entity will, in general, change at different rates. In the
					 semitemporal design, the value of the 
					 <phrase role="code">Since</phrase> column applies to the
					 proposition as a whole, and the since value is only known for the most recent
					 change. Similarly, in the fully temporal design, the timestamp applies to
					 <emphasis>all</emphasis> the columns in the table. In effect, both designs
					 "timestamp too much."</para> 
				<para>The key to resolving the first issue is provided by the
					 insight that the semitemporal and fully temporal designs are
					 <emphasis>different</emphasis> propositions. In other words, we need both
					 semitemporal and fully temporal tables in order to completely model temporal
					 data. Using both tables, we are now capable of storing both current and
					 historical information, while at the same time avoiding the difficulties of
					 storing current information in the fully temporal design.</para> 
				<para>The key to resolving the second issue is provided by
					 recognizing and designing for the fact that the column values will change
					 independently. For the semitemporal design, this is accomplished by introducing
					 multiple <emphasis>since</emphasis> attributes, one for each column: 
					 <programlisting><emphasis role="bold">create table</emphasis> Contact
{
	ID : ContactID,
	Since : DateTime,
	Name : ProperName,
	NameSince : DateTime,
	City : City,
	CitySince : DateTime,
	<emphasis role="bold">key</emphasis> { ID }
};</programlisting></para> 
				<para>For the fully temporal design, this is accomplished by
					 decomposing the table into multiple tables, one for each column: 
					 <programlisting><emphasis role="bold">create table</emphasis> ContactDuring
{
	Contact_ID : ContactID,
	From : DateTime,
	To : DateTime,
	<emphasis role="bold">key</emphasis> { Contact_ID, From }
};

<emphasis role="bold">create table</emphasis> ContactNameDuring
{
	Contact_ID : ContactID,
	From : DateTime,
	To : DateTime,
	Name : ProperName,
	<emphasis role="bold">key</emphasis> { Contact_ID, From }
};

<emphasis role="bold">create table</emphasis> ContactCityDuring
{
	Contact_ID : ContactID,
	From : DateTime,
	To : DateTime,
	City : City,
	<emphasis role="bold">key</emphasis> { Contact_ID, From }
};</programlisting></para> 
				<para>Using both these revised <emphasis>since</emphasis>
					 (semitemporal) and <emphasis>during</emphasis> (fully temporal) designs, the
					 database is now capable of completely representing both the current and
					 historical information for each contact. As discussed in 
					 <citetitle>Enforcing Stimulus-Response Rules</citetitle>, this
					 information can be maintained transparently with the addition of a few simple
					 event handlers.</para> 
				<para>Note that in the 
					 <phrase role="code">ContactAddress</phrase> example discussed
					 in that chapter, the address is considered as a whole, rather than tracking the
					 changes to each column. This illustrates one of the most useful aspects of
					 these proposals, namely that the granularity at which temporal data is to be
					 tracked is a design decision, rather than assumed by the system. Because this
					 design leads to some amount of redundancy in the historical information, we
					 document the reasons for the decision with the application.</para> 
				<para>Obviously, this section excludes a discussion of many of the
					 more in-depth issues surrounding temporal data. The discussion presented is
					 intended to provide practical guidelines for the design of temporal databases.
					 For a complete discussion, we strongly recommend reading reference [19].</para>
				
		  </sect1>

    <!--<sect1>
    <title>Design Guidelines</title>
    <para>This section discusses some general purpose design guidelines</para><para>Principle of Cautious Design</para><para>Principle of Orthogonal Design</para><para>Design as an iterative process</para><para>Transactional Considerations (avoiding deadlocks, concurrency issues)</para>
</sect1>-->
<!--<sect1> 
				<title>Common Design Patterns</title> 
				<para>Although the design of a database depends largely on the
					 application being built, there are many commonly occurring patterns. This
					 section discusses some of these patterns and provides examples of each taken
					 from the Shipping Application.</para> 
				<sect2> 
					 <title>Lookups/Details</title>
    <para><?xm-replace_text {Paragraph}?></para> 
				</sect2> 
				 
				<sect2> 
					 <title>Parents/Extensions</title>
    <para><?xm-replace_text {Paragraph}?></para> 
				</sect2> 
				<sect2> 
					 <title>Specializations</title>
    <para><?xm-replace_text {Paragraph}?></para> 
				</sect2> 
				<sect2> 
					 <title>Associations</title>
    <para><?xm-replace_text {Paragraph}?></para> 
				</sect2> 
				<sect2> 
					 <title>Hierarchies and Networks</title>
    <para><?xm-replace_text {Paragraph}?></para> 
				</sect2> 
				<sect2> 
					 <title>Modeling Temporal Data</title>
    <para><?xm-replace_text {Paragraph}?></para> 
				</sect2> 
		  </sect1>-->
		  <sect1 id="DDGDatabaseDesignTechniques-Conclusions"> 
				<title><indexterm> 
						  <primary>Database Design Techniques</primary> 
						  <secondary>Further Reading</secondary> 
					 </indexterm>Conclusions</title> 
				<para>Database design plays such an important role in developing
					 Dataphor applications that the more time spent producing a good database design
					 for a given application, the more easily the application can be realized within
					 the Dataphor framework. As such, database design as a discipline should be
					 given as much attention as possible. This chapter, and indeed this entire part
					 of the guide, has attempted to provide a good basis for understanding the
					 overriding goals and underlying fundamentals of database design, and the
					 implementation of database designs within the Dataphor product.</para> 
				<para>Perhaps the most important key to good database design is a
					 correct and complete understanding of the relational model. In addition to the
					 references listed in the bibliography section of this guide, the following list
					 gives some excellent references for further study in database design principles
					 and techniques: 
					 <itemizedlist> 
						  <listitem> 
								<para>Principle of Orthogonal Design</para> 
								<para>The Principle of Orthogonal Design basically
									 states that within a given database, no two tables should have overlapping
									 meanings. In other words, it should always be possible to determine in which
									 table a given proposition should be placed, based on the predicate of the
									 tables in the database. This principle is introduced in the paper 
									 <citetitle>A New Database Design
										  Principle</citetitle> published in 
									 <citetitle>Relational Database Writings
										  1991-1994</citetitle> [9].</para> 
						  </listitem> 
						  <listitem> 
								<para>Principle of Cautious Design</para> 
								<para>The Principle of Cautious Design is a general
									 guideline, not just for database design, but for software development in
									 general. Basically, the principle states that whenever we are faced with a
									 choice between two designs, and the first design is upward compatible with the
									 second (i.e. the first design is more restrictive, and implementing design two
									 would not affect functionality provided by design one), and the full
									 implications of the second design are not yet known, the first design choice is
									 recommended. This principle is discussed fully in the paper 
									 <citetitle>The Principle of Cautious
										  Design</citetitle> published in 
									 <citetitle>Relational Database Writings
										  1989-1991</citetitle> [8].</para> 
						  </listitem> 
						  <listitem> 
								<para>Database Design</para> 
								<para>Obviously, this topic is extremely broad, but a
									 particularly concise and insightful treatise on the subject can found in the
									 paper titled 
									 <citetitle>A Practical Approach to Database
										  Design</citetitle> by C. J. Date, published in 
									 <citetitle>Relational Database Selected
										  Writings</citetitle> [6].</para> 
						  </listitem> 
						  <listitem> 
								<para>Normalization Theory</para> 
								<para>Perhaps the best introduction to normalization
									 theory can be found in 
									 <citetitle>An Introduction to Database
										  Systems</citetitle> [1]. In addition, several papers available from
									 <emphasis>www.dbdebunk.com</emphasis> discuss the various costs associated with
									 denormalization. In particular 
									 <citetitle>The Costly Illusion: Normalization,
										  Integrity, and Performance</citetitle> [22] provides an in-depth discussion of
									 these issues.</para> 
						  </listitem> 
						  <listitem> 
								<para>Temporal Data</para> 
								<para>As mentioned in the section on temporal data, the
									 book 
									 <citetitle>Temporal Data and the Relational
										  Model</citetitle> [19] provides an excellent treatment of this complex
									 problem.</para> 
						  </listitem> 
					 </itemizedlist></para> 
		  </sect1> 
	 </chapter>
</part>
