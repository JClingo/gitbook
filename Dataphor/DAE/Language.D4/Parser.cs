/*
	Dataphor
	Â© Copyright 2000-2008 Alphora
	This file is licensed under a modified BSD-license which can be found here: http://dataphor.org/dataphor_license.txt
*/

#define ALTERNATIVEOPERATORPRECEDENCE
#define ALLOWARBITRARYAGGREGATEEXPRESSIONS

using System;
using System.Text;
using System.Collections.Generic;

namespace Alphora.Dataphor.DAE.Language.D4
{
	/*
		HEADER:
		The following non terminals in the Lexer BNF are referenced by the D4 BNF with equivalent meaning:
			<identifier>
			<literal>
			<string>

		The same conventions found in the The Third Manifesto are used here, namely:
			<XYZ list> ::= {<XYZ>}
			<XYZ commalist> ::= [<XYZ>{,<XYZ>}]
			<XYZ semicolonlist> ::= [<XYZ>{;<XYZ>}]
			<ne XYZ list> ::= <XYZ>{<XYZ>}
			<ne XYZ commalist> ::= <XYZ>{,<XYZ>}
			<ne XYZ semicolonlist> ::= <XYZ>{;<XYZ>}
	*/

	/// <remarks> Given a Dataphor expression in string form, return a parsed statement.</remarks>
	public class Parser : Object
	{
		public Parser() : base() {}

		// IsInternal indicates that the expression being compiled is a known good expression generated by the compiler, so
		// reserved word references may be safely ignored.
		public Parser(bool isInternal) : base()
		{
			_isInternal = isInternal;
		}
		
		protected Lexer _lexer;
		protected ParserMessages _messages;
		protected bool _isInternal;
		
		/*
			BNF:
			<script> ::=
				<statement semicolonlist>
		*/
		/// <summary>Parses the given Dataphor script.</summary>
		/// <returns>Returns the script in terms of <see cref="Statement"/> descendents</returns>
		public Statement ParseScript(string input, ParserMessages messages)
		{
			_lexer = new Lexer(input);
			try
			{
				_messages = messages;
				try
				{
					Block block = new Block();
					while (true)
					{
						if (_lexer[1].Type == TokenType.EOF)
							break;

						try
						{
							block.Statements.Add(Statement());
							
							if (_lexer.PeekTokenSymbol(1) == Keywords.StatementTerminator)
								_lexer.NextToken();
							else if (!(_lexer[1].Type == TokenType.EOF))
								throw new ParserException(ParserException.Codes.StatementTerminatorExpected);
						}
						catch (Exception exception)
						{
							if (_messages != null)
							{
								_messages.Add(new SyntaxException(_lexer, exception));
								break;
							}
							else
								throw exception;
						}
					}

					block.SetEndPosition(_lexer);
					return block;
				}
				finally
				{
					_messages = null;
				}
			}        
			finally
			{
				_lexer = null;
			}
		}
		
		public Statement ParseStatement(string input, ParserMessages messages)
		{
			_lexer = new Lexer(input);
			try
			{
				_messages = messages;
				try
				{
					try
					{
						return Statement();
					}
					catch (Exception E)
					{
						if (_messages != null)
						{
							_messages.Add(new SyntaxException(_lexer, E));
							return new EmptyStatement();
						}
						else
							throw new SyntaxException(_lexer, E);
					}
				}
				finally
				{
					_messages = null;
				}
			}
			finally
			{
				_lexer = null;
			}
		}
		
		public KeyDefinition ParseKeyDefinition(string input)
		{
			_lexer = new Lexer(input);
			try
			{
				try
				{
					return KeyDefinition();
				}
				catch (Exception E)
				{
					throw new SyntaxException(_lexer, E);
				}
				
			}
			finally
			{
				_lexer = null;
			}
		}
		
		public OrderDefinition ParseOrderDefinition(string input)
		{
			_lexer = new Lexer(input);
			try
			{
				try
				{
					return OrderDefinition();
				}
				catch (Exception E)
				{
					throw new SyntaxException(_lexer, E);
				}
			}
			finally
			{
				_lexer = null;
			}
		}

		/// <summary>Parses the given D4 expression.</summary>
		public Expression ParseExpression(string input)
		{
			_lexer = new Lexer(input);
			try
			{
				try
				{
					return Expression();
				}
				catch (Exception E)
				{
					throw new SyntaxException(_lexer, E);
				}
			}
			finally
			{
				_lexer = null;
			}
		}
		
		/// <summary>Parses the given D4 cursor definition.</summary>
		/// <returns>Returns the parse tree corresponding to the given cursor definition in terms of <see cref="Expression"/> descendents.  Ignores a leading select or cursor selector in the input string.</returns>        
		public Expression ParseCursorDefinition(string input)
		{
			_lexer = new Lexer(input);
			try
			{
				try
				{
					if (_lexer.PeekTokenSymbol(1) == Keywords.Select)
						_lexer.NextToken();
					else if (_lexer.PeekTokenSymbol(1) == Keywords.Cursor)
					{
						_lexer.NextToken();
						_lexer.NextToken();
					}
					return CursorDefinition();
				}
				catch (Exception E)
				{
					throw new SyntaxException(_lexer, E);
				}
			}
			finally
			{
				_lexer = null;
			}
		}
		
		public TypeSpecifier ParseTypeSpecifier(string input)
		{
			_lexer = new Lexer(input);
			try
			{
				try
				{
					return TypeSpecifier();
				}
				catch (Exception E)
				{
					throw new SyntaxException(_lexer, E);
				}
			}
			finally
			{
				_lexer = null;
			}
		}
		
		public CatalogObjectSpecifier ParseCatalogObjectSpecifier(string input)
		{
			_lexer = new Lexer(input);
			try
			{
				try
				{
					return CatalogObjectSpecifier();
				}
				catch (Exception E)
				{
					throw new SyntaxException(_lexer, E);
				}
			}
			finally
			{
				_lexer = null;
			}
		}
		
		public CreateOperatorStatement ParseOperatorDeclaration(string input)
		{
			_lexer = new Lexer(input);
			try
			{
				try
				{
					_lexer.NextToken().CheckSymbol(Keywords.Create);
					_lexer.NextToken();
					bool session = (_lexer[0].AsSymbol == Keywords.Session);
					if (session)
						_lexer.NextToken();
					_lexer[0].CheckSymbol(Keywords.Operator);
					return CreateOperatorStatement(1, 1, session, true);
				}
				catch (Exception E)
				{
					throw new SyntaxException(_lexer, E);
				}
			}
			finally
			{
				_lexer = null;
			}
		}
		
		public CreateAggregateOperatorStatement ParseAggregateOperatorDeclaration(string input)
		{
			_lexer = new Lexer(input);
			try
			{
				try
				{
					_lexer.NextToken().CheckSymbol(Keywords.Create);
					_lexer.NextToken();
					bool session = (_lexer[0].AsSymbol == Keywords.Session);
					if (session)
						_lexer.NextToken();
					_lexer[0].CheckSymbol(Keywords.Aggregate);
					return CreateAggregateOperatorStatement(1, 1, session, true);
				}
				catch (Exception E)
				{
					throw new SyntaxException(_lexer, E);
				}
			}
			finally
			{
				_lexer = null;
			}
		}

		/*
			BNF:
			<expression list>
		*/
		public List<Expression> ParseExpressionList(string input)
		{
			_lexer = new Lexer(input);
			try
			{
				try
				{
					var result = new List<Expression>();
					while (_lexer.PeekToken(1).Type != TokenType.EOF)
					{
						result.Add(Expression());
						if (_lexer.PeekToken(1).Type == TokenType.Symbol)
							_lexer.NextToken().CheckSymbol(Keywords.ListSeparator);
					}
					return result;
				}
				catch (Exception E)
				{
					throw new SyntaxException(_lexer, E);
				}
			}
			finally
			{
				_lexer = null;
			}
		}
		
		/*
			BNF:
			<terminated statement> ::=
				[<statement>];
		*/
		protected Statement TerminatedStatement()
		{
			try
			{
				if (_lexer.PeekTokenSymbol(1) == Keywords.StatementTerminator)
				{
					_lexer.NextToken();
					Block block = new Block();
					block.SetPosition(_lexer);
					block.SetEndPosition(_lexer);
					return block;
				}
				else
				{
					Statement statement = Statement();
					_lexer.NextToken().CheckSymbol(Keywords.StatementTerminator);
					return statement;
				}
			}
			catch (Exception exception)
			{
				if (_messages != null)
				{
					_messages.Add(new SyntaxException(_lexer, exception));
					while (true)
					{
						if (_lexer[0].Type == TokenType.EOF)
							break;
						else if (_lexer[0].Type == TokenType.Symbol)
							if (_lexer[0].AsSymbol == Keywords.StatementTerminator)
								break;
							else
								_lexer.NextToken();
						else
							_lexer.NextToken();
					}
					return new EmptyStatement();
				}
				else
					throw exception;
			}
		}
		
		protected bool IsDelimiter(string token, string[] delimiters)
		{
			foreach (string stringValue in delimiters)
				if (token == stringValue)
					return true;
			return false;
		}
		
		protected Statement DelimitedBlock(string[] delimiters)
		{
			Block block = new Block();
			block.SetPosition(_lexer);
			while (_lexer[0].Type != TokenType.EOF)
			{
				if (IsDelimiter(_lexer.PeekTokenSymbol(1), delimiters))
					break;
				else if (_lexer.PeekTokenSymbol(1) == Keywords.StatementTerminator)
				{
					_lexer.NextToken();
					continue;
				}
				else
					block.Statements.Add(TerminatedStatement());
			}
			block.SetEndPosition(_lexer);
			return block.Statements.Count == 1 ? block.Statements[0] : block;			
		}

		/*
			BNF:
			<block> ::=
				begin
					<terminated statement list>
				end
		*/        
		protected Statement Block()
		{
			return DelimitedBlock(new string[]{Keywords.End});
		}
		
		/* 
			BNF:
			<statement> ::=
				<dml statement> |
				<ddl statement> |
				<imperative statement>
				
			<dml statement> ::=
				<select statement> |
				<insert statement> |
				<update statement> |
				<delete statement>

			<ddl statement> ::=
				<create statement> |
				<alter statement> |
				<drop statement> |
				<attach statement> |
				<invoke statement> |
				<detach statement> |
				<grant statement> |
				<revoke statement> |
				<revert statement>

			<imperative statement> ::=
				<block> |
				<expression> |
				<variable declaration statement> |
				<assignment statement> |
				<exit statement> |
				<if statement> |
				<while statement> |
				<do while statement> |
				<for statement> |
				<foreach statement> |
				<repeat statement> |
				<break statement> |
				<continue statement> |
				<case statement> |
				<try finally statement> |
				<try except statement> |
				<try commit statement> |
				<raise statement>
		*/        
		protected Statement Statement()
		{
			Statement statement;
			switch (_lexer.PeekTokenSymbol(1))
			{
				case Keywords.Select: statement = SelectStatement(); break;
				case Keywords.Insert: statement = InsertStatement(); break;
				case Keywords.Update: statement = UpdateStatement(); break;
				case Keywords.Delete: statement = DeleteStatement(); break;
				case Keywords.Create: statement = CreateStatement(); break;
				case Keywords.Alter: statement = AlterStatement(); break;
				case Keywords.Drop: statement = DropStatement(); break;
				case Keywords.Attach: statement = AttachStatement(); break;
				case Keywords.Invoke: statement = InvokeStatement(); break;
				case Keywords.Detach: statement = DetachStatement(); break;
				case Keywords.Grant: statement = GrantStatement(); break;
				case Keywords.Revoke: statement = RevokeStatement(); break;
				case Keywords.Revert: statement = RevertStatement(); break;
				case Keywords.Var: statement = VariableStatement(); break;
				case Keywords.Exit: statement = ExitStatement(); break;
				case Keywords.If: statement = IfStatement(); break;
				case Keywords.While: statement = WhileStatement(); break;
				case Keywords.Do: statement = DoWhileStatement(); break;
				case Keywords.For: statement = ForStatement(); break;
				case Keywords.ForEach: statement = ForEachStatement(); break;
				case Keywords.Repeat: statement = RepeatStatement(); break;
				case Keywords.Break: statement = BreakStatement(); break;
				case Keywords.Continue: statement = ContinueStatement(); break;
				case Keywords.Case: statement = CaseStatement(); break;
				case Keywords.Try: statement = TryStatement(); break;
				case Keywords.Raise: statement = RaiseStatement(); break;
				case Keywords.StatementTerminator: 
					statement = new Block(); 
					statement.SetPosition(_lexer);
					statement.SetEndPosition(_lexer);
					break;
				case Keywords.Begin:
					_lexer.NextToken();
					statement = new DelimitedBlock();
					statement.SetPosition(_lexer);
					((DelimitedBlock)statement).Statements.Add(Block());
					_lexer.NextToken().CheckSymbol(Keywords.End);
					statement.SetEndPosition(_lexer);
					break;
				default: 
					Expression expression = Expression();
					if (_lexer.PeekTokenSymbol(1) == Keywords.Assign)
						statement = AssignmentStatement(expression);
					else
					{
						statement = new ExpressionStatement(expression);
						statement.Line = expression.Line;
						statement.LinePos = expression.LinePos;
						statement.EndLine = expression.EndLine;
						statement.EndLinePos = expression.EndLinePos;
					}
					break;
			}
			return statement;
		}

		/* 
			BNF:
			<select statement> ::=
				select <cursor definition>
		*/        
		protected SelectStatement SelectStatement()
		{
			_lexer.NextToken();
			SelectStatement selectStatement = new SelectStatement();
			selectStatement.SetPosition(_lexer);
			selectStatement.CursorDefinition = CursorDefinition();
			selectStatement.SetEndPosition(_lexer);
			return selectStatement;
		}
		
		protected bool IsTableOperator(string symbol)
		{
			switch (symbol)
			{
				case Keywords.Where:
				case Keywords.Over:
				case Keywords.Add:
				case Keywords.Rename:
				case Keywords.Remove:
				case Keywords.Group:
				case Keywords.Return:
				case Keywords.Explode:
				case Keywords.Adorn:
				case Keywords.Redefine:
				case Keywords.Union:
				case Keywords.Intersect:
				case Keywords.Minus:
				case Keywords.Times:
				case Keywords.Divide:
				case Keywords.Left:
				case Keywords.Right:
				case Keywords.Join: 
				case Keywords.Having:
				case Keywords.Without:
				case Keywords.Lookup: return true;

				case Keywords.On:
					switch (_lexer.PeekTokenSymbol(2))
					{
						case Keywords.Insert:
						case Keywords.Update:
						case Keywords.Delete: return false;
					}
					return true;
					
				case Keywords.BeginList: 
					switch (_lexer.PeekTokenSymbol(2))
					{
						case Keywords.Transition:
						case Keywords.Constraint: 
						case Keywords.Reference: 
						case Keywords.Key: 
						case Keywords.Order: return false;
					}
					return true;
			}
			return false;
		}
		
		protected bool IsUnaryTableOperator(string symbol)
		{
			switch (symbol)
			{
				case Keywords.Where:
				case Keywords.Over:
				case Keywords.Add:
				case Keywords.Rename:
				case Keywords.Remove:
				case Keywords.Group:
				case Keywords.Return:
				case Keywords.Explode:
				case Keywords.On:
				case Keywords.Adorn:
				case Keywords.Redefine: return true;
			}
			return false;
		}
		
		protected bool IsBinaryTableOperator(string symbol)
		{
			switch (symbol)
			{
				case Keywords.Union:
				case Keywords.Intersect:
				case Keywords.Minus:
				case Keywords.Times:
				case Keywords.Divide:
				case Keywords.Left:
				case Keywords.Right:
				case Keywords.Join: 
				case Keywords.Having:
				case Keywords.Without:
				case Keywords.Lookup: return true;
			}
			return false;
		}
		
		/* 
			BNF:
			<expression> ::= 
				<modified expression term> <table operator clause list>
				
			<table operator clause> ::=
				<restrict clause> |
				<project clause> |
				<add clause> |
				<rename clause> |
				<remove clause> |
				<specify clause> |
				<aggregate clause> |
				<quota clause> |
				<explode clause> |
				<adorn clause> |
				<redefine clause> |
				<binary table operator clause> |
				<join clause> |
				<having clause> |
				<without clause> |
				<outer join clause> |
				<on clause>
		*/
		protected Expression Expression()
		{
			Expression expression = ModifiedExpressionTerm();
			while (IsTableOperator(_lexer.PeekTokenSymbol(1)))
			{
				switch (_lexer.PeekTokenSymbol(1))
				{
					case Keywords.Where: expression = RestrictClause(expression); break;
					case Keywords.Over: expression = ProjectClause(expression); break;
					case Keywords.Add: expression = AddClause(expression); break;
					case Keywords.BeginList: expression = SpecifyClause(expression); break;
					case Keywords.Rename: expression = RenameClause(expression); break;
					case Keywords.Remove: expression = RemoveClause(expression); break;
					case Keywords.Group: expression = AggregateClause(expression); break;
					case Keywords.Return: expression = QuotaClause(expression); break;
					case Keywords.Explode: expression = ExplodeClause(expression); break;
					case Keywords.On: 
						if ((_lexer.PeekTokenSymbol(2) != Keywords.Insert) && (_lexer.PeekTokenSymbol(2) != Keywords.Update) && (_lexer.PeekTokenSymbol(2) != Keywords.Delete))
							expression = OnClause(expression); 
					break;
					case Keywords.Adorn: expression = AdornClause(expression); break;
					case Keywords.Redefine: expression = RedefineClause(expression); break;
					case Keywords.Union: expression = UnionClause(expression); break;
					case Keywords.Intersect: expression = IntersectClause(expression); break;
					case Keywords.Minus: expression = DifferenceClause(expression); break;
					case Keywords.Times: expression = ProductClause(expression); break;
					case Keywords.Divide: expression = DivideClause(expression); break;
					case Keywords.Join: 
					case Keywords.Lookup: expression = JoinClause(expression); break;
					case Keywords.Having: expression = HavingClause(expression); break;
					case Keywords.Without: expression = WithoutClause(expression); break;
					case Keywords.Left:
					case Keywords.Right: expression = OuterJoinClause(expression); break;
				}
			}
			#if CALCULESQUE
			if ((FLexer.PeekTokenSymbol(1) != String.Empty) && !IsKeyword(FLexer.PeekTokenSymbol(1)))
			{
				// This is a range variable name for the previous expression
				FLexer.NextToken();
			}
			#endif
			return expression;
		}

		/*
			BNF:
			<modified expression term> ::=
				<expression term> [<language modifiers>]
		*/
		protected Expression ModifiedExpressionTerm()
		{
			Expression expression = ExpressionTerm();
			LanguageModifiers(expression);
			expression.SetEndPosition(_lexer);
			return expression;
		}			

		#if ALTERNATIVEOPERATORPRECEDENCE

		protected bool IsLogicalOrTypeOperator(string operatorValue)
		{
			switch (operatorValue)
			{
				case Keywords.In: 
				case Keywords.Like: 
				case Keywords.Matches:
				case Keywords.Between: 
				case Keywords.Is:
				case Keywords.As: return true;
				default: return false;
			}
		}
		
		protected bool IsLogicalUnaryOperator(string operatorValue)
		{
			switch (operatorValue)
			{
				case Keywords.Not:
				case Keywords.Exists: return true;
				default: return false;
			}
		}

		protected bool IsLogicalDisjunctionOperator(string operatorValue)
		{
			switch (operatorValue)
			{
				case Keywords.Or:
				case Keywords.Xor: return true;
				default: return false;
			}
		}

		/* 
			BNF:
			<expression term> ::= 
				<logical and expression> <logical disjunction clause list>

			<logical disjunction clause> ::=
				<logical disjunction operator> <logical and expression>

			<logical disjunction operator> ::=
				or | xor
		*/
		protected Expression ExpressionTerm()
		{
			Expression expression = LogicalAndExpression();
			while (IsLogicalDisjunctionOperator(_lexer.PeekTokenSymbol(1)))
			{
				BinaryExpression binaryExpression = new BinaryExpression();
				binaryExpression.LeftExpression = expression;
				switch (_lexer.NextToken().AsSymbol)
				{
					case Keywords.Or: binaryExpression.Instruction = Instructions.Or; break;
					case Keywords.Xor: binaryExpression.Instruction = Instructions.Xor; break;
				}
				binaryExpression.SetPosition(_lexer);
				binaryExpression.RightExpression = LogicalAndExpression();
				expression = binaryExpression;
			}
			expression.SetEndPosition(_lexer);
			return expression;
		}

		/*
			BNF:
			<logical and expression> ::= 
				<logical unary expression> {<logical and operator> <logical unary expression>}

			<logical and operator> ::=
				and
		*/
		protected Expression LogicalAndExpression()
		{
			Expression expression = LogicalUnaryExpression();
			while (_lexer.PeekTokenSymbol(1) == Keywords.And)
			{
				_lexer.NextToken();
				BinaryExpression binaryExpression = new BinaryExpression();
				binaryExpression.SetPosition(_lexer);
				binaryExpression.LeftExpression = expression;
				binaryExpression.Instruction = Instructions.And;
				binaryExpression.RightExpression = LogicalUnaryExpression();
				expression = binaryExpression;
			}
			expression.SetEndPosition(_lexer);
			return expression;
		}

		/*
			BNF:
			<logical unary expression> ::=
				{<logical unary operator>} <comparison expression>

			<logical unary operator> ::=
				not | exists
		*/
		protected Expression LogicalUnaryExpression()
		{
			if (IsLogicalUnaryOperator(_lexer.PeekTokenSymbol(1)))
			{
				UnaryExpression expression;
				switch (_lexer.NextToken().AsSymbol)
				{
					case Keywords.Not: 
						expression = new UnaryExpression(Instructions.Not, LogicalUnaryExpression());
						expression.SetPosition(_lexer);
						expression.SetEndPosition(_lexer);
						return expression;
					case Keywords.Exists: 
						expression = new UnaryExpression(Instructions.Exists, LogicalUnaryExpression());
						expression.SetPosition(_lexer);
						expression.SetEndPosition(_lexer);
						return expression;
				}
			}
			return ComparisonExpression();
		}
		
		protected bool IsComparisonOperator(string operatorValue)
		{
			switch (operatorValue)
			{
				case Keywords.Equal:
				case Keywords.NotEqual:
				case Keywords.Less:
				case Keywords.Greater:
				case Keywords.InclusiveLess:
				case Keywords.InclusiveGreater: 
				case Keywords.Compare: return true;
				default: return false;
			}
		}

		/*
			BNF:
			<comparison expression> ::= 
				<logical binary expression> {<comparison operator> <logical binary expression>}

			<comparison operator> ::=
				= | "<>" | "<" | ">" | "<=" | ">=" | ?=
		*/
		protected Expression ComparisonExpression()
		{
			Expression expression = LogicalBinaryExpression();
			while (IsComparisonOperator(_lexer.PeekTokenSymbol(1)))
			{
				BinaryExpression binaryExpression = new BinaryExpression();
				binaryExpression.LeftExpression = expression;
				switch (_lexer.NextToken().AsSymbol)
				{
					case Keywords.Equal: binaryExpression.Instruction = Instructions.Equal; break;
					case Keywords.NotEqual: binaryExpression.Instruction = Instructions.NotEqual; break;
					case Keywords.Less: binaryExpression.Instruction = Instructions.Less; break;
					case Keywords.Greater: binaryExpression.Instruction = Instructions.Greater; break;
					case Keywords.InclusiveLess: binaryExpression.Instruction = Instructions.InclusiveLess; break;
					case Keywords.InclusiveGreater: binaryExpression.Instruction = Instructions.InclusiveGreater; break;
					case Keywords.Compare: binaryExpression.Instruction = Instructions.Compare; break;
				}
				binaryExpression.SetPosition(_lexer);
				binaryExpression.RightExpression = LogicalBinaryExpression();
				expression = binaryExpression;
			}
			expression.SetEndPosition(_lexer);
			return expression;
		}

		/*
			BNF:
			<logical binary expression> ::=
				<bitwise binary expression> <logical or type operator clause list>

			<logical or type operator clause> ::=
				<logical ternary clause> |
				<logical binary clause> |
				<type operator clause>

			<logical ternary clause> ::=
				<logical ternary operator> <additive expression> and <additive expression>

			<logical ternary operator> ::=
				between

			<logical binary clause> ::=
				<logical binary operator> <bitwise binary expression>

			<logical binary operator> ::=
				in | like | matches

			<type operator clause> ::=
				<type operator> <type specifier>

			<type operator> ::=
				is | as
		*/

		protected Expression LogicalBinaryExpression()
		{
			Expression expression = BitwiseBinaryExpression();
			while (IsLogicalOrTypeOperator(_lexer.PeekTokenSymbol(1)))
			{
				if (_lexer.PeekTokenSymbol(1) == Keywords.Between)
				{
					_lexer.NextToken();
					BetweenExpression betweenExpression = new BetweenExpression();
					betweenExpression.SetPosition(_lexer);
					betweenExpression.Expression = expression;
					betweenExpression.LowerExpression = AdditiveExpression();
					_lexer.NextToken().CheckSymbol(Keywords.And);
					betweenExpression.UpperExpression = AdditiveExpression();
					expression = betweenExpression;
				}
				else if (_lexer.PeekTokenSymbol(1) == Keywords.Is)
					expression = IsClause(expression);
				else if (_lexer.PeekTokenSymbol(1) == Keywords.As)
					expression = AsClause(expression);
				else
				{
					BinaryExpression binaryExpression = new BinaryExpression();
					binaryExpression.LeftExpression = expression;
					switch (_lexer.NextToken().AsSymbol)
					{
						case Keywords.In: binaryExpression.Instruction = Instructions.In; break;
						case Keywords.Like: binaryExpression.Instruction = Instructions.Like; break;
						case Keywords.Matches: binaryExpression.Instruction = Instructions.Matches; break;
					}
					binaryExpression.SetPosition(_lexer);
					binaryExpression.RightExpression = BitwiseBinaryExpression();
					expression = binaryExpression;
				}
			}
			expression.SetEndPosition(_lexer);
			return expression;
		}

		protected bool IsBitwiseBinaryOperator(string operatorValue)
		{
			switch (operatorValue)
			{
				case Keywords.BitwiseOr:
				case Keywords.BitwiseAnd:
				case Keywords.BitwiseXor:
				case Keywords.ShiftLeft:
				case Keywords.ShiftRight: return true;
				default: return false;
			}
		}

		/* 
			BNF:
			<bitwise binary expression> ::= 
				<additive expression> {<bitwise binary operator> <additive expression>}

			<bitwise binary operator> ::=
				^ | & | "|" | "<<" | ">>"
		*/
		protected Expression BitwiseBinaryExpression()
		{
			Expression expression = AdditiveExpression();
			while (IsBitwiseBinaryOperator(_lexer.PeekTokenSymbol(1)))
			{
				BinaryExpression binaryExpression = new BinaryExpression();
				binaryExpression.LeftExpression = expression;
				switch (_lexer.NextToken().AsSymbol)
				{
					case Keywords.BitwiseXor: binaryExpression.Instruction = Instructions.BitwiseXor; break;
					case Keywords.BitwiseAnd: binaryExpression.Instruction = Instructions.BitwiseAnd; break;
					case Keywords.BitwiseOr: binaryExpression.Instruction = Instructions.BitwiseOr; break;
					case Keywords.ShiftLeft: binaryExpression.Instruction = Instructions.ShiftLeft; break;
					case Keywords.ShiftRight: binaryExpression.Instruction = Instructions.ShiftRight; break;
				}
				binaryExpression.SetPosition(_lexer);
				binaryExpression.RightExpression = AdditiveExpression();
				expression = binaryExpression;
			}
			expression.SetEndPosition(_lexer);
			return expression;
		}
		
		#else
		
		protected bool IsLogicalOrTypeOperator(string operatorValue)
		{
			switch (operatorValue)
			{
				case Keywords.In: 
				case Keywords.Or:
				case Keywords.Xor:
				case Keywords.Like: 
				case Keywords.Matches:
				case Keywords.Between: 
				case Keywords.Is:
				case Keywords.As: return true;
				default: return false;
			}
		}
		
		/* 
			BNF:
			<expression term> ::= 
				<logical and expression> <logical or type operator clause list>
				
			<logical or type operator clause> ::=
				<logical ternary clause> |
				<logical binary clause> |
				<type operator clause>
				
			<logical ternary clause> ::=
				<logical ternary operator> <additive expression> and <additive expression>
				
			<logical ternary operator> ::=
				between
				
			<logical binary clause> ::=
				<logical binary operator> <logical and expression>
				
			<logical binary operator> ::=
				in | or | xor | like | matches
				
			<type operator clause> ::=
				<type operator> <type specifier>
				
			<type operator> ::=
				is | as
		*/
		protected Expression ExpressionTerm()
		{
			Expression expression = LogicalAndExpression();
			while (IsLogicalOrTypeOperator(_lexer.PeekTokenSymbol(1)))
			{
				if (_lexer.PeekTokenSymbol(1) == Keywords.Between)
				{
					_lexer.NextToken();
					BetweenExpression betweenExpression = new BetweenExpression();
					betweenExpression.SetPosition(_lexer);
					betweenExpression.Expression = expression;
					betweenExpression.LowerExpression = AdditiveExpression();
					_lexer.NextToken().CheckSymbol(Keywords.And);
					betweenExpression.UpperExpression = AdditiveExpression();
					expression = betweenExpression;
				}
				else if (_lexer.PeekTokenSymbol(1) == Keywords.Is)
					expression = IsClause(expression);
				else if (_lexer.PeekTokenSymbol(1) == Keywords.As)
					expression = AsClause(expression);
				else
				{
					BinaryExpression binaryExpression = new BinaryExpression();
					binaryExpression.LeftExpression = expression;
					switch (_lexer.NextToken().AsSymbol)
					{
						case Keywords.In: binaryExpression.Instruction = Instructions.In; break;
						case Keywords.Or: binaryExpression.Instruction = Instructions.Or; break;
						case Keywords.Xor: binaryExpression.Instruction = Instructions.Xor; break;
						case Keywords.Like: binaryExpression.Instruction = Instructions.Like; break;
						case Keywords.Matches: binaryExpression.Instruction = Instructions.Matches; break;
					}
					binaryExpression.SetPosition(_lexer);
					binaryExpression.RightExpression = LogicalAndExpression();
					expression = binaryExpression;
				}
			}
			expression.SetEndPosition(_lexer);
			return expression;
		}
		
		/* 
			BNF:
			<logical and expression> ::= 
				<bitwise binary expression> {<logical and operator> <bitwise binary expression>}
				
			<logical and operator> ::=
				and
		*/
		protected Expression LogicalAndExpression()
		{
			Expression expression = BitwiseBinaryExpression();
			while (_lexer.PeekTokenSymbol(1) == Keywords.And)
			{
				_lexer.NextToken();
				BinaryExpression binaryExpression = new BinaryExpression();
				binaryExpression.SetPosition(_lexer);
				binaryExpression.LeftExpression = expression;
				binaryExpression.Instruction = Instructions.And;
				binaryExpression.RightExpression = BitwiseBinaryExpression();
				expression = binaryExpression;
			}
			expression.SetEndPosition(_lexer);
			return expression;
		}
		
		protected bool IsBitwiseBinaryOperator(string operatorValue)
		{
			switch (operatorValue)
			{
				case Keywords.BitwiseOr:
				case Keywords.BitwiseAnd:
				case Keywords.BitwiseXor:
				case Keywords.ShiftLeft:
				case Keywords.ShiftRight: return true;
				default: return false;
			}
		}
		
		/* 
			BNF:
			<bitwise binary expression> ::= 
				<comparison expression> {<bitwise binary operator> <comparison expression>}
				
			<bitwise binary operator> ::=
				^ | & | "|" | "<<" | ">>"
		*/
		protected Expression BitwiseBinaryExpression()
		{
			Expression expression = ComparisonExpression();
			while (IsBitwiseBinaryOperator(_lexer.PeekTokenSymbol(1)))
			{
				BinaryExpression binaryExpression = new BinaryExpression();
				binaryExpression.LeftExpression = expression;
				switch (_lexer.NextToken().AsSymbol)
				{
					case Keywords.BitwiseXor: binaryExpression.Instruction = Instructions.BitwiseXor; break;
					case Keywords.BitwiseAnd: binaryExpression.Instruction = Instructions.BitwiseAnd; break;
					case Keywords.BitwiseOr: binaryExpression.Instruction = Instructions.BitwiseOr; break;
					case Keywords.ShiftLeft: binaryExpression.Instruction = Instructions.ShiftLeft; break;
					case Keywords.ShiftRight: binaryExpression.Instruction = Instructions.ShiftRight; break;
				}
				binaryExpression.SetPosition(_lexer);
				binaryExpression.RightExpression = ComparisonExpression();
				expression = binaryExpression;
			}
			expression.SetEndPosition(_lexer);
			return expression;
		}
		
		protected bool IsComparisonOperator(string operatorValue)
		{
			switch (operatorValue)
			{
				case Keywords.Equal:
				case Keywords.NotEqual:
				case Keywords.Less:
				case Keywords.Greater:
				case Keywords.InclusiveLess:
				case Keywords.InclusiveGreater: 
				case Keywords.Compare: return true;
				default: return false;
			}
		}
		
		/* 
			BNF:
			<comparison expression> ::= 
				<additive expression> {<comparison operator> <additive expression>}
				
			<comparison operator> ::=
				= | "<>" | "<" | ">" | "<=" | ">=" | ?=
		*/
		protected Expression ComparisonExpression()
		{
			Expression expression = AdditiveExpression();
			while (IsComparisonOperator(_lexer.PeekTokenSymbol(1)))
			{
				BinaryExpression binaryExpression = new BinaryExpression();
				binaryExpression.LeftExpression = expression;
				switch (_lexer.NextToken().AsSymbol)
				{
					case Keywords.Equal: binaryExpression.Instruction = Instructions.Equal; break;
					case Keywords.NotEqual: binaryExpression.Instruction = Instructions.NotEqual; break;
					case Keywords.Less: binaryExpression.Instruction = Instructions.Less; break;
					case Keywords.Greater: binaryExpression.Instruction = Instructions.Greater; break;
					case Keywords.InclusiveLess: binaryExpression.Instruction = Instructions.InclusiveLess; break;
					case Keywords.InclusiveGreater: binaryExpression.Instruction = Instructions.InclusiveGreater; break;
					case Keywords.Compare: binaryExpression.Instruction = Instructions.Compare; break;
				}
				binaryExpression.SetPosition(_lexer);
				binaryExpression.RightExpression = AdditiveExpression();
				expression = binaryExpression;
			}
			expression.SetEndPosition(_lexer);
			return expression;
		}

		#endif
	   
		protected bool IsAdditiveOperator(string operatorValue)
		{
			switch (operatorValue)
			{
				case Keywords.Addition:
				case Keywords.Subtraction: return true;
				default: return false;
			}
		}
		
		/* 
			BNF:
			<additive expression> ::= 
				<multiplicative expression> {<additive operator> <multiplicative expression>}
				
			<additive operator> ::=
				+ | -
		*/
		protected Expression AdditiveExpression()
		{
			Expression expression = MultiplicativeExpression();
			while (IsAdditiveOperator(_lexer.PeekTokenSymbol(1)))
			{
				BinaryExpression binaryExpression = new BinaryExpression();
				binaryExpression.LeftExpression = expression;
				switch (_lexer.NextToken().AsSymbol)
				{
					case Keywords.Addition: binaryExpression.Instruction = Instructions.Addition; break;
					case Keywords.Subtraction: binaryExpression.Instruction = Instructions.Subtraction; break;
				}
				binaryExpression.SetPosition(_lexer);
				binaryExpression.RightExpression = MultiplicativeExpression();
				expression = binaryExpression;
			}
			expression.SetEndPosition(_lexer);
			return expression;
		}
		
		protected bool IsMultiplicativeOperator(string operatorValue)
		{
			switch (operatorValue)
			{
				case Keywords.Multiplication:
				case Keywords.Division:
				case Keywords.Div:
				case Keywords.Mod: return true;
				default: return false;
			}
		}

		/*                 
			BNF:
			<multiplicative expression> ::= 
				<exponent expression> {<multiplicative operator> <exponent expression>}
				
			<multiplicative operator> ::=
				* | / | div | mod
		*/
		protected Expression MultiplicativeExpression()
		{
			Expression expression = ExponentExpression();
			while (IsMultiplicativeOperator(_lexer.PeekTokenSymbol(1)))
			{
				BinaryExpression binaryExpression = new BinaryExpression();
				binaryExpression.LeftExpression = expression;
				switch (_lexer.NextToken().AsSymbol)
				{
					case Keywords.Multiplication: binaryExpression.Instruction = Instructions.Multiplication; break;
					case Keywords.Division: binaryExpression.Instruction = Instructions.Division; break;
					case Keywords.Div: binaryExpression.Instruction = Instructions.Div; break;
					case Keywords.Mod: binaryExpression.Instruction = Instructions.Mod; break;
				}
				binaryExpression.SetPosition(_lexer);
				binaryExpression.RightExpression = ExponentExpression();
				expression = binaryExpression;
			}
			expression.SetEndPosition(_lexer);
			return expression;
		}

		/* 
			BNF:
			<exponent expression> ::= 
				<unary expression> {<exponent operator> <exponent expression>}
				
			<exponent operator> ::=
				**
		*/
		protected Expression ExponentExpression()
		{
			Expression expression = UnaryExpression();
			while (_lexer.PeekTokenSymbol(1) == Keywords.Power)
			{
				_lexer.NextToken();
				BinaryExpression binaryExpression = new BinaryExpression();
				binaryExpression.SetPosition(_lexer);
				binaryExpression.LeftExpression = expression;
				binaryExpression.Instruction = Instructions.Power;
				binaryExpression.RightExpression = ExponentExpression();
				expression = binaryExpression;
			}
			expression.SetEndPosition(_lexer);
			return expression;
		}
		
		protected bool IsUnaryOperator(string operatorValue)
		{
			switch (operatorValue)
			{
				case Keywords.Addition: 
				case Keywords.Subtraction:
				case Keywords.BitwiseNot: 
				case Keywords.Not:
				case Keywords.Exists: return true;
				default: return false;
			}
		}

		/* 
			BNF:
			<unary expression> ::=
				{<unary operator>} <qualified factor>
				
			<unary operator> ::=
				+ | - | ~ | not | exists

		*/
		protected Expression UnaryExpression()
		{
			if (IsUnaryOperator(_lexer.PeekTokenSymbol(1)))
			{
				UnaryExpression expression;
				switch (_lexer.NextToken().AsSymbol)
				{
					case Keywords.Addition: return UnaryExpression();
					case Keywords.Subtraction: 
						var subExpression = UnaryExpression();

						// If negation against a literal number, invert the value rather than add a negate operator
						var valueSubExpression = subExpression as ValueExpression;
						if (valueSubExpression != null)
						{
							switch (valueSubExpression.Token)
							{
								case TokenType.Decimal:
								case TokenType.Float:
								case TokenType.Money:
									valueSubExpression.Value = -(Decimal)valueSubExpression.Value;
									return valueSubExpression;
								case TokenType.Integer:
									valueSubExpression.Value = -(long)valueSubExpression.Value;
									return valueSubExpression;
							}
						}

						expression = new UnaryExpression(Instructions.Negate, subExpression);
						expression.SetPosition(_lexer);
						expression.SetEndPosition(_lexer);
						return expression;
					case Keywords.BitwiseNot: 
						expression = new UnaryExpression(Instructions.BitwiseNot, UnaryExpression());
						expression.SetPosition(_lexer);
						expression.SetEndPosition(_lexer);
						return expression;
					case Keywords.Not: 
						expression = new UnaryExpression(Instructions.Not, UnaryExpression());
						expression.SetPosition(_lexer);
						expression.SetEndPosition(_lexer);
						return expression;
					case Keywords.Exists: 
						expression = new UnaryExpression(Instructions.Exists, UnaryExpression());
						expression.SetPosition(_lexer);
						expression.SetEndPosition(_lexer);
						return expression;
				}
			}
			return QualifiedFactor();
		}
		
		/* 
			BNF:
			<qualified factor> ::=			
				<factor>[.<qualifier expression>]{<indexer expression>[.<qualifier expression>]}
		*/
		protected Expression QualifiedFactor()
		{
			Expression expression = Factor();

			if (_lexer.PeekTokenSymbol(1) == Keywords.Qualifier)
			{
				_lexer.NextToken();
				QualifierExpression qualifierExpression = new QualifierExpression();
				qualifierExpression.SetPosition(_lexer);
				qualifierExpression.LeftExpression = expression;
				qualifierExpression.RightExpression = QualifierExpression();
				expression = qualifierExpression;
			}

			while (_lexer.PeekTokenSymbol(1) == Keywords.BeginIndexer)
			{
				IndexerExpression indexerExpression = IndexerExpression(expression);
				expression = indexerExpression;
				
				if (_lexer.PeekTokenSymbol(1) == Keywords.Qualifier)
				{
					_lexer.NextToken();
					QualifierExpression qualifierExpression = new QualifierExpression();
					qualifierExpression.SetPosition(_lexer);
					qualifierExpression.LeftExpression = expression;
					qualifierExpression.RightExpression = QualifierExpression();
					expression = qualifierExpression;
				}
			}
			
			expression.SetEndPosition(_lexer);
			return expression;
		}
		
		/*
			BNF:
			<qualifier expression> ::=
				<identifier>[("("<actual parameter commalist>")") | (from <expression>)][.<qualifier expression>]
		*/
		protected Expression QualifierExpression()
		{
			Expression expression;			
			int line = _lexer[0, false].Line;
			int linePos = _lexer[0, false].LinePos;
			string identifier = Identifier();
				
			switch (_lexer.PeekTokenSymbol(1))
			{
				case Keywords.BeginGroup: expression = CallExpression(identifier); break;
				case Keywords.From: expression = ColumnExtractor(identifier); break;
				default: expression = new IdentifierExpression(identifier); break;
			}
			expression.Line = line;
			expression.LinePos = linePos;
			
			if (_lexer.PeekTokenSymbol(1) == Keywords.Qualifier)
			{
				_lexer.NextToken();
				QualifierExpression qualifierExpression = new QualifierExpression();
				qualifierExpression.SetPosition(_lexer);
				qualifierExpression.LeftExpression = expression;
				qualifierExpression.RightExpression = QualifierExpression();
				return qualifierExpression;
			}

			expression.SetEndPosition(_lexer);
			return expression;
		}
		
		/*
			BNF:
				
			<indexer expression> ::=
				"["<expression term commalist> [by "{"<column name commalist>"}"]"]"
		*/
		protected IndexerExpression IndexerExpression(Expression expression)
		{
			_lexer.NextToken();
			D4IndexerExpression indexerExpression = new D4IndexerExpression();
			indexerExpression.SetPosition(_lexer);
			indexerExpression.Expression = expression;

			bool hasIndexerExpressions = true;
			if (_lexer[1].Type == TokenType.Symbol)
			{
				switch (_lexer.PeekTokenSymbol(1))
				{
					case Keywords.By :
					case Keywords.EndIndexer :
						hasIndexerExpressions = false;
					break;
				}
			}
			
			if (hasIndexerExpressions)
			{
				bool done = false;
				do
				{
					indexerExpression.Expressions.Add(ExpressionTerm());
					
					switch (_lexer.PeekTokenSymbol(1))
					{
						case Keywords.ListSeparator : _lexer.NextToken(); break;
						default : done = true; break;
					}
				} while (!done);
			}
			
			if (_lexer.PeekTokenSymbol(1) == Keywords.By)
			{
				_lexer.NextToken();
				indexerExpression.HasByClause = true;
				KeyColumnList(indexerExpression.ByClause);
			}

			_lexer.NextToken().CheckSymbol(Keywords.EndIndexer);
			indexerExpression.SetEndPosition(_lexer);
			return indexerExpression;
		}
		
		/* 
			BNF:
			<factor> ::=
				<literal> |
				<selector expression> |
				<extractor expression> |
				([.]<identifier>[("("<actual parameter commalist>")") | (from <expression>)]) |
				("("<expression>")") |
				<if expression> |
				<case expression>
				
			<selector expression> ::=
				<table selector> |
				<row selector> |
				<cursor selector> |
				<list selector>
				
			<extractor expression> ::=
				<row extractor> |
				<column extractor> |
				<multiple column extractor>
		*/
		protected Expression Factor()
		{
			if (_lexer[1].Type != TokenType.Symbol)
			{
				Expression expression;
				switch (_lexer.NextToken().Type)
				{
					case TokenType.Nil:
						expression = new ValueExpression(null, TokenType.Nil);
						expression.SetPosition(_lexer);
						expression.SetEndPosition(_lexer);
						return expression;
					case TokenType.Boolean: 
						expression = new ValueExpression(_lexer[0].AsBoolean, TokenType.Boolean); 
						expression.SetPosition(_lexer);
						expression.SetEndPosition(_lexer);
						return expression;
					case TokenType.Integer: 
						expression = new ValueExpression(_lexer[0].AsInteger, TokenType.Integer); 
						expression.SetPosition(_lexer);
						expression.SetEndPosition(_lexer);
						return expression;
					case TokenType.Hex:
						expression = new ValueExpression(_lexer[0].AsHex, TokenType.Hex);
						expression.SetPosition(_lexer);
						expression.SetEndPosition(_lexer);
						return expression;
					case TokenType.Decimal: 
						expression = new ValueExpression(_lexer[0].AsDecimal, TokenType.Decimal); 
						expression.SetPosition(_lexer);
						expression.SetEndPosition(_lexer);
						return expression;
					case TokenType.Float:
						expression = new ValueExpression(Convert.ToDecimal(_lexer[0].AsFloat), TokenType.Decimal);
						expression.SetPosition(_lexer);
						expression.SetEndPosition(_lexer);
						return expression;
					case TokenType.Money: 
						expression = new ValueExpression(_lexer[0].AsMoney, TokenType.Money);
						expression.SetPosition(_lexer);
						expression.SetEndPosition(_lexer);
						return expression;
					case TokenType.String: 
						expression = new ValueExpression(_lexer[0].AsString, TokenType.String); 
						expression.SetPosition(_lexer);
						expression.SetEndPosition(_lexer);
						return expression;
					#if USEISTRING
					case LexerToken.IString: 
						expression = new ValueExpression(FLexer.TokenIString(), LexerToken.IString);
						expression.SetPosition(FLexer);
						expression.SetEndPosition(FLexer);
						return expression;
					#endif
					default: throw new ParserException(ParserException.Codes.UnknownTokenType, Enum.GetName(typeof(TokenType), _lexer[0].Type));
				}
			}
			else
			{
				Expression expression;
				switch (_lexer.PeekTokenSymbol(1))
				{
					case Keywords.BeginGroup:
						_lexer.NextToken();
						expression = Expression();
						_lexer.NextToken().CheckSymbol(Keywords.EndGroup);
						return expression;
						
					case Keywords.List: 
					case Keywords.BeginList: return ListSelector();
					case Keywords.Table: return TableSelector();
					case Keywords.Row: return RowExpression();
					case Keywords.Cursor: return CursorSelector();
					case Keywords.If: return IfExpression();
					case Keywords.Case: return CaseExpression();
					#if VirtualSupport
					case Keywords.Inherited: return InheritedExpression();
					#endif

					case Keywords.Parent: 
					{
						_lexer.NextToken();
						expression = new ExplodeColumnExpression();
						expression.SetPosition(_lexer);
						if (_lexer.PeekTokenSymbol(1) == Keywords.Qualifier)
							_lexer.NextToken();
						((ExplodeColumnExpression)expression).ColumnName = QualifiedIdentifier();
						expression.SetEndPosition(_lexer);
						return expression;
					}
						
					default:
					{
						bool isQualifier = false;
						if (_lexer.PeekTokenSymbol(1) == Keywords.Qualifier)
						{
							isQualifier = true;
							_lexer.NextToken();
						}

						string identifier = Identifier();
						int line = _lexer[0, false].Line;
						int linePos = _lexer[0, false].LinePos;
						if (isQualifier)
							identifier = String.Format("{0}{1}", Keywords.Qualifier, identifier);
							
						switch (_lexer.PeekTokenSymbol(1))
						{
							case Keywords.BeginGroup: expression = CallExpression(identifier); break;
							case Keywords.From: expression = ColumnExtractor(identifier); break;
							default: expression = new IdentifierExpression(identifier); break;
						}
						expression.Line = line;
						expression.LinePos = linePos;
						expression.SetEndPosition(_lexer);
						
						return expression;
					}
				}
			}
		}

		protected Expression CallExpression(string identifier)
		{
			CallExpression callExpression = new CallExpression();
			callExpression.SetPosition(_lexer);
			callExpression.Identifier = identifier;
			_lexer.NextToken().CheckSymbol(Keywords.BeginGroup);
			if (_lexer.PeekTokenSymbol(1) != Keywords.EndGroup)
			{
				bool done = false;
				do
				{
					callExpression.Expressions.Add(ActualParameter());
					if (_lexer.NextToken().Type == TokenType.Symbol)
					{
						switch (_lexer[0].AsSymbol)
						{
							case Keywords.ListSeparator: break;
							case Keywords.EndGroup: done = true; break;
							default: throw new ParserException(ParserException.Codes.GroupTerminatorExpected);
						}
					}
					else
						throw new ParserException(ParserException.Codes.GroupTerminatorExpected);
				}
				while (!done);
			}
			else
				_lexer.NextToken();
			callExpression.SetEndPosition(_lexer);
			return callExpression;
		}
		
		#if VirtualSupport
		protected Expression InheritedExpression()
		{
			FLexer.NextToken().CheckSymbol(Keywords.Inherited);
			return CallExpression(Keywords.Inherited);
		}
		#endif
		
		/* 
			BNF:
			<metadata> ::=
				[<tags>] [<tags>]
				
			<tags> ::=
				[static] tags "{"<ne tag definition commalist>"}"
				
			<tag definition> ::=
				[static | dynamic] <tag name> = <string>
				
			<tag name> ::=
				<qualified identifier>
		*/
		protected void MetaData(IMetaData metaData)
		{
			metaData.MetaData = new MetaData();
			MetaDataTags(metaData.MetaData);
			MetaDataTags(metaData.MetaData);
		}
		
		public void MetaDataTags(MetaData metaData)
		{
			bool isStatic = false;
			if (_lexer.PeekTokenSymbol(1) == Keywords.Static)
			{
				isStatic = true;
				_lexer.NextToken();
			}
			
			if (isStatic || (_lexer.PeekTokenSymbol(1) == Keywords.Tags))
			{
				_lexer.NextToken().CheckSymbol(Keywords.Tags);
				_lexer.NextToken().CheckSymbol(Keywords.BeginList);
				bool done = false;
				do
				{
					metaData.Tags.Add(MetaDataTag(isStatic));
					if (_lexer.NextToken().Type == TokenType.Symbol)
					{
						switch (_lexer[0].AsSymbol)
						{
							case Keywords.ListSeparator: break;
							case Keywords.EndList: done = true; break;
							default: throw new ParserException(ParserException.Codes.ListTerminatorExpected);
						}
					}
					else
						throw new ParserException(ParserException.Codes.ListTerminatorExpected);
				} while (!done);
			}
		}
		
		protected Tag MetaDataTag(bool isStatic)
		{
			int line = _lexer[0, false].Line;
			int linePos = _lexer[0, false].LinePos;
			switch (_lexer.PeekTokenSymbol(1))
			{
				case Keywords.Static :
					isStatic = true;
					_lexer.NextToken();
					break;
				case Keywords.Dynamic :
					isStatic = false;
					_lexer.NextToken();
					break;
			}
			string name = QualifiedIdentifier(false);
			_lexer.NextToken().CheckSymbol(Keywords.Equal);
			_lexer.NextToken().CheckType(TokenType.String);
			Tag tag = new Tag(name, _lexer[0].AsString, false, isStatic);
			return tag;
		}		

		/* 
			BNF:
			<alter metadata> ::=
				[alter tags "{"<alter tag definition commalist>"}"]
				
			<alter tag definition> ::=
				(create <tag definition>) | 
				(alter <tag definition>) | 
				(drop <tag name>)
		*/        
		protected void AlterMetaData(IAlterMetaData alterMetaData, bool isAlter)
		{
			// This method must be able to parse from the initial alter, or the metadata keywords !!!
			if (alterMetaData.AlterMetaData == null)
				alterMetaData.AlterMetaData = new AlterMetaData();
				
			AlterMetaDataTags(alterMetaData.AlterMetaData, isAlter);
		}
		
		protected void AlterMetaDataTags(AlterMetaData alterMetaData, bool isAlter)
		{
			if (_lexer.PeekTokenSymbol(1) == Keywords.Alter)
			{
				isAlter = true;
				_lexer.NextToken();
			}

			if (!isAlter)
				return;
						
			if (isAlter || _lexer.PeekTokenSymbol(1) == Keywords.Tags)
			{
				_lexer.NextToken().CheckSymbol(Keywords.Tags);
				_lexer.NextToken().CheckSymbol(Keywords.BeginList);
				bool done = false;
				do
				{
					switch (_lexer.NextToken().AsSymbol)
					{
						case Keywords.Create: 
							alterMetaData.CreateTags.Add(MetaDataTag(false));
						break;
						case Keywords.Alter: 
							alterMetaData.AlterTags.Add(MetaDataTag(false)); 
						break;
						case Keywords.Drop: 
							int line = _lexer[0, false].Line;
							int linePos = _lexer[0, false].LinePos;
							Tag tag = new Tag(QualifiedIdentifier(false), String.Empty, false, false);
							alterMetaData.DropTags.Add(tag); 
						break;
						default: throw new ParserException(ParserException.Codes.DDLDirectiveExpected);
					}

					if (_lexer.NextToken().Type == TokenType.Symbol)
					{
						switch (_lexer[0].AsSymbol)
						{
							case Keywords.ListSeparator: break;
							case Keywords.EndList: done = true; break;
							default: throw new ParserException(ParserException.Codes.ListTerminatorExpected);
						}
					}
					else
						throw new ParserException(ParserException.Codes.ListTerminatorExpected);
				} while (!done);
			}
		}
		
		protected string CollapseQualifierExpressionToIdentifier(QualifierExpression expression)
		{
			string ALeftIdentifier = String.Empty;
			string ARightIdentifier = String.Empty;
			if (expression.LeftExpression is IdentifierExpression)
				ALeftIdentifier = ((IdentifierExpression)expression.LeftExpression).Identifier;
			else if (expression.LeftExpression is QualifierExpression)
				ALeftIdentifier = CollapseQualifierExpressionToIdentifier((QualifierExpression)expression.LeftExpression);
			else
				throw new ParserException(ParserException.Codes.InvalidColumnExtractorExpression);
			if (expression.RightExpression is IdentifierExpression)
				ARightIdentifier = ((IdentifierExpression)expression.RightExpression).Identifier;
			else if (expression.RightExpression is QualifierExpression)
				ARightIdentifier = CollapseQualifierExpressionToIdentifier((QualifierExpression)expression.RightExpression);
			else
				throw new ParserException(ParserException.Codes.InvalidColumnExtractorExpression);
			return String.Format("{0}{1}{2}", ALeftIdentifier, Keywords.Qualifier, ARightIdentifier);
		}
		
		protected ColumnExpression ExpressionToColumnExpression(Expression expression)
		{
			ColumnExpression localExpression;
			if (expression is IdentifierExpression)
				localExpression = new ColumnExpression(((IdentifierExpression)expression).Identifier);
			else if (expression is QualifierExpression)
				localExpression = new ColumnExpression(CollapseQualifierExpressionToIdentifier(((QualifierExpression)expression)));
			else
				throw new ParserException(ParserException.Codes.InvalidColumnExtractorExpression);
				
			localExpression.Line = expression.Line;
			localExpression.LinePos = expression.LinePos;
			localExpression.EndLine = expression.EndLine;
			localExpression.EndLinePos = expression.EndLinePos;
			return localExpression;
		}
		
		/* 
			BNF:
			<list selector> ::=
				[<list type specifier>]"{"<expression>"}"

			<multiple column extractor> ::=
				"{"<column name commalist>"}" from <expression> [order by "{"<order column definition commalist>"}"]
		*/
		protected Expression ListSelector()
		{
			ListSelectorExpression expression = new ListSelectorExpression();
			if (_lexer.PeekTokenSymbol(1) == Keywords.List)
				expression.TypeSpecifier = ListTypeSpecifier(false);

			_lexer.NextToken().CheckSymbol(Keywords.BeginList);
			expression.SetPosition(_lexer);
			if (_lexer.PeekTokenSymbol(1) == Keywords.EndList)
				_lexer.NextToken();
			else
			{
				bool done = false;
				do
				{
					expression.Expressions.Add(Expression());
					if (_lexer.NextToken().Type == TokenType.Symbol)
					{
						switch (_lexer[0].AsSymbol)
						{
							case Keywords.ListSeparator: break;
							case Keywords.EndList: done = true; break;
							default: throw new ParserException(ParserException.Codes.ListTerminatorExpected);
						}
					}
					else
						throw new ParserException(ParserException.Codes.ListTerminatorExpected);
				} while (!done);
			}
			
			if (_lexer.PeekTokenSymbol(1) == Keywords.From)
			{
				if (expression.TypeSpecifier != null)
					throw new ParserException(ParserException.Codes.InvalidColumnExtractorExpression);
				_lexer.NextToken();
				ColumnExtractorExpression columnExtractorExpression = new ColumnExtractorExpression();
				columnExtractorExpression.SetPosition(_lexer);
				foreach (Expression columnExpression in expression.Expressions)
					columnExtractorExpression.Columns.Add(ExpressionToColumnExpression(columnExpression));
				columnExtractorExpression.Expression = Expression();

				if (_lexer.PeekTokenSymbol(1) == Keywords.Order)
				{
					columnExtractorExpression.HasByClause = true;
					_lexer.NextToken();
					_lexer.NextToken().CheckSymbol(Keywords.By);
					OrderColumnDefinitionList(columnExtractorExpression.OrderColumns);
				}
				
				return columnExtractorExpression;
			}
			
			expression.SetEndPosition(_lexer);
			return expression;
		}

		/* 
			BNF:
			<if expression> ::=
				if <expression term> then <expression term> else <expression term>
		*/        
		protected IfExpression IfExpression()
		{
			IfExpression expression = new IfExpression();
			_lexer.NextToken().CheckSymbol(Keywords.If);
			expression.SetPosition(_lexer);
			expression.Expression = ExpressionTerm();
			_lexer.NextToken().CheckSymbol(Keywords.Then);
			expression.TrueExpression = ExpressionTerm();
			_lexer.NextToken().CheckSymbol(Keywords.Else);
			expression.FalseExpression = ExpressionTerm();
			expression.SetEndPosition(_lexer);
			return expression;
		}
		
		/* 
			BNF:
			<case expression> ::=
				case [<expression>]
					<ne case expression item list>
					else <expression>
				end
				
			<case expression item> ::=
				when <expression> then <expression>
		*/
		protected CaseExpression CaseExpression()
		{
			CaseExpression caseExpression = new CaseExpression();
			_lexer.NextToken().CheckSymbol(Keywords.Case);
			caseExpression.SetPosition(_lexer);
			if (!(_lexer.PeekTokenSymbol(1) == Keywords.When))
				caseExpression.Expression = Expression();
			bool done = false;
			do
			{
				caseExpression.CaseItems.Add(CaseItemExpression());
				switch (_lexer.PeekTokenSymbol(1))
				{
					case Keywords.When: break;
					case Keywords.Else: 
						caseExpression.ElseExpression = CaseElseExpression();
						done = true;
						break;
					default: throw new ParserException(ParserException.Codes.CaseItemExpressionExpected);
				}
			}
			while (!done);
			_lexer.NextToken().CheckSymbol(Keywords.End);
			caseExpression.SetEndPosition(_lexer);
			return caseExpression;
		}
		
		protected CaseItemExpression CaseItemExpression()
		{
			CaseItemExpression expression = new CaseItemExpression();
			_lexer.NextToken().CheckSymbol(Keywords.When);
			expression.SetPosition(_lexer);
			expression.WhenExpression = Expression();
			_lexer.NextToken().CheckSymbol(Keywords.Then);
			expression.ThenExpression = Expression();
			expression.SetEndPosition(_lexer);
			return expression;
		}
		
		protected CaseElseExpression CaseElseExpression()
		{
			CaseElseExpression expression = new CaseElseExpression();
			_lexer.NextToken().CheckSymbol(Keywords.Else);
			expression.SetPosition(_lexer);
			expression.Expression = Expression();
			expression.SetEndPosition(_lexer);
			return expression;
		}
		
		protected string UnrootedIdentifier()
		{
			return UnrootedIdentifier(true);
		}
		
		protected string UnrootedIdentifier(bool throwIfReserved)
		{
			string stringValue = QualifiedIdentifier(throwIfReserved);
			if (stringValue.IndexOf(Keywords.Qualifier) == 0)	
				return stringValue.Substring(1);
			return stringValue;
		}
		
		/* 
			BNF:
			<qualified identifier> ::=
				[.]{<identifier>.}<identifier>
		*/        
		protected string QualifiedIdentifier(bool throwIfReserved)
		{
			StringBuilder identifier = new StringBuilder();
			if (_lexer.PeekTokenSymbol(1) == Keywords.Qualifier)
				identifier.Append(_lexer.NextToken().AsSymbol);

			identifier.Append(Identifier(throwIfReserved));
			while (_lexer.PeekTokenSymbol(1) == Keywords.Qualifier)
				identifier.AppendFormat("{0}{1}", _lexer.NextToken().AsSymbol, Identifier(throwIfReserved));

			return identifier.ToString();
		}
		
		protected string QualifiedIdentifier() 
		{ 
			return QualifiedIdentifier(true); 
		}

		public static  bool IsKeyword(string identifier)
		{
			return Keywords.Contains(identifier);
		}
		
		public static bool IsReservedWord(string identifier)
		{
			return ReservedWords.Contains(identifier);
		}
		
		public static bool IsValidQualifiedIdentifier(string identifier)
		{
			if (identifier == ".")
				return false;
				
			bool first = true;
			for (int index = 0; index < identifier.Length; index++)
			{
				switch (identifier[index])
				{
					case '.' : 
						first = true;
					break;
						
					case '_' :
						first = false;
					break;
					
					default :
						if ((first && !Char.IsLetter(identifier, index)) || (!first && !Char.IsLetterOrDigit(identifier, index)))
							return false;
						first = false;
					break;
				}
			}
			return true;
		}
		
		public static bool IsValidIdentifier(string identifier)
		{
			for (int index = 0; index < identifier.Length; index++)
			{
				switch (identifier[index])
				{
					case '_' : break;
					
					default :
						if (((index == 0) && !Char.IsLetter(identifier, index)) || ((index != 0) && !Char.IsLetterOrDigit(identifier, index)))
							return false;
					break;
				}
			}
			return true;
		}
		
		protected string ValidIdentifier()
		{
			_lexer.NextToken().CheckType(TokenType.Symbol);
			if (!IsValidIdentifier(_lexer[0].AsSymbol))
				throw new ParserException(ParserException.Codes.InvalidIdentifier, _lexer[0].AsSymbol);

			return _lexer[0].AsSymbol;
		}

		protected string Identifier()
		{
			return Identifier(true);
		}
				
		protected string Identifier(bool throwIfReserved)
		{
			string identifier = ValidIdentifier();
			if (throwIfReserved && IsReservedWord(identifier) && !_isInternal)
				throw new ParserException(ParserException.Codes.ReservedWordIdentifier, identifier);

			return _lexer[0].AsSymbol;
		}
		
		/* 
			BNF:
			<table selector> ::=
				table [of (("{"<named type specifier commalist>"}") | <typeof type specifier>)] "{"<table selector item commalist>"}"
				
			<table selector item> ::=
				<expression> |
				<key definition>
		*/
		protected TableSelectorExpression TableSelector()
		{
			TableSelectorExpression expression = new TableSelectorExpression();
			_lexer.NextToken().CheckSymbol(Keywords.Table);
			expression.SetPosition(_lexer);
			if (_lexer.PeekTokenSymbol(1) == Keywords.Of)
			{
				_lexer.NextToken();
				switch (_lexer.PeekTokenSymbol(1))
				{
					case Keywords.BeginList :
						expression.TypeSpecifier = new TableTypeSpecifier();
						LineInfo lineInfo = NamedTypeSpecifierList(((TableTypeSpecifier)expression.TypeSpecifier).Columns);
						expression.TypeSpecifier.Line = lineInfo.Line;
						expression.TypeSpecifier.LinePos = lineInfo.LinePos;
					break;
					
					default : expression.TypeSpecifier = TypeOfTypeSpecifier(); break;
				}
			}
				
			_lexer.NextToken().CheckSymbol(Keywords.BeginList);
			if (_lexer.PeekTokenSymbol(1) == Keywords.EndList)
				_lexer.NextToken();
			else
			{
				bool done = false;
				do
				{
					switch (_lexer.PeekTokenSymbol(1))
					{
						case Keywords.Key: expression.Keys.Add(KeyDefinition()); break;
						default: expression.Expressions.Add(Expression()); break;
					}
						
					if (_lexer.NextToken().Type == TokenType.Symbol)
					{
						switch (_lexer[0].AsSymbol)
						{
							case Keywords.ListSeparator: break;
							case Keywords.EndList: done = true; break;
							default: throw new ParserException(ParserException.Codes.ListTerminatorExpected);
						}
					}
					else 
						throw new ParserException(ParserException.Codes.ListTerminatorExpected);
				} while (!done);
			}

			expression.SetEndPosition(_lexer);
			return expression;
		}
		
		protected Expression RowExpression()
		{
			_lexer.NextToken().CheckSymbol(Keywords.Row);
			if (_lexer.PeekTokenSymbol(1) == Keywords.From)
				return RowExtractor();
			else
				return RowSelector();
		}
		
		/* 
			BNF:
			<row selector> ::=
				row [of (("{"<named type specifier commalist>"}") | <typeof type specifier>)] "{"<named expression term commalist>"}"
				
			<named expression term> ::=
				<expression term> <column name> <metadata>
		*/
		protected RowSelectorExpression RowSelector()
		{
			RowSelectorExpression expression = new RowSelectorExpression();

			LineInfo lineInfo;
			expression.SetPosition(_lexer);
			if (_lexer.PeekTokenSymbol(1) == Keywords.Of)
			{
				_lexer.NextToken();
				switch (_lexer.PeekTokenSymbol(1))
				{
					case Keywords.BeginList :
						expression.TypeSpecifier = new RowTypeSpecifier();
						lineInfo = NamedTypeSpecifierList(((RowTypeSpecifier)expression.TypeSpecifier).Columns);
						expression.TypeSpecifier.Line = lineInfo.Line;
						expression.TypeSpecifier.LinePos = lineInfo.LinePos;
					break;
					
					default : expression.TypeSpecifier = TypeOfTypeSpecifier(); break;
				}
			}
				
			lineInfo = OptionallyNamedColumnList(expression.Expressions);
			expression.Line = lineInfo.Line;
			expression.LinePos = lineInfo.LinePos;
			expression.SetEndPosition(_lexer);
			return expression;
		}
		
		/* 
			BNF:
			<cursor selector> ::=
				cursor"("<cursor definition>")"
		*/		
		protected CursorSelectorExpression CursorSelector()
		{
			CursorSelectorExpression expression = new CursorSelectorExpression();
			_lexer.NextToken().CheckSymbol(Keywords.Cursor);
			expression.SetPosition(_lexer);
			_lexer.NextToken().CheckSymbol(Keywords.BeginGroup);
			expression.CursorDefinition = CursorDefinition();
			_lexer.NextToken().CheckSymbol(Keywords.EndGroup);
			expression.SetEndPosition(_lexer);
			return expression;
		}
		
		/* 
			BNF:
			<cursor definition> ::=
				<expression> [<order clause> | <browse clause>] [<cursor capabilities>] [<cursor isolation>] [<cursor type>]
		*/
		// TODO: Should the on clause be put in here too?
		//<expression> [<order clause> | <browse clause>] [<on clause>] [<cursor capabilities>] [<cursor isolation>] [<cursor type>]
		protected CursorDefinition CursorDefinition()
		{
			CursorDefinition cursorDefinition = new CursorDefinition();
			Expression expression = Expression();
			cursorDefinition.Line = expression.Line;
			cursorDefinition.LinePos = expression.LinePos;
			switch (_lexer.PeekTokenSymbol(1))
			{
				case Keywords.Order: expression = OrderClause(expression); break;
				case Keywords.Browse: expression = BrowseClause(expression); break;
			}

			/*
			if (FLexer.PeekTokenSymbol(1) == Keywords.On)
				LExpression = OnClause(LExpression);
			*/
				
			cursorDefinition.Expression = expression;

			switch (_lexer.PeekTokenSymbol(1))
			{
				case Keywords.Capabilities:
				case Keywords.Isolation:
				case Keywords.Type:
					CursorCapabilities(cursorDefinition);
					CursorIsolation(cursorDefinition);
					CursorType(cursorDefinition);
				break;
			}

			cursorDefinition.SetEndPosition(_lexer);
			return cursorDefinition;
		}
		
		/* 
			BNF:
			<cursor capabilities> ::=
				capabilities "{"<cursor capability commalist>"}"
				
			<cursor capability> ::=
				navigable | 
				backwardsnavigable | 
				bookmarkable | 
				searchable | 
				updateable | 
				truncateable | 
				countable |
				elaborable
		*/
		protected void CursorCapabilities(CursorDefinition LExpression)
		{
			if (_lexer.PeekTokenSymbol(1) == Keywords.Capabilities)
			{
				_lexer.NextToken();
				_lexer.NextToken().CheckSymbol(Keywords.BeginList);
				do
				{
					LExpression.Capabilities = LExpression.Capabilities | (CursorCapability)Enum.Parse(typeof(CursorCapability), _lexer.NextToken().AsSymbol, true);
					if (_lexer.NextToken().Type == TokenType.Symbol)
					{
						switch (_lexer[0].AsSymbol)
						{
							case Keywords.ListSeparator: break;
							case Keywords.EndList: return;
							default: throw new ParserException(ParserException.Codes.ListTerminatorExpected);
						}
					}
					else
						throw new ParserException(ParserException.Codes.ListTerminatorExpected);
				} while (true);
			}
		}
		
		/* 
			BNF:
			<cursor isolation> ::=
				isolation (none | chaos | browse | stability | isolated)
		*/
		protected void CursorIsolation(CursorDefinition LExpression)
		{
			if (_lexer.PeekTokenSymbol(1) == Keywords.Isolation)
			{
				_lexer.NextToken();
				LExpression.Isolation = (CursorIsolation)Enum.Parse(typeof(CursorIsolation), _lexer.NextToken().AsSymbol, true);
			}
		}
		
		/*
			BNF:
			<cursor type> ::=
				type (static | dynamic)
		*/
		protected void CursorType(CursorDefinition LExpression)
		{
			if (_lexer.PeekTokenSymbol(1) == Keywords.Type)
			{
				_lexer.NextToken();
				LExpression.SpecifiesType = true;
				LExpression.CursorType = (CursorType)Enum.Parse(typeof(CursorType), _lexer.NextToken().AsSymbol, true);
			}
		}
		
		/* 
			BNF:
			<row extractor> ::=
				row from <expression>
		*/
		protected RowExtractorExpression RowExtractor()
		{
			RowExtractorExpression expression = new RowExtractorExpression();
			_lexer.NextToken().CheckSymbol(Keywords.From);
			expression.SetPosition(_lexer);
			expression.Expression = Expression();
			expression.SetEndPosition(_lexer);
			return expression;
		}
		
		/* 
			BNF:
			<column extractor> ::=
				<column name> from <expression> [order by "{"<order column definition commalist>"}"]
		*/
		protected Expression ColumnExtractor(string columnName)
		{
			ColumnExtractorExpression expression = new ColumnExtractorExpression();
			_lexer.NextToken().CheckSymbol(Keywords.From);
			expression.SetPosition(_lexer);
			expression.Expression = Expression();
			
			if (_lexer.PeekTokenSymbol(1) == Keywords.Order)
			{
				_lexer.NextToken();
				_lexer.NextToken().CheckSymbol(Keywords.By);
				expression.HasByClause = true;
				OrderColumnDefinitionList(expression.OrderColumns);
			}
			
			expression.Columns.Add(new ColumnExpression(columnName));
			expression.SetEndPosition(_lexer);
			return expression;
		}

		/* 
			BNF:
			<restrict clause> ::=
				where <expression term> [by <expression term>] [<language modifiers>]
		*/        
		protected Expression RestrictClause(Expression expression)
		{
			RestrictExpression localExpression = new RestrictExpression();
			_lexer.NextToken().CheckSymbol(Keywords.Where);
			localExpression.SetPosition(_lexer);
			localExpression.Expression = expression;
			localExpression.Condition = ExpressionTerm();
			LanguageModifiers(localExpression);
			localExpression.SetEndPosition(_lexer);
			return localExpression;
		}

		/* 
			BNF:
			<project clause> ::=
				over "{"<column name commalist>"}" [<language modifiers>]
		*/        
		protected ProjectExpression ProjectClause(Expression expression)
		{
			ProjectExpression projectExpression = new ProjectExpression();
			_lexer.NextToken().CheckSymbol(Keywords.Over);
			projectExpression.SetPosition(_lexer);
			projectExpression.Expression = expression;
			ColumnList(projectExpression.Columns);
			LanguageModifiers(projectExpression);
			projectExpression.SetEndPosition(_lexer);
			return projectExpression;
		}
		
		protected ColumnExpression Column()
		{
			ColumnExpression expression = new ColumnExpression();
			expression.ColumnName = QualifiedIdentifier();
			expression.SetPosition(_lexer);
			expression.SetEndPosition(_lexer);
			return expression;
		}

		protected void ColumnList(ColumnExpressions columns)
		{
			_lexer.NextToken().CheckSymbol(Keywords.BeginList);
			if (_lexer.PeekTokenSymbol(1) == Keywords.EndList)
			{
				_lexer.NextToken();
				return;
			}
			else
			{
				bool done = false;
				do
				{
					columns.Add(Column());
					if (_lexer.NextToken().Type == TokenType.Symbol)
					{
						switch (_lexer[0].AsSymbol)
						{
							case Keywords.ListSeparator: break;
							case Keywords.EndList: done = true; break;
							default: throw new ParserException(ParserException.Codes.ListTerminatorExpected);
						}
					}
					else
						throw new ParserException(ParserException.Codes.ListTerminatorExpected);
				} while (!done); 
			}
		}
		
		protected NamedColumnExpression NamedColumn()
		{
			NamedColumnExpression expression = new NamedColumnExpression();
			expression.Expression = ExpressionTerm();
			expression.Line = expression.Expression.Line;
			expression.LinePos = expression.Expression.LinePos;
			expression.ColumnAlias = UnrootedIdentifier();
			MetaData(expression);
			expression.SetEndPosition(_lexer);
			return expression;
		}
		
		protected NamedColumnExpression OptionallyNamedColumn()
		{
			NamedColumnExpression expression = new NamedColumnExpression();
			expression.Expression = ExpressionTerm();
			expression.Line = expression.Expression.Line;
			expression.LinePos = expression.Expression.LinePos;
			switch (_lexer.PeekTokenSymbol(1))
			{
				case Keywords.ListSeparator:
				case Keywords.EndList: break;
				case Keywords.Static:
				case Keywords.Dynamic:
				case Keywords.Tags: MetaData(expression); break;
				default: expression.ColumnAlias = UnrootedIdentifier(); break;
			}
			MetaData(expression);
			expression.SetEndPosition(_lexer);
			return expression;
		}
		
		protected void NonEmptyNamedColumnList(NamedColumnExpressions columns)
		{
			_lexer.NextToken().CheckSymbol(Keywords.BeginList);
			bool done = false;
			do
			{
				columns.Add(NamedColumn());
				if (_lexer.NextToken().Type == TokenType.Symbol)
				{		
					switch (_lexer[0].AsSymbol)
					{
						case Keywords.ListSeparator: break;
						case Keywords.EndList: done = true; break;
						default: throw new ParserException(ParserException.Codes.ListTerminatorExpected);
					}
				}
				else
					throw new ParserException(ParserException.Codes.ListTerminatorExpected);
			} while (!done);
		}
		
		protected LineInfo OptionallyNamedColumnList(NamedColumnExpressions columns)
		{
			_lexer.NextToken().CheckSymbol(Keywords.BeginList);
			LineInfo result = new LineInfo(_lexer[0, false].LinePos, _lexer[0, false].Line, -1, -1);
			if (_lexer.PeekTokenSymbol(1) == Keywords.EndList)
				_lexer.NextToken();
			else
			{
				bool done = false;
				do
				{
					columns.Add(OptionallyNamedColumn());
					if (_lexer.NextToken().Type == TokenType.Symbol)
					{		
						switch (_lexer[0].AsSymbol)
						{
							case Keywords.ListSeparator: break;
							case Keywords.EndList: done = true; break;
							default: throw new ParserException(ParserException.Codes.ListTerminatorExpected);
						}
					}
					else
						throw new ParserException(ParserException.Codes.ListTerminatorExpected);
				} while (!done);
			}
			return result;
		}
		
		protected RenameColumnExpression RenameColumn()
		{
			RenameColumnExpression expression = new RenameColumnExpression();
			expression.ColumnName = QualifiedIdentifier();
			expression.SetPosition(_lexer);
			expression.ColumnAlias = UnrootedIdentifier();
			MetaData(expression);
			expression.SetEndPosition(_lexer);
			return expression;
		}

		protected void RenameColumnList(RenameColumnExpressions columns)
		{
			_lexer.NextToken().CheckSymbol(Keywords.BeginList);
			bool done = false;
			do
			{
				columns.Add(RenameColumn());
				if (_lexer.NextToken().Type == TokenType.Symbol)
				{
					switch (_lexer[0].AsSymbol)
					{
						case Keywords.ListSeparator: break;
						case Keywords.EndList: done = true; break;
						default: throw new ParserException(ParserException.Codes.ListTerminatorExpected);
					}
				}
				else
					throw new ParserException(ParserException.Codes.ListTerminatorExpected);
			} while (!done); 
		}

		/* 
			BNF:
			<remove clause> ::=
				remove "{"<column name commalist>"}" [<language modifiers>]
		*/
		protected RemoveExpression RemoveClause(Expression expression)
		{
			RemoveExpression removeExpression = new RemoveExpression();
			_lexer.NextToken().CheckSymbol(Keywords.Remove);
			removeExpression.SetPosition(_lexer);
			removeExpression.Expression = expression;
			ColumnList(removeExpression.Columns);
			LanguageModifiers(removeExpression);
			removeExpression.SetEndPosition(_lexer);
			return removeExpression;
		}

		/* 
			BNF:
			<add clause> ::=
				add "{"<ne named expression term commalist>"}" [<language modifiers>]
		*/
		protected ExtendExpression AddClause(Expression expression)
		{
			ExtendExpression localExpression = new ExtendExpression();
			_lexer.NextToken().CheckSymbol(Keywords.Add);
			localExpression.SetPosition(_lexer);
			localExpression.Expression = expression;
			NonEmptyNamedColumnList(localExpression.Expressions);
			LanguageModifiers(localExpression);
			localExpression.SetEndPosition(_lexer);
			return localExpression;
		}
		
		/*
			BNF:
			<specify clause> ::=
				"{"<optionally named expression term commalist>"}" [<language modifiers>]
				
			<optionally named expression term> ::=
				<expression term> [<column name>] <metadata>
		*/
		protected SpecifyExpression SpecifyClause(Expression expression)
		{
			SpecifyExpression localExpression = new SpecifyExpression();
			localExpression.Line = expression.Line;
			localExpression.LinePos = expression.LinePos;
			localExpression.Expression = expression;
			OptionallyNamedColumnList(localExpression.Expressions);
			LanguageModifiers(localExpression);
			localExpression.SetEndPosition(_lexer);
			return localExpression;
		}

		/* 
			BNF:
			<rename clause> ::=
				rename (("{"<ne named column name commalist>"}") | (<qualified identifier> <metadata>)) [<language modifiers>]

			<named column name> ::=
				<column name> <column name>
		*/
		protected Expression RenameClause(Expression expression)
		{
			int line = _lexer[0, false].Line;
			int linePos = _lexer[0, false].LinePos;
			Expression localExpression;
			_lexer.NextToken().CheckSymbol(Keywords.Rename);
			if (_lexer.PeekTokenSymbol(1) == Keywords.BeginList)
			{
				RenameExpression renameExpression = new RenameExpression();
				renameExpression.Expression = expression;
				RenameColumnList(renameExpression.Expressions);
				localExpression = renameExpression;
			}
			else
			{
				RenameAllExpression renameExpression = new RenameAllExpression();
				renameExpression.Expression = expression;
				renameExpression.Identifier = UnrootedIdentifier();
				MetaData(renameExpression);
				localExpression = renameExpression;
			}
			localExpression.Line = line;
			localExpression.LinePos = linePos;
			LanguageModifiers(localExpression);
			localExpression.SetEndPosition(_lexer);
			return localExpression;
		}

		public static IdentifierExpression CollapseQualifiedIdentifierExpression(Expression expression)
		{
			if (expression is IdentifierExpression)
				return (IdentifierExpression)expression;
			
			if (expression is QualifierExpression)
			{
				IdentifierExpression leftExpression = CollapseQualifiedIdentifierExpression(((QualifierExpression)expression).LeftExpression);
				IdentifierExpression rightExpression = CollapseQualifiedIdentifierExpression(((QualifierExpression)expression).RightExpression);
				if ((leftExpression != null) && (rightExpression != null))
				{
					IdentifierExpression result = new IdentifierExpression(Schema.Object.Qualify(rightExpression.Identifier, leftExpression.Identifier));
					result.Line = leftExpression.Line;
					result.LinePos = rightExpression.LinePos;
					return result;
				}
			}
			
			return null;
		}

		/* 
			BNF:
			<aggregate clause> ::=
				group [by "{"<ne column name commalist>"}"] add "{"<ne named aggregate expression commalist>"}" [<language modifiers>]

				group [by "{"<ne optionally named expression term commalist>"}"] add "{"<ne named aggregate expression commalist>"}" [<language modifiers>]
		*/
		protected AggregateExpression AggregateClause(Expression expression)
		{
			AggregateExpression aggregateExpression = new AggregateExpression();
			_lexer.NextToken().CheckSymbol(Keywords.Group);
			aggregateExpression.SetPosition(_lexer);
			aggregateExpression.Expression = expression;

			#if ALLOWARBITRARYAGGREGATEEXPRESSIONS
			ExtendExpression extendExpression = null;
			NamedColumnExpressions expressionColumns = new NamedColumnExpressions();
			#endif

			if (_lexer.PeekTokenSymbol(1) == Keywords.By)
			{
				_lexer.NextToken();

				#if ALLOWARBITRARYAGGREGATEEXPRESSIONS
				NamedColumnExpressions byColumns = new NamedColumnExpressions();
				OptionallyNamedColumnList(byColumns);
				foreach (NamedColumnExpression column in byColumns)
				{
					if (!String.IsNullOrEmpty(column.ColumnAlias))
					{
						expressionColumns.Add(column);
						ColumnExpression byColumn = new ColumnExpression(column.ColumnAlias);
						byColumn.SetLineInfo(column.LineInfo);
						aggregateExpression.ByColumns.Add(byColumn);
					}
					else
					{
						IdentifierExpression identifier = CollapseQualifiedIdentifierExpression(column.Expression);
						if (identifier != null)
						{
							ColumnExpression byColumn = new ColumnExpression(identifier.Identifier);
							byColumn.SetLineInfo(column.LineInfo);
							aggregateExpression.ByColumns.Add(byColumn);
						}
						else
						{
							// This will error when it gets to the compiler, as it should, the column must be named if an expression is provided
							expressionColumns.Add(column);
						}
					}
				}

				#else
				ColumnList(aggregateExpression.ByColumns);
				#endif
			}
		
			_lexer.NextToken().CheckSymbol(Keywords.Add);
			AggregateColumnList(aggregateExpression.ComputeColumns);

			#if ALLOWARBITRARYAGGREGATEEXPRESSIONS
			foreach (AggregateColumnExpression computeColumn in aggregateExpression.ComputeColumns)
			{
				foreach (Expression argument in computeColumn.Arguments)
				{
					IdentifierExpression identifier = CollapseQualifiedIdentifierExpression(argument);
					if (identifier != null)
					{
						ColumnExpression columnArgument = new ColumnExpression();
						columnArgument.ColumnName = identifier.Identifier;
						columnArgument.SetLineInfo(identifier.LineInfo);
						computeColumn.Columns.Add(columnArgument);
					}
					else
					{
						string argumentName = Schema.Object.GetUniqueName();
						ColumnExpression columnArgument = new ColumnExpression(argumentName);
						columnArgument.SetLineInfo(argument.LineInfo);
						computeColumn.Columns.Add(columnArgument);

						NamedColumnExpression argumentColumnExpression = new NamedColumnExpression(argument, argumentName);
						argumentColumnExpression.SetLineInfo(argument.LineInfo);
						expressionColumns.Add(argumentColumnExpression);
					}
				}

				computeColumn.Arguments.Clear();
			}

			if (expressionColumns.Count > 0)
			{
				extendExpression = new ExtendExpression(expression);
				extendExpression.Expressions.AddRange(expressionColumns);
				extendExpression.SetLineInfo(expression.LineInfo);
				aggregateExpression.Expression = extendExpression;
			}
			#endif

			LanguageModifiers(aggregateExpression);
			aggregateExpression.SetEndPosition(_lexer);
			return aggregateExpression;
		}
		
		protected void AggregateColumnList(AggregateColumnExpressions columns)
		{
			_lexer.NextToken().CheckSymbol(Keywords.BeginList);
			
			do
			{
				columns.Add(AggregateColumn());
				if (_lexer.NextToken().Type == TokenType.Symbol)
				{
					switch (_lexer[0].AsSymbol)
					{
						case Keywords.ListSeparator: break;
						case Keywords.EndList: return;
						default: throw new ParserException(ParserException.Codes.ListTerminatorExpected);
					}
				}
				else
					throw new ParserException(ParserException.Codes.ListTerminatorExpected);
			} while (true);
		}
		
		/* 
			BNF:
			<named aggregate expression> ::=
				<aggregate expression> <column name> <metadata>

			<aggregate expression> ::=
				<operator name>"("[distinct] [<column name commalist>] [order by "{"<order column definition commalist>"}"]")" [<language modifiers>]

				<operator name>"("[distinct] [<expression term commalist>] [order by "{"<order column definition commalist>"}"]")" [<language modifiers>]
		*/
		protected AggregateColumnExpression AggregateColumn()
		{
			AggregateColumnExpression aggregateColumnExpression = new AggregateColumnExpression();
			aggregateColumnExpression.AggregateOperator = QualifiedIdentifier();
			aggregateColumnExpression.SetPosition(_lexer);
			_lexer.NextToken().CheckSymbol(Keywords.BeginGroup);
			if (_lexer.PeekTokenSymbol(1) == Keywords.Distinct)
			{
				_lexer.NextToken();
				aggregateColumnExpression.Distinct = true;
			}

			if (_lexer.PeekTokenSymbol(1) != Keywords.EndGroup)
			{            
				bool done = false;
				while (!done)
				{
					#if ALLOWARBITRARYAGGREGATEEXPRESSIONS
					Expression argument = ExpressionTerm();
					aggregateColumnExpression.Arguments.Add(argument);
					#else
					ColumnExpression expression = new ColumnExpression();
					expression.ColumnName = QualifiedIdentifier();
					expression.SetPosition(_lexer);
					aggregateColumnExpression.Columns.Add(expression);
					#endif

					switch (_lexer.NextToken().AsSymbol)
					{
						case Keywords.ListSeparator : break;
						case Keywords.Order : 
							done = true;
							aggregateColumnExpression.HasByClause = true;
							_lexer.NextToken().CheckSymbol(Keywords.By);
							OrderColumnDefinitionList(aggregateColumnExpression.OrderColumns);
							_lexer.NextToken().CheckSymbol(Keywords.EndGroup);
						break;
						case Keywords.EndGroup : done = true; break;
						default : throw new ParserException(ParserException.Codes.GroupTerminatorExpected);
					}
				}
			}
			else
				_lexer.NextToken();
				
			LanguageModifiers(aggregateColumnExpression);
			aggregateColumnExpression.ColumnAlias = UnrootedIdentifier();
			MetaData(aggregateColumnExpression);
			aggregateColumnExpression.SetEndPosition(_lexer);
			return aggregateColumnExpression;
		}

		/* 
			BNF:
			<order clause> ::=
				order by 
					"{"<order column definition commalist>"}" 
					[include sequence [<column name>] <metadata>] 
					[<language modifiers>]
		*/        
		protected OrderExpression OrderClause(Expression expression)
		{
			OrderExpression orderExpression = new OrderExpression();
			_lexer.NextToken().CheckSymbol(Keywords.Order);
			orderExpression.SetPosition(_lexer);
			orderExpression.Expression = expression;
			_lexer.NextToken().CheckSymbol(Keywords.By);
			OrderColumnDefinitionList(orderExpression.Columns);
			if (_lexer.PeekTokenSymbol(1) == Keywords.Include)
			{
				orderExpression.SequenceColumn = new IncludeColumnExpression(String.Empty);
				_lexer.NextToken();
				orderExpression.SequenceColumn.SetPosition(_lexer);
				_lexer.NextToken().CheckSymbol(Keywords.Sequence);
				if ((_lexer[1].Type == TokenType.Symbol) && ((_lexer.PeekTokenSymbol(1) == Keywords.Qualifier) || IsValidIdentifier(_lexer.PeekTokenSymbol(1))) && !ReservedWords.Contains(_lexer.PeekTokenSymbol(1)))
					orderExpression.SequenceColumn.ColumnAlias = UnrootedIdentifier();
				MetaData(orderExpression.SequenceColumn);
			}
			LanguageModifiers(orderExpression);
			orderExpression.SetEndPosition(_lexer);
			return orderExpression;
		}

		/* 
			BNF:
			<browse clause> ::=
				browse by 
					"{"<order column definition commalist>"}"
					[<language modifiers>]
		*/        
		protected BrowseExpression BrowseClause(Expression expression)
		{
			BrowseExpression browseExpression = new BrowseExpression();
			_lexer.NextToken().CheckSymbol(Keywords.Browse);
			browseExpression.SetPosition(_lexer);
			browseExpression.Expression = expression;
			_lexer.NextToken().CheckSymbol(Keywords.By);
			OrderColumnDefinitionList(browseExpression.Columns);
			LanguageModifiers(browseExpression);
			browseExpression.SetEndPosition(_lexer);
			return browseExpression;
		}

		/* 
			BNF:
			<quota clause> ::=
				return <expression term> [by "{"<order column definition commalist>"}"] [<language modifiers>]
		*/        
		protected QuotaExpression QuotaClause(Expression expression)
		{
			QuotaExpression quotaExpression = new QuotaExpression();
			_lexer.NextToken().CheckSymbol(Keywords.Return);
			quotaExpression.SetPosition(_lexer);
			quotaExpression.Expression = expression;
			quotaExpression.Quota = ExpressionTerm();
			if (_lexer.PeekTokenSymbol(1) == Keywords.By)
			{
				_lexer.NextToken();
				quotaExpression.HasByClause = true;
				OrderColumnDefinitionList(quotaExpression.Columns);
			}
			LanguageModifiers(quotaExpression);
			quotaExpression.SetEndPosition(_lexer);
			return quotaExpression;
		}

		/* 
			BNF:
			<explode clause> ::=
				explode by <expression term> where <expression term> 
				[order by "{"<order column definition commalist>"}"]
				[include level [<column name>] <metadata>]
				[include sequence [<column name>] <metadata>]
				[<language modifiers>]
		*/        
		protected ExplodeExpression ExplodeClause(Expression expression)
		{
			ExplodeExpression explodeExpression = new ExplodeExpression();
			_lexer.NextToken().CheckSymbol(Keywords.Explode);
			explodeExpression.SetPosition(_lexer);
			explodeExpression.Expression = expression;
			_lexer.NextToken().CheckSymbol(Keywords.By);
			explodeExpression.ByExpression = ExpressionTerm();
			_lexer.NextToken().CheckSymbol(Keywords.Where);
			explodeExpression.RootExpression = ExpressionTerm();

			if (_lexer.PeekTokenSymbol(1) == Keywords.Order)
			{
				explodeExpression.HasOrderByClause = true;
				_lexer.NextToken();
				_lexer.NextToken().CheckSymbol(Keywords.By);
				OrderColumnDefinitionList(explodeExpression.OrderColumns);
			}

			for (int index = 0; index < 2; index++)
			{
				if (_lexer.PeekTokenSymbol(1) == Keywords.Include)
				{
					_lexer.NextToken();
					switch (_lexer.PeekTokenSymbol(1))
					{
						case Keywords.Level:
							_lexer.NextToken();
							explodeExpression.LevelColumn = new IncludeColumnExpression(String.Empty);
							explodeExpression.LevelColumn.SetPosition(_lexer);
							if ((_lexer[1].Type == TokenType.Symbol) && ((_lexer.PeekTokenSymbol(1) == Keywords.Qualifier) || IsValidIdentifier(_lexer.PeekTokenSymbol(1))) && !ReservedWords.Contains(_lexer.PeekTokenSymbol(1)))
								explodeExpression.LevelColumn.ColumnAlias = UnrootedIdentifier();
							MetaData(explodeExpression.LevelColumn);
						break;
						
						case Keywords.Sequence:
							_lexer.NextToken();
							explodeExpression.SequenceColumn = new IncludeColumnExpression(String.Empty);
							explodeExpression.SequenceColumn.SetPosition(_lexer);
							if ((_lexer[1].Type == TokenType.Symbol) && ((_lexer.PeekTokenSymbol(1) == Keywords.Qualifier) || IsValidIdentifier(_lexer.PeekTokenSymbol(1))) && !ReservedWords.Contains(_lexer.PeekTokenSymbol(1)))
								explodeExpression.SequenceColumn.ColumnAlias = UnrootedIdentifier();
							MetaData(explodeExpression.SequenceColumn);
						break;
					}
				}
			}
			LanguageModifiers(explodeExpression);
			explodeExpression.SetEndPosition(_lexer);
			return explodeExpression;
		}

		/* 
			BNF:
			<on clause> ::=
				on <server link name>
		*/        
		protected OnExpression OnClause(Expression expression)
		{
			OnExpression onExpression = new OnExpression();
			_lexer.NextToken().CheckSymbol(Keywords.On);
			onExpression.SetPosition(_lexer);
			onExpression.Expression = expression;
			onExpression.ServerName = QualifiedIdentifier();
			onExpression.SetEndPosition(_lexer);
			return onExpression;
		}

		protected IsExpression IsClause(Expression expression)
		{
			IsExpression localExpression = new IsExpression();
			_lexer.NextToken().CheckSymbol(Keywords.Is);
			localExpression.SetPosition(_lexer);
			localExpression.Expression = expression;
			localExpression.TypeSpecifier = TypeSpecifier();
			localExpression.SetEndPosition(_lexer);
			return localExpression;
		}
		
		protected AsExpression AsClause(Expression expression)
		{	
			AsExpression localExpression = new AsExpression();
			_lexer.NextToken().CheckSymbol(Keywords.As);
			localExpression.SetPosition(_lexer);
			localExpression.Expression = expression;
			localExpression.TypeSpecifier = TypeSpecifier();
			localExpression.SetEndPosition(_lexer);
			return localExpression;
		}
		
		/* 
			BNF:
			<adorn clause> ::=
				adorn ["{"<ne adorn item definition commalist>"}"] <metadata> <alter metadata> [<language modifiers>]
			
			<adorn item definition> ::=
				<adorn column> |
				<key definition> |
				(alter key "{"<column name commalist>"}" <alter metadata>) |
				(drop key "{"<column name commalist>"}") |
				<order definition> |
				(alter order "{"<order column definition commalist>"}" <alter metadata>) |
				(drop order "{"<order column definition commalist>"}") |
				<row constraint definition> |
				<reference definition> |
				(alter reference <reference name> <alter metadata>) |
				(drop <reference name>)
				
			<adorn column> ::=
				<column name> 
					<nilable definition>
					["{"<ne column definition item commalist>"}"] 
					<metadata> 
					<alter metadata>
		*/
		protected AdornExpression AdornClause(Expression expression)
		{
			AdornExpression adornExpression = new AdornExpression();
			_lexer.NextToken().CheckSymbol(Keywords.Adorn);
			adornExpression.SetPosition(_lexer);
			adornExpression.Expression = expression;
			if (_lexer.PeekTokenSymbol(1) == Keywords.BeginList)
			{
				_lexer.NextToken();
				bool done = false;
				do
				{
					switch (_lexer.PeekTokenSymbol(1))
					{
						case Keywords.Key : adornExpression.Keys.Add(KeyDefinition()); break;
						case Keywords.Order : adornExpression.Orders.Add(OrderDefinition()); break;
						case Keywords.Reference : adornExpression.References.Add(ReferenceDefinition()); break;

						case Keywords.Alter : 
							_lexer.NextToken(); 
							switch (_lexer.NextToken().AsSymbol)
							{
								case Keywords.Reference : adornExpression.AlterReferences.Add(AlterReferenceDefinition()); break;
								case Keywords.Order : adornExpression.AlterOrders.Add(AlterOrderDefinition()); break;
								case Keywords.Key : adornExpression.AlterKeys.Add(AlterKeyDefinition()); break;
								default : throw new ParserException(ParserException.Codes.UnknownAlterDirective, _lexer[0].AsSymbol);
							}
						break;

						case Keywords.Drop :
							_lexer.NextToken();
							switch (_lexer.NextToken().AsSymbol)
							{
								case Keywords.Reference : adornExpression.DropReferences.Add(DropReferenceDefinition()); break;
								case Keywords.Order : adornExpression.DropOrders.Add(DropOrderDefinition()); break;
								case Keywords.Key : adornExpression.DropKeys.Add(DropKeyDefinition()); break;
							}
						break;

						case Keywords.Transition :
						case Keywords.Constraint : adornExpression.Constraints.Add(RowConstraintDefinition()); break;
						default : adornExpression.Expressions.Add(AdornColumn()); break;
					}
					
					switch (_lexer.NextToken().AsSymbol)
					{
						case Keywords.ListSeparator : break;
						case Keywords.EndList : done = true; break;
						default : throw new ParserException(ParserException.Codes.ListTerminatorExpected);
					}
				} while (!done);
			}
			MetaData(adornExpression);
			AlterMetaData(adornExpression, false);
			LanguageModifiers(adornExpression);
			adornExpression.SetEndPosition(_lexer);
			return adornExpression;
		}
		
		protected AdornColumnExpression AdornColumn()
		{
			AdornColumnExpression expression = new AdornColumnExpression();
			expression.ColumnName = QualifiedIdentifier();
			expression.SetPosition(_lexer);

			if (_lexer.PeekTokenSymbol(1) == Keywords.Not)
			{
				_lexer.NextToken();
				_lexer.NextToken().CheckType(TokenType.Nil);
				expression.ChangeNilable = true;
				expression.IsNilable = false;
			}
			else if (_lexer[1].Type == TokenType.Nil)
			{
				_lexer.NextToken();
				expression.ChangeNilable = true;
				expression.IsNilable = true;
			}
			
			if (_lexer.PeekTokenSymbol(1) == Keywords.BeginList)
			{
				_lexer.NextToken();
				bool done = false;
				do
				{
					switch (_lexer.PeekTokenSymbol(1))
					{
						case Keywords.Default: 
							if (expression.Default != null)
								throw new ParserException(ParserException.Codes.DefaultDefinitionExists);
							expression.Default = DefaultDefinition();
						break;
						
						case Keywords.Constraint: expression.Constraints.Add(ConstraintDefinition()); break;
						
						default : throw new ParserException(ParserException.Codes.UnknownCreateDirective, _lexer.PeekTokenSymbol(1));
					}
					
					switch (_lexer.NextToken().AsSymbol)
					{
						case Keywords.ListSeparator : break;
						case Keywords.EndList : done = true; break;
						default : throw new ParserException(ParserException.Codes.ListTerminatorExpected);
					}
				} while (!done);
			}
			MetaData(expression);
			AlterMetaData(expression, false);
			expression.SetEndPosition(_lexer);
			return expression;
		}
		
		/* 
			BNF:
			<redefine clause> ::=
				redefine "{"<redefine column commalist>"}" [<language modifiers>]
				
			<redefine column> ::=
				<column name> := <expression term>
		*/
		protected Expression RedefineClause(Expression expression)
		{
			RedefineExpression localExpression = new RedefineExpression();
			_lexer.NextToken().CheckSymbol(Keywords.Redefine);
			localExpression.SetPosition(_lexer);
			localExpression.Expression = expression;
			_lexer.NextToken().CheckSymbol(Keywords.BeginList);
			bool done = false;
			do
			{
				localExpression.Expressions.Add(RedefineColumn());
				switch (_lexer.NextToken().AsSymbol)
				{
					case Keywords.ListSeparator: break;
					case Keywords.EndList: done = true; break;
					default: throw new ParserException(ParserException.Codes.ListTerminatorExpected);
				}
			} while (!done);

			LanguageModifiers(localExpression);			
			localExpression.SetEndPosition(_lexer);
			return localExpression;
		}
		
		protected NamedColumnExpression RedefineColumn()
		{
			NamedColumnExpression expression = new NamedColumnExpression();
			expression.ColumnAlias = UnrootedIdentifier();
			expression.SetPosition(_lexer);
			_lexer.NextToken().CheckSymbol(Keywords.Assign);
			expression.Expression = ExpressionTerm();
			expression.SetEndPosition(_lexer);
			return expression;
		}

		/*
			BNF:
			<language modifiers> ::=
				with "{"<ne language modifier commalist>"}"
		
			<language modifier> ::=
				<language modifier name> = <language modifier value>
				
			<language modifier name> ::=
				<qualified identifier>
				
			<language modifier value> ::=
				<string>
		*/
		protected void LanguageModifiers(Statement statement)
		{
			if (_lexer.PeekTokenSymbol(1) == Keywords.With)
			{
				_lexer.NextToken();
				_lexer.NextToken().CheckSymbol(Keywords.BeginList);
				statement.Modifiers = new LanguageModifiers();
				bool done = false;
				do
				{
					statement.Modifiers.Add(LanguageModifier());
					
					if (_lexer.NextToken().Type == TokenType.Symbol)
					{
						switch (_lexer[0].AsSymbol)
						{
							case Keywords.ListSeparator: break;
							case Keywords.EndList: done = true; break;
							default: throw new ParserException(ParserException.Codes.ListTerminatorExpected);
						}
					}
					else
						throw new ParserException(ParserException.Codes.ListTerminatorExpected);
				} while (!done);
			}
		}
		
		protected LanguageModifier LanguageModifier()
		{
			string name = QualifiedIdentifier(false);
			_lexer.NextToken().CheckSymbol(Keywords.Equal);
			_lexer.NextToken().CheckType(TokenType.String);
			return new LanguageModifier(name, _lexer[0].AsString);
		}
		
		/* 
			BNF:
			<binary table operator clause> ::=
				<binary table operator> <expression term> [<language modifiers>]
				
			<binary table operator> ::=
				union | intersect | minus | times | divide
		*/
		protected UnionExpression UnionClause(Expression expression)
		{
			UnionExpression unionExpression = new UnionExpression();
			_lexer.NextToken().CheckSymbol(Keywords.Union);
			unionExpression.SetPosition(_lexer);
			unionExpression.LeftExpression = expression;
			unionExpression.RightExpression = ExpressionTerm();
			LanguageModifiers(unionExpression);
			unionExpression.SetEndPosition(_lexer);
			return unionExpression;
		}
		
		protected IntersectExpression IntersectClause(Expression expression)
		{
			IntersectExpression intersectExpression = new IntersectExpression();
			_lexer.NextToken().CheckSymbol(Keywords.Intersect);
			intersectExpression.SetPosition(_lexer);
			intersectExpression.LeftExpression = expression;
			intersectExpression.RightExpression = ExpressionTerm();
			LanguageModifiers(intersectExpression);
			intersectExpression.SetEndPosition(_lexer);
			return intersectExpression;
		}

		protected DifferenceExpression DifferenceClause(Expression expression)
		{
			DifferenceExpression differenceExpression = new DifferenceExpression();
			_lexer.NextToken().CheckSymbol(Keywords.Minus);
			differenceExpression.SetPosition(_lexer);
			differenceExpression.LeftExpression = expression;
			differenceExpression.RightExpression = ExpressionTerm();
			LanguageModifiers(differenceExpression);
			differenceExpression.SetEndPosition(_lexer);
			return differenceExpression;
		}

		protected ProductExpression ProductClause(Expression expression)
		{
			ProductExpression productExpression = new ProductExpression();
			_lexer.NextToken().CheckSymbol(Keywords.Times);
			productExpression.SetPosition(_lexer);
			productExpression.LeftExpression = expression;
			productExpression.RightExpression = ExpressionTerm();
			LanguageModifiers(productExpression);
			productExpression.SetEndPosition(_lexer);
			return productExpression;
		}

		protected DivideExpression DivideClause(Expression expression)
		{
			DivideExpression divideExpression = new DivideExpression();
			_lexer.NextToken().CheckSymbol(Keywords.Divide);
			divideExpression.SetPosition(_lexer);
			divideExpression.LeftExpression = expression;
			divideExpression.RightExpression = ExpressionTerm();
			LanguageModifiers(divideExpression);
			divideExpression.SetEndPosition(_lexer);
			return divideExpression;
		}

		/* 
			BNF:
			<join clause> ::=
				(join | lookup) <conditioned expression term> [<language modifiers>]
		*/
		protected JoinExpression JoinClause(Expression expression)
		{
			JoinExpression joinExpression = new InnerJoinExpression();
			_lexer.NextToken();
			joinExpression.SetPosition(_lexer);
			joinExpression.IsLookup = (_lexer[0].AsSymbol == Keywords.Lookup);
			joinExpression.LeftExpression = expression;
			ConditionedExpressionTerm(joinExpression);
			LanguageModifiers(joinExpression);
			joinExpression.SetEndPosition(_lexer);
			return joinExpression;
		}
		
		/*
			BNF:
			<having clause> ::=
				having <conditioned expression term> [<language modifiers>]
		*/
		protected HavingExpression HavingClause(Expression expression)
		{
			HavingExpression havingExpression = new HavingExpression();
			_lexer.NextToken();
			havingExpression.SetPosition(_lexer);
			havingExpression.LeftExpression = expression;
			ConditionedExpressionTerm(havingExpression);
			LanguageModifiers(havingExpression);
			havingExpression.SetEndPosition(_lexer);
			return havingExpression;
		}
		
		/*
			BNF:
			<without clause> ::=
				without <conditioned expression term> [<language modifiers>]
		*/
		protected WithoutExpression WithoutClause(Expression expression)
		{
			WithoutExpression withoutExpression = new WithoutExpression();
			_lexer.NextToken();
			withoutExpression.SetPosition(_lexer);
			withoutExpression.LeftExpression = expression;
			ConditionedExpressionTerm(withoutExpression);
			LanguageModifiers(withoutExpression);
			withoutExpression.SetEndPosition(_lexer);
			return withoutExpression;
		}

		/*				 
			BNF:
			<outer join clause> ::=
				(left | right) (join | lookup) <conditioned expression term>
					[include rowexists [<column name>] <metadata>]
					[<language modifiers>]
		*/
		protected JoinExpression OuterJoinClause(Expression expression)
		{
			int line = _lexer[0, false].Line;
			int linePos = _lexer[0, false].LinePos;
			_lexer.NextToken();
			OuterJoinExpression outerJoinExpression = null;
			switch (_lexer[0].AsSymbol)
			{
				case Keywords.Left: outerJoinExpression = new LeftOuterJoinExpression(); break;
				case Keywords.Right: outerJoinExpression = new RightOuterJoinExpression(); break;
			}
			outerJoinExpression.Line = line;
			outerJoinExpression.LinePos = linePos;
			_lexer.NextToken();
			switch (_lexer[0].AsSymbol)
			{
				case Keywords.Join: break;
				case Keywords.Lookup: outerJoinExpression.IsLookup = true;	break;
			}
			outerJoinExpression.LeftExpression = expression;
			ConditionedExpressionTerm(outerJoinExpression);
			if (_lexer.PeekTokenSymbol(1) == Keywords.Include)
			{
				_lexer.NextToken();
				outerJoinExpression.RowExistsColumn = new IncludeColumnExpression(String.Empty);
				outerJoinExpression.RowExistsColumn.SetPosition(_lexer);
				_lexer.NextToken().CheckSymbol(Keywords.RowExists);
				if ((_lexer[1].Type == TokenType.Symbol) && ((_lexer.PeekTokenSymbol(1) == Keywords.Qualifier) || IsValidIdentifier(_lexer.PeekTokenSymbol(1))) && !ReservedWords.Contains(_lexer.PeekTokenSymbol(1)))
					outerJoinExpression.RowExistsColumn.ColumnAlias = UnrootedIdentifier();
				MetaData(outerJoinExpression.RowExistsColumn);
			}
			LanguageModifiers(outerJoinExpression);
			outerJoinExpression.SetEndPosition(_lexer);
			return outerJoinExpression;
		}

		/* 
			BNF:
			<conditioned expression term> ::=
				<expression term> [by <expression term>]
		*/        
		protected void ConditionedExpressionTerm(ConditionedBinaryTableExpression conditionedExpression)
		{
			conditionedExpression.RightExpression = ExpressionTerm();
			if (_lexer.PeekTokenSymbol(1) == Keywords.By)
			{
				_lexer.NextToken();
				conditionedExpression.Condition = ExpressionTerm();
			}
		}

		/* 
			BNF:
			<insert statement> ::=
				insert [<language modifiers>] <expression> into <expression>
		*/
		protected InsertStatement InsertStatement()
		{
			InsertStatement statement = new InsertStatement();
			_lexer.NextToken();
			statement.SetPosition(_lexer);
			LanguageModifiers(statement);
			statement.SourceExpression = Expression();
			_lexer.NextToken().CheckSymbol(Keywords.Into);
			statement.Target = Expression();
			statement.SetEndPosition(_lexer);
			return statement;
		}

		/* 
			BNF:
			<update statement> ::=
				update [<language modifiers>] <expression> 
					set "{"<ne update column commalist>"}" 
					[where <expression term>]
		*/        
		protected UpdateStatement UpdateStatement()
		{
			UpdateStatement statement = new UpdateStatement();
			_lexer.NextToken();
			statement.SetPosition(_lexer);
			LanguageModifiers(statement);
			statement.Target = Expression();
			_lexer.NextToken().CheckSymbol(Keywords.Set);
			UpdateColumnList(statement.Columns);
			if (_lexer.PeekTokenSymbol(1) == Keywords.Where)
			{
				_lexer.NextToken();
				statement.Condition = ExpressionTerm();
			}
			statement.SetEndPosition(_lexer);
			return statement;
		}
		
		protected void UpdateColumnList(UpdateColumnExpressions columns)
		{	
			_lexer.NextToken().CheckSymbol(Keywords.BeginList);
			bool done = false;
			do
			{
				columns.Add(UpdateColumn());
				if (_lexer.NextToken().Type == TokenType.Symbol)
				{
					switch (_lexer[0].AsSymbol)
					{
						case Keywords.ListSeparator: break;
						case Keywords.EndList: return;
						default: throw new ParserException(ParserException.Codes.ListTerminatorExpected);
					}
				}
				else
					throw new ParserException(ParserException.Codes.ListTerminatorExpected);
			} while (!done);
		}
		
		/* 
			BNF:
			<update column> ::=
				<target> := <expression term>

			<target> ::=
				<expression>
		*/
		protected UpdateColumnExpression UpdateColumn()
		{
			UpdateColumnExpression expression = new UpdateColumnExpression();
			expression.Target = Expression();
			_lexer.NextToken().CheckSymbol(Keywords.Assign);
			expression.SetPosition(_lexer);
			expression.Expression = ExpressionTerm();
			expression.SetEndPosition(_lexer);
			return expression;
		}
		
		/* 
			BNF:
			<delete statement> ::=
				delete [<language modifiers>] <expression>
		*/        
		protected DeleteStatement DeleteStatement()
		{
			DeleteStatement statement = new DeleteStatement();
			_lexer.NextToken();
			statement.SetPosition(_lexer);
			LanguageModifiers(statement);
			statement.Target = Expression();
			statement.SetEndPosition(_lexer);
			return statement;
		}
 
		/* 
			BNF:
			<variable declaration statement> ::=
				var <ne variable definition commalist>
				
			<variable definition> ::=
				<qualified identifier> [: <type specifier>] [:= <expression>]
		*/
		protected Statement VariableStatement()
		{
			Block block = new Block();
			_lexer.NextToken();
			block.SetPosition(_lexer);
			while (true)
			{
				VariableStatement statement = new VariableStatement();
				statement.VariableName = new IdentifierExpression();
				statement.VariableName.Identifier = UnrootedIdentifier();
				statement.VariableName.SetPosition(_lexer);
				statement.SetPosition(_lexer);
				if (_lexer.PeekTokenSymbol(1) == Keywords.TypeSpecifier)
				{
					_lexer.NextToken();
					statement.TypeSpecifier = TypeSpecifier();
				}
				if (_lexer.PeekTokenSymbol(1) == Keywords.Assign)
				{
					_lexer.NextToken();
					statement.Expression = Expression();
				}
				statement.SetEndPosition(_lexer);
				block.Statements.Add(statement);
				if (_lexer.PeekTokenSymbol(1) == Keywords.ListSeparator)
					_lexer.NextToken();
				else
				  break;
			}
			block.SetEndPosition(_lexer);
			if (block.Statements.Count == 1)
				return block.Statements[0];
			else
				return block;
		}
		
		/* 
			BNF:
			<assignment statement> ::=
				<target> := <expression>
		*/
		protected Statement AssignmentStatement(Expression expression)
		{
			AssignmentStatement statement = new AssignmentStatement();
			statement.Target = expression;
			_lexer.NextToken().CheckSymbol(Keywords.Assign);
			statement.SetPosition(_lexer);
			statement.Expression = Expression();
			statement.SetEndPosition(_lexer);
			return statement;
		}
		
		/* 
			BNF:
			<exit statement> ::=
				exit
		*/
		protected Statement ExitStatement()
		{
			Statement statement = new ExitStatement();
			_lexer.NextToken();
			statement.SetPosition(_lexer);
			statement.SetEndPosition(_lexer);
			return statement;
		}
		
		/* 
			BNF:
			<if statement> ::=
				if <expression> then
					<statement>
				[else <statement>]
		*/
		protected IfStatement IfStatement()
		{
			IfStatement statement = new IfStatement();
			_lexer.NextToken();
			statement.SetPosition(_lexer);
			statement.Expression = Expression();
			_lexer.NextToken().CheckSymbol(Keywords.Then);
			statement.TrueStatement = Statement();
			if (_lexer.PeekTokenSymbol(1) == Keywords.Else)
			{
				_lexer.NextToken();
				statement.FalseStatement = Statement();
			}
			statement.SetEndPosition(_lexer);
			return statement;
		}
		
		/* 
			BNF:
			<while statement> ::=
				while <expression> do <statement>
		*/
		protected WhileStatement WhileStatement()
		{
			WhileStatement statement = new WhileStatement();
			_lexer.NextToken();
			statement.SetPosition(_lexer);
			statement.Condition = Expression();
			_lexer.NextToken().CheckSymbol(Keywords.Do);
			statement.Statement = Statement();
			statement.SetEndPosition(_lexer);
			return statement;
		}
		
		/*
			BNF:
			<do while statement> ::=
				do <terminated statement list> while <expression>
		*/
		protected DoWhileStatement DoWhileStatement()
		{
			DoWhileStatement statement = new DoWhileStatement();
			_lexer.NextToken();
			statement.SetPosition(_lexer);
			statement.Statement = DelimitedBlock(new string[] { Keywords.While });
			_lexer.NextToken();
			statement.Condition = Expression();
			statement.SetEndPosition(_lexer);
			return statement;
		}
		
		/*
			BNF:
			<for statement> ::=
				for 
					[var] <qualified identifier> [: <type specifier>] 
					:= <expression> (to | downto)
					<expression> 
					[step <expression>] 
					do <statement>
		*/
		protected Statement ForStatement()
		{
			Block block = new DelimitedBlock();
			_lexer.NextToken();
			block.SetPosition(_lexer);
			bool isAllocation = false;
			if (_lexer.PeekTokenSymbol(1) == Keywords.Var)
			{
				_lexer.NextToken();
				isAllocation = true;
			}
			string variableName = UnrootedIdentifier();
			Expression variableExpression = new IdentifierExpression(variableName);
			variableExpression.SetPosition(_lexer);
			VariableStatement variableStatement = null;
			if (isAllocation || (_lexer.PeekTokenSymbol(1) == Keywords.TypeSpecifier))
			{
				variableStatement = new VariableStatement();
				variableStatement.SetPosition(_lexer);
				variableStatement.VariableName = new IdentifierExpression(variableName);
				variableStatement.VariableName.SetPosition(_lexer);
				if (_lexer.PeekTokenSymbol(1) == Keywords.TypeSpecifier)
				{
					_lexer.NextToken();
					variableStatement.TypeSpecifier = TypeSpecifier();
				}
				variableStatement.SetEndPosition(_lexer);
				block.Statements.Add(variableStatement);
			}

			_lexer.NextToken().CheckSymbol(Keywords.Assign);
			AssignmentStatement assignmentStatement = new AssignmentStatement();
			assignmentStatement.SetPosition(_lexer);
			assignmentStatement.Target = variableExpression;
			assignmentStatement.Expression = Expression();
			if ((variableStatement != null) && (variableStatement.TypeSpecifier == null))
				variableStatement.TypeSpecifier = new TypeOfTypeSpecifier(assignmentStatement.Expression);
			assignmentStatement.SetEndPosition(_lexer);
			block.Statements.Add(assignmentStatement);
			
			bool isPositive;
			switch (_lexer.NextToken().AsSymbol)
			{
				case Keywords.To: isPositive = true; break;
				case Keywords.Downto: isPositive = false; break;
				default : throw new LexerException(LexerException.Codes.SymbolExpected, String.Format("{0} or {1}", Keywords.To, Keywords.Downto));
			}
			Expression finalExpression = Expression();
			Expression stepExpression = null;
			if (_lexer.PeekTokenSymbol(1) == Keywords.Step)
			{
				_lexer.NextToken();
				stepExpression = Expression();
			}
			else
				stepExpression = new ValueExpression(1, TokenType.Integer);
			_lexer.NextToken().CheckSymbol(Keywords.Do);
			WhileStatement whileStatement = new WhileStatement();
			whileStatement.Condition = new BinaryExpression(new IdentifierExpression(variableName), isPositive ? Instructions.InclusiveLess : Instructions.InclusiveGreater, finalExpression);
			Statement iterationStatement = Statement();
			Statement incrementStatement = new AssignmentStatement(new IdentifierExpression(variableName), new BinaryExpression(new IdentifierExpression(variableName), isPositive ? Instructions.Addition : Instructions.Subtraction, stepExpression));
			TryFinallyStatement iterationBlock = new TryFinallyStatement();
			iterationBlock.TryStatement = iterationStatement;
			iterationBlock.FinallyStatement = incrementStatement;
			iterationStatement = iterationBlock;
			whileStatement.Statement = iterationStatement;
			block.Statements.Add(whileStatement);
			block.SetEndPosition(_lexer);
			return block;
		}
		
		/*
			BNF:
			<foreach statement> ::=
				foreach row | ([var] <qualified identifier>)
					in <cursor definition> 
					do <statement>
		*/
		
		/*
			#if <cursor definition> is cursor valued ::=	
				begin
					var LCursor := <expression>;
					try
						#if var is specified
						var <qualified identifier> : typeof(LCursor.Select());
						#end
						while LCursor.Next() do
						begin
							#if <qualified identifier> is specified
							<qualified identifier> := LCursor.Select();
							#else
							#stackpush LCursor.Select()
							#end
							<statement>;
							#if <qualified identifier> is not specified
							#stackpop
							#end
						end;
					finally
						LCursor.Close();
					end;
				end;
			#else
				begin
					#if var is specified
					var <qualified identifier> : typeof(<expression>[0]);
					#end
					for var LIndex := 1 to <expression>.Count() do
					begin
						<qualified identifier> := <expression>[LIndex];
						<statement>;
					end;
				end;
			#end
		*/
		protected Statement ForEachStatement()
		{
			ForEachStatement statement = new ForEachStatement();
			_lexer.NextToken();
			statement.SetPosition(_lexer);
			switch (_lexer.PeekTokenSymbol(1))
			{
				case Keywords.Row : _lexer.NextToken(); break;
				case Keywords.Var :
					_lexer.NextToken();
					statement.VariableName = UnrootedIdentifier();
					statement.IsAllocation = true;
				break;
				
				default: statement.VariableName = UnrootedIdentifier(); break;
			}
			
			_lexer.NextToken().CheckSymbol(Keywords.In);
			statement.Expression = CursorDefinition();
			_lexer.NextToken().CheckSymbol(Keywords.Do);
			statement.Statement = Statement();
			statement.SetEndPosition(_lexer);
			return statement;
		}
		
		/*
			BNF:
			<repeat statement> ::=
				repeat <terminated statement list> until <condition>
				
			<condition> ::=
				<expression>
		*/
		protected DoWhileStatement RepeatStatement()
		{
			DoWhileStatement doWhileStatement = new DoWhileStatement();
			_lexer.NextToken();
			doWhileStatement.SetPosition(_lexer);
			doWhileStatement.Statement = DelimitedBlock(new string[] { Keywords.Until });
			_lexer.NextToken();
			doWhileStatement.Condition = new UnaryExpression(Instructions.Not, Expression());
			doWhileStatement.SetEndPosition(_lexer);
			return doWhileStatement;
		}
		
		/* 
			BNF:
			<break statement> ::=
				break
		*/
		protected BreakStatement BreakStatement()
		{
			BreakStatement statement = new BreakStatement();
			_lexer.NextToken();
			statement.SetPosition(_lexer);
			statement.SetEndPosition(_lexer);
			return statement;
		}
		
		/* 
			BNF:
			<continue statement> ::=
				continue
		*/
		protected ContinueStatement ContinueStatement()
		{
			ContinueStatement statement = new ContinueStatement();
			_lexer.NextToken();
			statement.SetPosition(_lexer);
			statement.SetEndPosition(_lexer);
			return statement;
		}
		
		/*
			BNF:
			<case statement> ::=
				case [<expression>]
					<ne case statement item list>
					[else <terminated statement>]
				end
				
			<case statement item> ::=
				when <expression> then <terminated statement>
		*/
		protected CaseStatement CaseStatement()
		{
			CaseStatement caseStatement = new CaseStatement();
			_lexer.NextToken().CheckSymbol(Keywords.Case);
			caseStatement.SetPosition(_lexer);
			if (!(_lexer.PeekTokenSymbol(1) == Keywords.When))
				caseStatement.Expression = Expression();
			bool done = false;
			do
			{
				caseStatement.CaseItems.Add(CaseItemStatement());
				switch (_lexer.PeekTokenSymbol(1))
				{
					case Keywords.When: break;
					case Keywords.Else:
						_lexer.NextToken();
						caseStatement.ElseStatement = TerminatedStatement(); 
						done = true;
					break;
					case Keywords.End:
						done = true;
					break;
					default: throw new ParserException(ParserException.Codes.CaseItemExpressionExpected);
				}
			}
			while (!done);
			_lexer.NextToken().CheckSymbol(Keywords.End);
			caseStatement.SetEndPosition(_lexer);
			return caseStatement;
		}
		
		protected CaseItemStatement CaseItemStatement()
		{
			CaseItemStatement statement = new CaseItemStatement();
			_lexer.NextToken().CheckSymbol(Keywords.When);
			statement.SetPosition(_lexer);
			statement.WhenExpression = Expression();
			_lexer.NextToken().CheckSymbol(Keywords.Then);
			statement.ThenStatement = TerminatedStatement();
			statement.SetEndPosition(_lexer);
			return statement;
		}
		
		/* 
			BNF:
			<try finally statement> ::=
				try
					<terminated statement list>
				finally
					<terminated statement list>
				end
			
			<try except statement> ::=
				try
					<terminated statement list>
				except
					<terminated statement list> | <exception handler list>
				end
				
			<exception handler> ::=
				on [<exception variable> :] <type specifier> do 
					<terminated statement>

			<exception variable> ::=
				<qualified identifier>
				
			<try commit statement> ::=
				try
					<terminated statement list>
				commit
		*/
		protected Statement TryStatement()
		{
			_lexer.NextToken();
			int line = _lexer[0, false].Line;
			int linePos = _lexer[0, false].LinePos;
			Statement tryStatement = DelimitedBlock(new string[] { Keywords.Finally, Keywords.Except, Keywords.Commit });
			switch (_lexer.NextToken().AsSymbol)
			{
				case Keywords.Finally:
					TryFinallyStatement finallyStatement = new TryFinallyStatement();
					finallyStatement.Line = line;
					finallyStatement.LinePos = linePos;
					finallyStatement.TryStatement = tryStatement;
					finallyStatement.FinallyStatement = Block();
					_lexer.NextToken().CheckSymbol(Keywords.End);
					finallyStatement.SetEndPosition(_lexer);
					return finallyStatement;

				case Keywords.Except:
					TryExceptStatement exceptStatement = new TryExceptStatement();
					exceptStatement.Line = line;
					exceptStatement.LinePos = linePos;
					exceptStatement.TryStatement = tryStatement;
						
					if (_lexer.PeekTokenSymbol(1) == Keywords.On)
					{
						string identifier;
						while (true)
						{
							_lexer.NextToken().CheckSymbol(Keywords.On);
							line = _lexer[0, false].Line;
							linePos = _lexer[0, false].LinePos;
							identifier = UnrootedIdentifier();
							GenericErrorHandler errorHandler;
							if (_lexer.PeekTokenSymbol(1) == Keywords.TypeSpecifier)
							{
								_lexer.NextToken();
								errorHandler = new ParameterizedErrorHandler(QualifiedIdentifier(), identifier);
							}
							else
								errorHandler = new SpecificErrorHandler(identifier);
							errorHandler.Line = line;
							errorHandler.LinePos = linePos;
							_lexer.NextToken().CheckSymbol(Keywords.Do);
							
							errorHandler.Statement = TerminatedStatement();
							exceptStatement.ErrorHandlers.Add(errorHandler);
							
							if (_lexer.PeekTokenSymbol(1) == Keywords.End)
								break;
						}
						_lexer.NextToken();
					}
					else if (_lexer.PeekTokenSymbol(1) == Keywords.End)
					{
						_lexer.NextToken();
					}
					else
					{
						exceptStatement.ErrorHandlers.Add(new GenericErrorHandler(Block()));
						_lexer.NextToken();
					}

					exceptStatement.SetEndPosition(_lexer);
					return exceptStatement;
					
				case Keywords.Commit:
					DelimitedBlock block = new DelimitedBlock();
					block.Line = line;
					block.LinePos = linePos;
					block.Statements.Add(new ExpressionStatement(new CallExpression("BeginTransaction", new Expression[]{})));
					TryExceptStatement commitStatement = new TryExceptStatement();
					commitStatement.Line = line;
					commitStatement.LinePos = linePos;
					Block tryBlock = new Block();
					tryBlock.SetPosition(_lexer);
					tryBlock.Statements.Add(tryStatement);
					tryBlock.Statements.Add(new ExpressionStatement(new CallExpression("CommitTransaction", new Expression[]{})));
					commitStatement.TryStatement = tryBlock;
					DelimitedBlock errorBlock = new DelimitedBlock();
					errorBlock.SetPosition(_lexer);
					errorBlock.Statements.Add(new ExpressionStatement(new CallExpression("RollbackTransaction", new Expression[]{})));
					errorBlock.Statements.Add(new RaiseStatement());
					commitStatement.ErrorHandlers.Add(new GenericErrorHandler(errorBlock));
					block.Statements.Add(commitStatement);
					block.SetEndPosition(_lexer);
					return block;
					
				default: throw new ParserException(ParserException.Codes.TryStatementExpected);
			}
		}
		
		/* 
			BNF:
			<raise statement> ::=
				raise [<expression>]
		*/
		protected Statement RaiseStatement()
		{
			RaiseStatement statement = new RaiseStatement();
			_lexer.NextToken();
			statement.SetPosition(_lexer);
			if (_lexer.PeekTokenSymbol(1) != Keywords.StatementTerminator)
				statement.Expression = Expression();
			statement.SetEndPosition(_lexer);
			return statement;
		}

		/*
			BNF:
			<actual parameter> ::=
				[var] <expression>
		*/		
		protected Expression ActualParameter()
		{
			Expression expression;
			switch (_lexer.PeekTokenSymbol(1))
			{
				case Keywords.Var:
					_lexer.NextToken();
					expression = new ParameterExpression();
					expression.SetPosition(_lexer);
					((ParameterExpression)expression).Modifier = Modifier.Var;
					((ParameterExpression)expression).Expression = Expression();
				break;
					
				default:
					expression = Expression();
				break;
			}

			expression.SetEndPosition(_lexer);
			return expression;
		}
		
		/* 
			BNF:
			<create statement> ::=
				<create table statement> |
				<create view statement> |
				<create constraint statement> |
				<create reference statement> |
				<create scalar type statement> |
				<create operator statement> |
				<create aggregate operator statement> |
				<create device statement> |
				<create server link statement> |
				<create sort statement> |
				<create conversion statement> |
				<create role statement> |
				<create right statement>
		*/
		protected Statement CreateStatement()
		{
			_lexer.NextToken();
			int line = _lexer[0, false].Line;
			int linePos = _lexer[0, false].LinePos;
			switch (_lexer.NextToken().AsSymbol)
			{
				case Keywords.Table: return CreateTableStatement(line, linePos, false);
				case Keywords.View: return CreateViewStatement(line, linePos, false);
				case Keywords.Constraint: return CreateConstraintStatement(line, linePos, false);
				case Keywords.Reference: return CreateReferenceStatement(line, linePos, false);
				case Keywords.Operator: return CreateOperatorStatement(line, linePos, false, false);
				case Keywords.Aggregate: return CreateAggregateOperatorStatement(line, linePos, false, false);
				case Keywords.Session:
					switch (_lexer.NextToken().AsSymbol)
					{
						case Keywords.Table: return CreateTableStatement(line, linePos, true);
						case Keywords.View: return CreateViewStatement(line, linePos, true);
						case Keywords.Constraint: return CreateConstraintStatement(line, linePos, true);
						case Keywords.Reference: return CreateReferenceStatement(line, linePos, true);
						case Keywords.Operator: return CreateOperatorStatement(line, linePos, true, false);
						case Keywords.Aggregate: return CreateAggregateOperatorStatement(line, linePos, true, false);
						default : throw new ParserException(ParserException.Codes.UnknownCreateDirective, _lexer[0].AsSymbol);
					}
				case Keywords.Type: return CreateScalarTypeStatement(line, linePos);
				case Keywords.Server: return CreateServerStatement(line, linePos);
				case Keywords.Device: return CreateDeviceStatement(line, linePos);
				case Keywords.Sort: return CreateSortStatement(line, linePos);
				case Keywords.Conversion: return CreateConversionStatement(line, linePos);
				case Keywords.Role: return CreateRoleStatement(line, linePos);
				case Keywords.Right: return CreateRightStatement(line, linePos);
				default: throw new ParserException(ParserException.Codes.UnknownCreateDirective, _lexer[0].AsSymbol);
			}
		}
		
		/* 
			BNF:
			<create table statement> ::=
				create [session] table <table name> 
					[in <device name>]
					(
						(from <expression>) |
						("{"<table definition item commalist>"}")
					)
					<metadata>
				
			<table name> ::=
				<qualified identifier>
				
			<device name> ::=
				<qualified identifier>
		*/
		protected CreateTableStatement CreateTableStatement(int line, int linePos, bool isSession)
		{
			CreateTableStatement statement = new CreateTableStatement();
			statement.Line = line;
			statement.LinePos = linePos;
			statement.IsSession = isSession;
			statement.TableVarName = QualifiedIdentifier();
			if (_lexer.PeekTokenSymbol(1) == Keywords.In)
			{
				_lexer.NextToken().CheckSymbol(Keywords.In);
				statement.DeviceName = new IdentifierExpression(QualifiedIdentifier());
			}
			if (_lexer.PeekTokenSymbol(1) == Keywords.From)
			{
				_lexer.NextToken();
				statement.FromExpression = Expression();
			}
			else
				CreateTableDefinitionList(statement);
			MetaData(statement);
			statement.SetEndPosition(_lexer);
			return statement;
		}

		/* 
			BNF:
			<table definition item> ::=
				<column definition> |
				<row constraint definition> |
				<key definition> |
				<reference definition> |
				<order definition>
		*/        
		protected void CreateTableDefinitionList(CreateTableStatement statement)
		{
			_lexer.NextToken().CheckSymbol(Keywords.BeginList);
			if (_lexer.PeekTokenSymbol(1) == Keywords.EndList)
			{
				_lexer.NextToken();
				return;
			}
			
			do
			{
				switch (_lexer.PeekTokenSymbol(1))
				{
					case Keywords.Transition :
					case Keywords.Constraint : statement.Constraints.Add(RowConstraintDefinition()); break;
					case Keywords.Reference : statement.References.Add(ReferenceDefinition()); break;
					case Keywords.Key : statement.Keys.Add(KeyDefinition()); break;
					case Keywords.Order : statement.Orders.Add(OrderDefinition()); break;
					default: statement.Columns.Add(ColumnDefinition()); break;
				}
				
				switch (_lexer.NextToken().AsSymbol)
				{
					case Keywords.ListSeparator: break;
					case Keywords.EndList: return;
					default: throw new ParserException(ParserException.Codes.ListTerminatorExpected);
				}
			} while (true);
		}

		/*         
			BNF:
			<column definition> ::=
				<column name> : <type specifier>
					<nilable definition>
					["{"<ne column definition item commalist>"}"]
					<metadata>
					
			<column definition item> ::=
				<default definition> |
				<constraint definition> |
				<nilable definition>
				
			<column name> ::=
				<qualified identifier>
				
			<nilable definition> ::=
				[[not] nil]                
		*/
		protected ColumnDefinition ColumnDefinition()
		{
			ColumnDefinition definition = new ColumnDefinition();
			definition.ColumnName = UnrootedIdentifier();
			definition.SetPosition(_lexer);
			_lexer.NextToken().CheckSymbol(Keywords.TypeSpecifier);
			definition.TypeSpecifier = TypeSpecifier();
			
			if (_lexer.PeekTokenSymbol(1) == Keywords.Not)
			{
				_lexer.NextToken();
				_lexer.NextToken().CheckType(TokenType.Nil);
				definition.IsNilable = false;
			}
			else if (_lexer[1].Type == TokenType.Nil)
			{
				_lexer.NextToken();
				definition.IsNilable = true;
			}
			
			if (_lexer.PeekTokenSymbol(1) == Keywords.BeginList)
			{
				_lexer.NextToken();
				bool done = false;
				do
				{
					if (_lexer[1].Type == TokenType.Nil)
					{
						_lexer.NextToken();
						definition.IsNilable = true;
					}
					else
					{
						switch (_lexer.PeekTokenSymbol(1))
						{
							case Keywords.Default:
								if (definition.Default != null)
									throw new ParserException(ParserException.Codes.DefaultDefinitionExists);
								definition.Default = DefaultDefinition();
							break;

							case Keywords.Constraint: 
								definition.Constraints.Add(ConstraintDefinition()); 
							break;

							case Keywords.Not :
								_lexer.NextToken();
								_lexer.NextToken().CheckType(TokenType.Nil);
								definition.IsNilable = false;
							break;

							default: throw new ParserException(ParserException.Codes.UnknownCreateDirective, _lexer.PeekTokenSymbol(1));
						}
					}
					
					switch (_lexer.NextToken().AsSymbol)
					{
						case Keywords.ListSeparator: break;
						case Keywords.EndList: done = true; break;
						default: throw new ParserException(ParserException.Codes.ListTerminatorExpected);
					}
				} while (!done);
			}

			MetaData(definition);
			definition.SetEndPosition(_lexer);
			return definition;
		}
		
		/* 
			BNF:
			<key definition> ::=
				key "{"<column name commalist>"}" <metadata>
		*/
		protected KeyDefinition KeyDefinition()
		{
			KeyDefinition definition = new KeyDefinition();
			_lexer.NextToken().CheckSymbol(Keywords.Key);
			definition.SetPosition(_lexer);
			KeyColumnList(definition.Columns);
			MetaData(definition);
			definition.SetEndPosition(_lexer);
			return definition;
		}
		
		protected void KeyColumnList(KeyColumnDefinitions columns)
		{
			_lexer.NextToken().CheckSymbol(Keywords.BeginList);
			if (_lexer.PeekTokenSymbol(1) == Keywords.EndList)
				_lexer.NextToken();
			else
			{
				KeyColumnDefinition definition;
				do
				{
					definition = new KeyColumnDefinition();
					definition.ColumnName = QualifiedIdentifier();
					definition.SetPosition(_lexer);
					columns.Add(definition);
					switch (_lexer.NextToken().AsSymbol)
					{
						case Keywords.ListSeparator: break;
						case Keywords.EndList: return;
						default: throw new ParserException(ParserException.Codes.ListTerminatorExpected);
					}
				} while (true);
			}
		}
		
		/* 
			BNF:
			<reference definition> ::=
				reference <reference name> 
				"{"<column name commalist>"}" 
				<references definition>
				<metadata>
				
			<reference name> ::=
				<qualified identifier>
		*/
		protected ReferenceDefinition ReferenceDefinition()
		{
			ReferenceDefinition definition = new ReferenceDefinition();
			_lexer.NextToken().CheckSymbol(Keywords.Reference);
			definition.SetPosition(_lexer);
			definition.ReferenceName = QualifiedIdentifier();
			ReferenceColumnList(definition.Columns);
			definition.ReferencesDefinition = ReferencesDefinition();
			MetaData(definition);
			definition.SetEndPosition(_lexer);
			return definition;
		}
		
		protected void UpdateReferenceAction(ReferencesDefinition definition)
		{
			if (_lexer.PeekTokenSymbol(1) == Keywords.Update)
			{
				_lexer.NextToken();
				switch (_lexer.NextToken().AsSymbol)
				{
					case Keywords.Require: definition.UpdateReferenceAction = ReferenceAction.Require; break;
					case Keywords.Cascade: definition.UpdateReferenceAction = ReferenceAction.Cascade; break;
					case Keywords.Clear: definition.UpdateReferenceAction = ReferenceAction.Clear; break;
					case Keywords.Set: 
						definition.UpdateReferenceAction = ReferenceAction.Set;
						_lexer.NextToken().CheckSymbol(Keywords.BeginList);
						if (_lexer.PeekTokenSymbol(1) == Keywords.EndList)
							_lexer.NextToken();
						else
						{
							bool done = false;
							while (!done)
							{
								definition.UpdateReferenceExpressions.Add(Expression());
								switch (_lexer.NextToken().AsSymbol)
								{
									case Keywords.ListSeparator: break;
									case Keywords.EndList: done = true; break;
									default: throw new ParserException(ParserException.Codes.ListTerminatorExpected);
								}
							}
						}
					break;
					default: throw new ParserException(ParserException.Codes.UnknownReferenceAction, _lexer[0].AsSymbol);
				}
			}
		}
		
		protected void DeleteReferenceAction(ReferencesDefinition definition)
		{
			if (_lexer.PeekTokenSymbol(1) == Keywords.Delete)
			{
				_lexer.NextToken();
				switch (_lexer.NextToken().AsSymbol)
				{
					case Keywords.Require: definition.DeleteReferenceAction = ReferenceAction.Require; break;
					case Keywords.Cascade: definition.DeleteReferenceAction = ReferenceAction.Cascade; break;
					case Keywords.Clear: definition.DeleteReferenceAction = ReferenceAction.Clear; break;
					case Keywords.Set:
						definition.DeleteReferenceAction = ReferenceAction.Set;
						_lexer.NextToken().CheckSymbol(Keywords.BeginList);
						if (_lexer.PeekTokenSymbol(1) == Keywords.EndList)
							_lexer.NextToken();
						else
						{
							bool done = false;
							while (!done)
							{
								definition.DeleteReferenceExpressions.Add(Expression());
								switch (_lexer.NextToken().AsSymbol)
								{
									case Keywords.ListSeparator: break;
									case Keywords.EndList: done = true; break;
									default: throw new ParserException(ParserException.Codes.ListTerminatorExpected);
								}
							}
						}
					break;
					default: throw new ParserException(ParserException.Codes.UnknownReferenceAction, _lexer[0].AsSymbol);
				}
			}
		}

		/* 
			BNF:
			<references definition> ::=
				references <tablevar name> "{"<column name commalist>"}" 
				[update (require | cascade | clear | set "{"<expression commalist>"}")] 
				[delete (require | cascade | clear | set "{"<expression commalist>"}")]
				
			<tablevar name> ::=
				<qualified identifier>
		*/		
		protected ReferencesDefinition ReferencesDefinition()
		{
			ReferencesDefinition definition = new ReferencesDefinition();
			_lexer.NextToken().CheckSymbol(Keywords.References);
			definition.SetPosition(_lexer);
			definition.TableVarName = QualifiedIdentifier();
			ReferenceColumnList(definition.Columns);
			UpdateReferenceAction(definition);
			DeleteReferenceAction(definition);
			definition.SetEndPosition(_lexer);
			return definition;
		}
		
		protected void ReferenceColumnList(ReferenceColumnDefinitions columns)
		{
			_lexer.NextToken().CheckSymbol(Keywords.BeginList);
			if (_lexer.PeekTokenSymbol(1) == Keywords.EndList)
				_lexer.NextToken();
			else
			{
				ReferenceColumnDefinition definition;
				do
				{
					definition = new ReferenceColumnDefinition();
					definition.ColumnName = QualifiedIdentifier();
					definition.SetPosition(_lexer);
					columns.Add(definition);
					switch (_lexer.NextToken().AsSymbol)
					{
						case Keywords.ListSeparator: break;
						case Keywords.EndList: return;
						default: throw new ParserException(ParserException.Codes.ListTerminatorExpected);
					}
				} while (true);
			}
		}

		/* 
			BNF:
			<create constraint statement> ::=
				create [session] <constraint definition>

			<constraint definition> ::=
				constraint <constraint name> <expression> <metadata>
				
			<constraint name> ::=
				<qualified identifier>
		*/        
		protected CreateConstraintStatement CreateConstraintStatement(int line, int linePos, bool isSession)
		{
			CreateConstraintStatement statement = new CreateConstraintStatement();
			statement.Line = line;
			statement.LinePos = linePos;
			statement.IsSession = isSession;
			statement.ConstraintName = QualifiedIdentifier();
			statement.Expression = Expression();
			MetaData(statement);
			statement.SetEndPosition(_lexer);
			return statement;
		}
		
		/* 
			BNF:
			<create view statement> ::=
				create [session] view <view name> 
					<expression> 
					["{"<ne view definition item commalist>"}"] 
					<metadata>
				
			<view name> ::=
				<qualified identifier>
		*/        
		protected CreateViewStatement CreateViewStatement(int line, int linePos, bool isSession)
		{
			CreateViewStatement statement = new CreateViewStatement();
			statement.Line = line;
			statement.LinePos = linePos;
			statement.IsSession = isSession;
			statement.TableVarName = QualifiedIdentifier();
			statement.Expression = Expression();
			if (_lexer.PeekTokenSymbol(1) == Keywords.BeginList)
				CreateViewDefinitionList(statement);
			MetaData(statement);
			statement.SetEndPosition(_lexer);
			return statement;
		}
		
		/* 
			BNF:
			<view definition item> ::=
				<row constraint definition> |
				<key definition> |
				<reference definition> |
				<order definition>
		*/        
		protected void CreateViewDefinitionList(CreateViewStatement statement)
		{
			_lexer.NextToken().CheckSymbol(Keywords.BeginList);
			if (_lexer.PeekTokenSymbol(1) == Keywords.EndList)
			{
				_lexer.NextToken();
				return;
			}
			
			do
			{
				switch (_lexer.PeekTokenSymbol(1))
				{
					case Keywords.Transition:
					case Keywords.Constraint: statement.Constraints.Add(RowConstraintDefinition()); break;
					case Keywords.Reference: statement.References.Add(ReferenceDefinition()); break;
					case Keywords.Key: statement.Keys.Add(KeyDefinition()); break;
					case Keywords.Order: statement.Orders.Add(OrderDefinition()); break;
					default: throw new ParserException(ParserException.Codes.ListTerminatorExpected);
				}
				
				switch (_lexer.NextToken().AsSymbol)
				{
					case Keywords.ListSeparator: break;
					case Keywords.EndList: return;
					default: throw new ParserException(ParserException.Codes.ListTerminatorExpected);
				}
			} while (true);
		}

		/*                     
			BNF:
			<order definition> ::=
				order "{"<order column definition commalist>"}" <metadata>
		*/
		protected OrderDefinition OrderDefinition()
		{
			OrderDefinition definition = new OrderDefinition();
			_lexer.NextToken().CheckSymbol(Keywords.Order);
			definition.SetPosition(_lexer);
			OrderColumnDefinitionList(definition.Columns);
			MetaData(definition);
			definition.SetEndPosition(_lexer);
			return definition;
		}
		
		protected void OrderColumnDefinitionList(OrderColumnDefinitions columns)
		{
			_lexer.NextToken().CheckSymbol(Keywords.BeginList);
			if (_lexer.PeekTokenSymbol(1) == Keywords.EndList)
				_lexer.NextToken();
			else
				do
				{
					columns.Add(OrderColumnDefinition());
					switch (_lexer.NextToken().AsSymbol)
					{
						case Keywords.ListSeparator: break;
						case Keywords.EndList: return;
						default: throw new ParserException(ParserException.Codes.ListTerminatorExpected);
					}
				} while (true);
		}

		/*        
			BNF:
			<order column definition> ::=
				<column name> [sort <expression>] [asc | desc] [(include | exclude) nil]
		*/
		protected OrderColumnDefinition OrderColumnDefinition()
		{
			OrderColumnDefinition column = new OrderColumnDefinition();
			column.ColumnName = QualifiedIdentifier();
			column.SetPosition(_lexer);

			if (_lexer.PeekTokenSymbol(1) == Keywords.Sort)
				column.Sort = SortDefinition();

			column.Ascending = true;
			switch (_lexer.PeekTokenSymbol(1))
			{
				case Keywords.Desc: column.Ascending = false; goto case Keywords.Asc;
				case Keywords.Asc: _lexer.NextToken(); break;
			}
			
			column.IncludeNils = false;
			switch (_lexer.PeekTokenSymbol(1))
			{
				case Keywords.Include: column.IncludeNils = true; goto case Keywords.Exclude;
				case Keywords.Exclude: _lexer.NextToken(); _lexer.NextToken().CheckType(TokenType.Nil); break;
			}
			
			return column;
		}
		
		/* 
			BNF:
			<class definition> ::=
				class <class name> [<attributes>]

			<class name> ::=
				<string>
		*/
		protected ClassDefinition ClassDefinition()
		{
			ClassDefinition definition = new ClassDefinition();
			_lexer.NextToken().CheckSymbol(Keywords.Class);
			definition.SetPosition(_lexer);
			_lexer.NextToken();
			definition.ClassName = _lexer[0].AsString;
			if (_lexer.PeekTokenSymbol(1) == Keywords.Attributes)
			{
				_lexer.NextToken();
				ClassAttributeDefinitionList(definition.Attributes);
			}
			definition.SetEndPosition(_lexer);
			return definition;
		}
		
		protected void ClassAttributeDefinitionList(ClassAttributeDefinitions attributes)
		{
			_lexer.NextToken().CheckSymbol(Keywords.BeginList);
			do
			{
				attributes.Add(ClassAttributeDefinition());
				switch (_lexer.NextToken().AsSymbol)
				{
					case Keywords.ListSeparator: break;
					case Keywords.EndList: return;
					default: throw new ParserException(ParserException.Codes.ListTerminatorExpected);
				}
			} while (true);
		}
		
		/* 
			BNF:
			<attributes> ::=
				attributes "{"<ne attribute definition commalist>"}"
				
			<attribute definition> ::=
				<attribute name> = <attribute value>

			<attribute name> ::=
				<string>

			<attribute value> ::=
				<string>
		*/
		protected ClassAttributeDefinition ClassAttributeDefinition()
		{
			ClassAttributeDefinition definition = new ClassAttributeDefinition();
			_lexer.NextToken();
			definition.SetPosition(_lexer);
			definition.AttributeName = _lexer[0].AsString;
			_lexer.NextToken().CheckSymbol(Keywords.Equal);
			_lexer.NextToken();
			definition.AttributeValue = _lexer[0].AsString;
			definition.SetEndPosition(_lexer);
			return definition;
		}

		/* 
			BNF:
			<alter class definition> ::=
				alter class [<class name>] ["{"<alter attribute definition commalist>"}"]
				
			<alter attribute definition> ::=
				(create <attribute definition>) | 
				(alter <attribute definition>) | 
				(drop <attribute name>)
		*/
		protected AlterClassDefinition AlterClassDefinition()
		{
			// This must be able to parse from the alter or class keywords of the construct
			if (_lexer.PeekTokenSymbol(1) == Keywords.Alter)
				_lexer.NextToken();

			_lexer.NextToken().CheckSymbol(Keywords.Class);

			AlterClassDefinition definition = new AlterClassDefinition();
			definition.SetPosition(_lexer);
			if (_lexer.PeekTokenSymbol(1) != Keywords.BeginList)
			{
				_lexer.NextToken();
				definition.ClassName = _lexer[0].AsString;
			}

			if (_lexer.PeekTokenSymbol(1) == Keywords.BeginList)
			{
				_lexer.NextToken();
				bool done = false;
				do
				{
					switch (_lexer.NextToken().AsSymbol)
					{
						case Keywords.Create: definition.CreateAttributes.Add(ClassAttributeDefinition()); break;
						case Keywords.Alter: definition.AlterAttributes.Add(ClassAttributeDefinition()); break;
						case Keywords.Drop:
							ClassAttributeDefinition attributeDefinition = new ClassAttributeDefinition();
							attributeDefinition.SetPosition(_lexer);
							_lexer.NextToken();
							attributeDefinition.AttributeName = _lexer[0].AsString;
							definition.DropAttributes.Add(attributeDefinition); 
						break;
						default: throw new ParserException(ParserException.Codes.DDLDirectiveExpected);
					}

					if (_lexer.NextToken().Type == TokenType.Symbol)
					{
						switch (_lexer[0].AsSymbol)
						{
							case Keywords.ListSeparator: break;
							case Keywords.EndList: done = true; break;
							default: throw new ParserException(ParserException.Codes.ListTerminatorExpected);
						}
					}
					else
						throw new ParserException(ParserException.Codes.ListTerminatorExpected);
				} while (!done);
			}
			
			definition.SetEndPosition(_lexer);
			return definition;
		}
		
		/* 
			BNF:
			<create scalar type statement> ::=
				create type <scalar type name> 
					[from <class definition>]
					[is "{"<ne scalar type name commalist>"}"]
					[like <scalar type name>]
					["{"<scalar type definition item commalist>"}"]
					[<class definition>]
					<metadata>
				
			<scalar type definition item> ::=
				<representation definition> |
				<constraint definition> |
				<default definition> |
				<special definition>
		*/
		protected CreateScalarTypeStatement CreateScalarTypeStatement(int line, int linePos)
		{
			CreateScalarTypeStatement statement = new CreateScalarTypeStatement();
			statement.Line = line;
			statement.LinePos = linePos;
			statement.ScalarTypeName = QualifiedIdentifier();

			if (_lexer.PeekTokenSymbol(1) == Keywords.From)
			{
				_lexer.NextToken();
				statement.FromClassDefinition = ClassDefinition();
			}
			
			if (_lexer.PeekTokenSymbol(1) == Keywords.Is)
			{
				_lexer.NextToken();
				ScalarTypeNameList(statement.ParentScalarTypes);
			}

			if (_lexer.PeekTokenSymbol(1) == Keywords.Like)
			{
				_lexer.NextToken();
				statement.LikeScalarTypeName = QualifiedIdentifier();
			}

			if (_lexer.PeekTokenSymbol(1) == Keywords.BeginList)
			{
				_lexer.NextToken();
				bool done = false;
				do
				{
					switch (_lexer.PeekTokenSymbol(1))
					{
						case Keywords.Representation: statement.Representations.Add(RepresentationDefinition()); break;
						case Keywords.Constraint: statement.Constraints.Add(ConstraintDefinition()); break;
						case Keywords.Special: statement.Specials.Add(SpecialDefinition()); break;
						case Keywords.Default: 
							if (statement.Default != null)
								throw new ParserException(ParserException.Codes.DefaultDefinitionExists);
							statement.Default = DefaultDefinition();
						break;
						default: throw new ParserException(ParserException.Codes.UnknownCreateScalarTypeDirective, _lexer.PeekTokenSymbol(1));
					}
					
					if (_lexer.NextToken().Type == TokenType.Symbol)
					{
						switch (_lexer[0].AsSymbol)
						{
							case Keywords.ListSeparator: break;
							case Keywords.EndList: done = true; break;
							default: throw new ParserException(ParserException.Codes.ListTerminatorExpected);
						}
					}
					else
						throw new ParserException(ParserException.Codes.ListTerminatorExpected);
				} while (!done);
			}

			if (_lexer.PeekTokenSymbol(1) == Keywords.Class)
				statement.ClassDefinition = ClassDefinition();
			MetaData(statement);
			statement.SetEndPosition(_lexer);
			return statement;
		}
		
		protected ScalarTypeNameDefinition ScalarTypeName()
		{
			ScalarTypeNameDefinition definition = new ScalarTypeNameDefinition();
			definition.ScalarTypeName = QualifiedIdentifier();
			definition.SetPosition(_lexer);
			definition.SetEndPosition(_lexer);
			return definition;
		}

		protected void ScalarTypeNameList(ScalarTypeNameDefinitions scalarTypeNames)
		{
			_lexer.NextToken().CheckSymbol(Keywords.BeginList);
			bool done = false;
			do
			{
				scalarTypeNames.Add(ScalarTypeName());
				if (_lexer.NextToken().Type == TokenType.Symbol)
				{
					switch (_lexer[0].AsSymbol)
					{
						case Keywords.ListSeparator: break;
						case Keywords.EndList: done = true; break;
						default: throw new ParserException(ParserException.Codes.ListTerminatorExpected);
					}
				}
				else
					throw new ParserException(ParserException.Codes.ListTerminatorExpected);
			} while (!done); 
		}
		
		/*         
			BNF:
			<representation definition> ::=
				representation <representation name>
					"{"<ne property definition commalist>"}"
					[<class definition> | (selector <accessor block>)]
					<metadata>

			<representation name> ::=
				<qualified identifier>
				
			<accessor block> ::=
				<class definition> | <expression> | <block>
		*/
		protected RepresentationDefinition RepresentationDefinition()
		{
			RepresentationDefinition definition = new RepresentationDefinition();
			_lexer.NextToken().CheckSymbol(Keywords.Representation);
			definition.SetPosition(_lexer);
			definition.RepresentationName = UnrootedIdentifier();
			
			_lexer.NextToken().CheckSymbol(Keywords.BeginList);

			bool done = false;
			do
			{
				definition.Properties.Add(PropertyDefinition());
				
				switch (_lexer.NextToken().AsSymbol)
				{
					case Keywords.ListSeparator: break;
					case Keywords.EndList: done = true; break;
					default: throw new ParserException(ParserException.Codes.ListTerminatorExpected);
				}
			} while (!done);		
			
			switch (_lexer.PeekTokenSymbol(1))
			{
				case Keywords.Class : 
					definition.SelectorAccessorBlock = new AccessorBlock();
					definition.SelectorAccessorBlock.ClassDefinition = ClassDefinition(); 
				break;
				
				case Keywords.Selector :
					_lexer.NextToken();
					definition.SelectorAccessorBlock = new AccessorBlock();
					AccessorBlock(definition.SelectorAccessorBlock);
				break;
			}

			MetaData(definition);
			definition.SetEndPosition(_lexer);
			return definition;
		}
		
		protected void AccessorBlock(AccessorBlock accessorBlock)
		{
			switch (_lexer.PeekTokenSymbol(1))
			{
				case Keywords.Class : accessorBlock.ClassDefinition = ClassDefinition(); break;
				case Keywords.Begin :
					_lexer.NextToken();
					accessorBlock.Block = Block();
					_lexer.NextToken().CheckSymbol(Keywords.End);
				break;
				default : accessorBlock.Expression = Expression(); break;
			}
		}
		
		/* 
			BNF:
			<property definition> ::=
				<property name> : <type specifier> 
					[read <accessor block>] 
					[write <accessor block>] 
					<metadata>
					
			<property name> ::=
				<qualified identifier>
		*/
		protected PropertyDefinition PropertyDefinition()
		{
			PropertyDefinition definition = new PropertyDefinition();
			definition.PropertyName = UnrootedIdentifier();
			definition.SetPosition(_lexer);
			_lexer.NextToken().CheckSymbol(Keywords.TypeSpecifier);
			definition.PropertyType = TypeSpecifier();
			
			if (_lexer.PeekTokenSymbol(1) == Keywords.Read)
			{
				_lexer.NextToken();
				definition.ReadAccessorBlock = new AccessorBlock();
				AccessorBlock(definition.ReadAccessorBlock);
			}
			
			if (_lexer.PeekTokenSymbol(1) == Keywords.Write)
			{
				_lexer.NextToken();
				definition.WriteAccessorBlock = new AccessorBlock();
				AccessorBlock(definition.WriteAccessorBlock);
			}

			MetaData(definition);
			definition.SetEndPosition(_lexer);
			return definition;
		}
		
		/*
			BNF:
			<default definition> ::=
				default <expression> <metadata>
		*/                    
		protected DefaultDefinition DefaultDefinition()
		{
			DefaultDefinition definition = new DefaultDefinition();
			_lexer.NextToken().CheckSymbol(Keywords.Default);
			definition.SetPosition(_lexer);
			definition.Expression = Expression();
			MetaData(definition);
			definition.SetEndPosition(_lexer);
			return definition;
		}
		
		protected ConstraintDefinition ConstraintDefinition()
		{
			ConstraintDefinition definition = new ConstraintDefinition();
			_lexer.NextToken().CheckSymbol(Keywords.Constraint);
			definition.SetPosition(_lexer);
			definition.ConstraintName = UnrootedIdentifier();
			definition.Expression = Expression();
			MetaData(definition);
			definition.SetEndPosition(_lexer);
			return definition;
		}

		/*
			BNF:
			<row constraint definition> ::=
				<constraint definition> |
				<transition constraint definition>
				
			<transition constraint definition> ::=
				transition constraint <constraint name>
					[on insert <expression>]
					[on update <expression>]
					[on delete <expression>]
					<metadata>
		*/        
		protected CreateConstraintDefinition RowConstraintDefinition()
		{
			if (_lexer.PeekTokenSymbol(1) == Keywords.Transition)
			{
				_lexer.NextToken();
				TransitionConstraintDefinition definition = new TransitionConstraintDefinition();
				definition.SetPosition(_lexer);
				_lexer.NextToken().CheckSymbol(Keywords.Constraint);
				definition.ConstraintName = UnrootedIdentifier();
				while (_lexer.PeekTokenSymbol(1) == Keywords.On)
				{
					_lexer.NextToken();
					switch (_lexer.NextToken().AsSymbol)
					{
						case Keywords.Insert : definition.OnInsertExpression = Expression(); break;
						case Keywords.Update : definition.OnUpdateExpression = Expression(); break;
						case Keywords.Delete : definition.OnDeleteExpression = Expression(); break;
						default : throw new ParserException(ParserException.Codes.UnknownConstraintTarget);
					}
				}
				MetaData(definition);
				definition.SetEndPosition(_lexer);
				return definition;
			}
			else
			{
				ConstraintDefinition definition = new ConstraintDefinition();
				_lexer.NextToken().CheckSymbol(Keywords.Constraint);
				definition.SetPosition(_lexer);
				definition.ConstraintName = UnrootedIdentifier();
				definition.Expression = Expression();
				MetaData(definition);
				definition.SetEndPosition(_lexer);
				return definition;
			}
		}
		
		/* 
			BNF:
			<special definition> ::=
				special <special name> <expression> <metadata>

			<special name> ::=
				<qualified identifier>
		*/
		protected SpecialDefinition SpecialDefinition()
		{
			SpecialDefinition definition = new SpecialDefinition();
			_lexer.NextToken().CheckSymbol(Keywords.Special);
			definition.SetPosition(_lexer);
			definition.Name = UnrootedIdentifier();
			definition.Value = Expression();
			MetaData(definition);
			definition.SetEndPosition(_lexer);
			return definition;
		}
		
		/*
			<sort definition> ::=
				sort <expression>
		*/
		protected SortDefinition SortDefinition()
		{
			SortDefinition definition = new SortDefinition();
			_lexer.NextToken().CheckSymbol(Keywords.Sort);
			definition.SetPosition(_lexer);
			definition.Expression = Expression();
			definition.SetEndPosition(_lexer);
			return definition;
		}
		
		/* 
			BNF:
			<create reference statement> ::=
				create [session] reference <reference name>
					<tablevar name> "{"<column name commalist>"}" 
					<references definition>
					<metadata>
		*/        
		protected CreateReferenceStatement CreateReferenceStatement(int line, int linePos, bool isSession)
		{
			CreateReferenceStatement statement = new CreateReferenceStatement();
			statement.Line = line;
			statement.LinePos = linePos;
			statement.IsSession = isSession;
			statement.ReferenceName = QualifiedIdentifier();
			statement.TableVarName = QualifiedIdentifier();
			ReferenceColumnList(statement.Columns);
			statement.ReferencesDefinition = ReferencesDefinition();
			MetaData(statement);
			statement.SetEndPosition(_lexer);
			return statement;
		}
		
		/* 
			BNF:
			<create operator statement> ::=
				create [session] operator
					<operator name>
					"("<formal parameter commalist>")"
					[: <type specifier>]
					(<class definition> | <block>)
					<metadata>
					
			<operator name> ::=
				<qualified identifier>
		*/
		protected CreateOperatorStatement CreateOperatorStatement(int line, int linePos, bool isSession, bool isDeclarationOnly)
		{
			CreateOperatorStatement statement = new CreateOperatorStatement();
			statement.Line = line;
			statement.LinePos = linePos;
			statement.OperatorName = QualifiedIdentifier();
			statement.IsSession = isSession;
			FormalParameterList(statement.FormalParameters);
			if (_lexer.PeekTokenSymbol(1) == Keywords.TypeSpecifier)
			{
				_lexer.NextToken();
				statement.ReturnType = TypeSpecifier();
			}
			
			if (!isDeclarationOnly)
			{
				#if USETYPEINHERITANCE
				// [reintroduce] [abstract | virtual | override]
				// Virtual invocation has been removed until we have a better solution for casting physical representations and specialization by constraint
				switch (FLexer.PeekTokenSymbol(1))
				{
					case Keywords.Reintroduce:
						FLexer.NextToken();
						statement.IsReintroduced = true;
						switch (FLexer.PeekTokenSymbol(1))
						{
							case Keywords.Abstract:
								FLexer.NextToken();
								statement.IsAbstract = true;
							break;
							
							case Keywords.Virtual:
								FLexer.NextToken();
								statement.IsVirtual = true;
							break;
							
							case Keywords.Override:
								throw new ParserException(ParserException.Codes.InvalidOverrideDirective);
						}
					break;
					
					case Keywords.Abstract:
						FLexer.NextToken();
						statement.IsAbstract = true;
					break;
					
					case Keywords.Virtual:
						FLexer.NextToken();
						statement.IsVirtual = true;
					break;
					
					case Keywords.Override:
						FLexer.NextToken();
						statement.IsOverride = true;
					break;
				}
				#endif

				bool hasBody = false;
				switch (_lexer.PeekTokenSymbol(1))
				{
					case Keywords.Class:
						#if USETYPEINHERITANCE
						if (statement.IsAbstract)
							throw new ParserException(ParserException.Codes.InvalidAbstractDirective);
						#endif
						statement.Block.ClassDefinition = ClassDefinition();
						statement.Block.Line = statement.Block.ClassDefinition.Line;
						statement.Block.LinePos = statement.Block.ClassDefinition.LinePos;
						statement.Block.SetEndPosition(_lexer);
						hasBody = true;
					break;
					
					case Keywords.Begin:
						#if USETYPEINHERITANCE
						if (statement.IsAbstract)
							throw new ParserException(ParserException.Codes.InvalidAbstractDirective);
						#endif
						_lexer.NextToken();
						line = _lexer[0].Line;
						linePos = _lexer[0].LinePos;
						statement.Block.Block = Block();
						_lexer.NextToken().CheckSymbol(Keywords.End);
						statement.Block.Line = line;
						statement.Block.LinePos = linePos;
						statement.Block.SetEndPosition(_lexer);
						hasBody = true;
					break;
				}

				#if USETYPEINHERITANCE			
				if (!statement.IsAbstract && !hasBody)
					throw new ParserException(ParserException.Codes.InvalidOperatorDefinition);
				#endif
				
				if (!hasBody)
					throw new ParserException(ParserException.Codes.InvalidOperatorDefinition);

				MetaData(statement);
				statement.SetEndPosition(_lexer);
			}

			return statement;
		}
		
		protected void FormalParameterList(FormalParameters formalParameters)
		{
			_lexer.NextToken().CheckSymbol(Keywords.BeginGroup);
			if (_lexer.PeekTokenSymbol(1) == Keywords.EndGroup)
				_lexer.NextToken();
			else
				do
				{
					formalParameters.Add(FormalParameter());
					switch (_lexer.NextToken().AsSymbol)
					{
						case Keywords.ListSeparator: break;
						case Keywords.EndGroup: return;
						default: throw new ParserException(ParserException.Codes.GroupTerminatorExpected);
					}
				} while (true);
		}
		
		/* 
			BNF:
			<formal parameter> ::=
				[<modifier>] <named type specifier>

			<modifier> ::=
				[var | const]
		*/
		protected FormalParameter FormalParameter()
		{
			FormalParameter formalParameter = new FormalParameter();
			switch (_lexer.PeekTokenSymbol(1))
			{
				case Keywords.Var: 
					_lexer.NextToken();
					formalParameter.Modifier = Modifier.Var;
				break;
					
				case Keywords.Const:
					_lexer.NextToken();
					formalParameter.Modifier = Modifier.Const;
				break;
			}
			
			formalParameter.Identifier = UnrootedIdentifier();
			formalParameter.SetPosition(_lexer);
			_lexer.NextToken().CheckSymbol(Keywords.TypeSpecifier);
			formalParameter.TypeSpecifier = TypeSpecifier();
			formalParameter.SetEndPosition(_lexer);
			return formalParameter;
		}

		protected LineInfo NamedTypeSpecifierList(NamedTypeSpecifiers typeSpecifiers)
		{
			_lexer.NextToken().CheckSymbol(Keywords.BeginList);
			LineInfo result = new LineInfo(_lexer[0, false].LinePos, _lexer[0, false].Line, -1, -1);
			if (_lexer.PeekTokenSymbol(1) == Keywords.EndList)
			{
				_lexer.NextToken();
				return result;
			}
			else
				do
				{
					typeSpecifiers.Add(NamedTypeSpecifier());
					switch (_lexer.NextToken().AsSymbol)
					{
						case Keywords.ListSeparator: break;
						case Keywords.EndList: return result;
						default: throw new ParserException(ParserException.Codes.ListTerminatorExpected);
					}
				} while (true);
		}

		/* 
			BNF:
			<named type specifier> ::=
				<qualified identifier> : <type specifier>
		*/        
		protected NamedTypeSpecifier NamedTypeSpecifier()
		{
			NamedTypeSpecifier specifier = new NamedTypeSpecifier();
			specifier.Identifier = UnrootedIdentifier();
			specifier.SetPosition(_lexer);
			_lexer.NextToken().CheckSymbol(Keywords.TypeSpecifier);
			specifier.TypeSpecifier = TypeSpecifier();
			specifier.SetEndPosition(_lexer);
			return specifier;
		}

		/* 
			BNF:
			<type specifier> ::=
				<generic type specifier> |
				<scalar type specifier> |
				<row type specifier> |
				<table type specifier> |
				<list type specifier> |
				<cursor type specifier> |
				<typeof type specifier>
		*/        
		protected TypeSpecifier TypeSpecifier()
		{
			switch (_lexer.PeekTokenSymbol(1))
			{
				case Keywords.Generic: 
					_lexer.NextToken();
					switch (_lexer.PeekTokenSymbol(1))
					{
						case Keywords.Type: return ScalarTypeSpecifier(true);
						case Keywords.Row: return RowTypeSpecifier(true);
						case Keywords.Table: return TableTypeSpecifier(true);
						case Keywords.List: return ListTypeSpecifier(true);
						case Keywords.Cursor: return CursorTypeSpecifier(true);
						default: return GenericTypeSpecifier();
					}
										
				case Keywords.Row: return RowTypeSpecifier(false);
				case Keywords.Table: return TableTypeSpecifier(false);
				case Keywords.List: return ListTypeSpecifier(false);
				case Keywords.Cursor: return CursorTypeSpecifier(false);
				//case Keywords.Operator: return OperatorTypeSpecifier();
				case Keywords.TypeOf: return TypeOfTypeSpecifier();
				default: return ScalarTypeSpecifier(false);
			}
		}
		
		/*
			BNF:
			<generic type specifier> ::=
				generic
		*/
		protected GenericTypeSpecifier GenericTypeSpecifier()
		{
			GenericTypeSpecifier specifier = new GenericTypeSpecifier();
			specifier.SetPosition(_lexer);
			specifier.SetEndPosition(_lexer);
			return specifier;
		}

		/*         
			BNF:
			<scalar type specifier> ::=
				[generic] scalar | <scalar type name>
		*/
		protected ScalarTypeSpecifier ScalarTypeSpecifier(bool isGeneric)
		{
			ScalarTypeSpecifier specifier = new ScalarTypeSpecifier();
			if (_lexer.PeekTokenSymbol(1) == Keywords.Scalar)
			{
				_lexer.NextToken();
				specifier.IsGeneric = true;
			}
			else
				specifier.ScalarTypeName = QualifiedIdentifier();
			specifier.SetPosition(_lexer);
			specifier.SetEndPosition(_lexer);
			return specifier;
		}

		/* 
			BNF:
			<list type specifier> ::=
				[generic] list["("<type specifier>")"]
		*/
		protected ListTypeSpecifier ListTypeSpecifier(bool isGeneric)
		{
			ListTypeSpecifier specifier = new ListTypeSpecifier();
			_lexer.NextToken();
			specifier.SetPosition(_lexer);
			if (isGeneric)
				specifier.IsGeneric = true;
			else
			{
				if (_lexer.PeekTokenSymbol(1) == Keywords.BeginGroup)
				{
					_lexer.NextToken();
					specifier.TypeSpecifier = TypeSpecifier();
					_lexer.NextToken().CheckSymbol(Keywords.EndGroup);
				}
				else
					specifier.IsGeneric = true;
			}
			specifier.SetEndPosition(_lexer);
			return specifier;
		}

		/* 
			BNF:
			<row type specifier> ::=
				[generic] row["{"<named type specifier commalist>"}"]
		*/        
		protected RowTypeSpecifier RowTypeSpecifier(bool isGeneric)
		{
			RowTypeSpecifier specifier = new RowTypeSpecifier();
			_lexer.NextToken();
			specifier.SetPosition(_lexer);
			if (isGeneric)
				specifier.IsGeneric = true;
			else
			{
				if (_lexer.PeekTokenSymbol(1) == Keywords.BeginList)
					NamedTypeSpecifierList(specifier.Columns);
				else
					specifier.IsGeneric = true;	
			}
			specifier.SetEndPosition(_lexer);
			return specifier;
		}
		
		/* 
			BNF:
			<table type specifier> ::=
				[generic] table["{"<named type specifier commalist>"}"]
		*/        
		protected TableTypeSpecifier TableTypeSpecifier(bool isGeneric)        
		{
			TableTypeSpecifier specifier = new TableTypeSpecifier();
			_lexer.NextToken();
			specifier.SetPosition(_lexer);
			if (isGeneric)
				specifier.IsGeneric = true;
			else
			{
				if (_lexer.PeekTokenSymbol(1) == Keywords.BeginList)
				{
					_lexer.NextToken();
					bool done = false;
					do
					{
						switch (_lexer.PeekTokenSymbol(1))
						{
							case Keywords.EndList: break;
							default: specifier.Columns.Add(NamedTypeSpecifier()); break;
						}
						switch (_lexer.NextToken().AsSymbol)
						{
							case Keywords.ListSeparator: break;
							case Keywords.EndList: done = true; break;
							default: throw new ParserException(ParserException.Codes.ListTerminatorExpected);
						}
					} while (!done);
				}
				else
					specifier.IsGeneric = true;
			}
			specifier.SetEndPosition(_lexer);
			return specifier;
		}
		
		/*         
			BNF:
			<cursor type specifier> ::=
				[generic] cursor["("<type specifier>")"]
		*/
		protected CursorTypeSpecifier CursorTypeSpecifier(bool isGeneric)
		{
			CursorTypeSpecifier specifier = new CursorTypeSpecifier();
			_lexer.NextToken();
			specifier.SetPosition(_lexer);
			if (isGeneric)
				specifier.IsGeneric = true;
			else
			{
				if (_lexer.PeekTokenSymbol(1) == Keywords.BeginGroup)
				{
					_lexer.NextToken();
					specifier.TypeSpecifier = TypeSpecifier();
					_lexer.NextToken().CheckSymbol(Keywords.EndGroup);
				}
				else
					specifier.IsGeneric = true;
			}
			specifier.SetEndPosition(_lexer);
			return specifier;
		}
		
		/* 
			!BNF:
			<operator type specifier> ::=
				operator["("<formal parameter specifier commalist>")"]
		*/
		/*
		protected OperatorTypeSpecifier OperatorTypeSpecifier()
		{
			OperatorTypeSpecifier LSpecifier = new OperatorTypeSpecifer();
			FLexer.NextToken();
			LSpecifier.SetPosition(FLexer);
			if (FLexer.PeekTokenSymbol(1) == Keywords.BeginGroup)
				FormalParameterSpecifiers(LSpecifier.TypeSpecifiers);
			else
				LSpecifier.IsGeneric = true;
			return LSpecifier;
		}
		*/

		/* 
			BNF:
			<typeof type specifier> ::=
				typeof"("<expression>")"
		*/        
		protected TypeOfTypeSpecifier TypeOfTypeSpecifier()
		{
			TypeOfTypeSpecifier typeSpecifier = new TypeOfTypeSpecifier();
			_lexer.NextToken();
			typeSpecifier.SetPosition(_lexer);
			_lexer.NextToken().CheckSymbol(Keywords.BeginGroup);
			typeSpecifier.Expression = Expression();
			_lexer.NextToken().CheckSymbol(Keywords.EndGroup);
			typeSpecifier.SetEndPosition(_lexer);
			return typeSpecifier;
		}
		
		/* 
			BNF:
			<formal parameter specifier> ::=
				[<modifier>] <type specifier>
		*/
		protected FormalParameterSpecifier FormalParameterSpecifier()
		{
			FormalParameterSpecifier typeSpecifier = new FormalParameterSpecifier();
			switch (_lexer.PeekTokenSymbol(1))
			{
				case Keywords.Var: 
					_lexer.NextToken(); 
					typeSpecifier.Modifier = Modifier.Var;
					typeSpecifier.SetPosition(_lexer);
					break;
				case Keywords.Const: 
					_lexer.NextToken(); 
					typeSpecifier.Modifier = Modifier.Const;
					typeSpecifier.SetPosition(_lexer);
					break;
				default: break;
			}
			
			typeSpecifier.TypeSpecifier = TypeSpecifier();
			if (typeSpecifier.Line == -1)
			{
				typeSpecifier.Line = typeSpecifier.TypeSpecifier.Line;
				typeSpecifier.LinePos = typeSpecifier.TypeSpecifier.LinePos;
			}
			typeSpecifier.SetEndPosition(_lexer);
			return typeSpecifier;
		}
		
		protected void FormalParameterSpecifiers(FormalParameterSpecifiers typeSpecifiers)
		{
			_lexer.NextToken().CheckSymbol(Keywords.BeginGroup);
			if (_lexer.PeekTokenSymbol(1) == Keywords.EndGroup)
				_lexer.NextToken();
			else
			{
				bool done = false;
				do
				{
					typeSpecifiers.Add(FormalParameterSpecifier());
					switch (_lexer.NextToken().AsSymbol)
					{
						case Keywords.ListSeparator: break;
						case Keywords.EndGroup: done = true; break;
						default: throw new ParserException(ParserException.Codes.ListTerminatorExpected);
					}
				} while (!done);
			}
		}

		/* 
			BNF:
			<create aggregate operator statement> ::=
				create [session] aggregate operator
					<operator name>
					"("<formal parameter commalist>")"
					: <type specifier>
					initialization (<class definition> | <block>)
					aggregation (<class definition> | <block>)
					finalization (<class definition> | <block>)
					<metadata>
		*/
		protected CreateAggregateOperatorStatement CreateAggregateOperatorStatement(int line, int linePos, bool isSession, bool isDeclarationOnly)
		{
			CreateAggregateOperatorStatement statement = new CreateAggregateOperatorStatement();
			statement.Line = line;
			statement.LinePos = linePos;
			statement.IsSession = isSession;
			_lexer.NextToken().CheckSymbol(Keywords.Operator);
			statement.OperatorName = QualifiedIdentifier();
			FormalParameterList(statement.FormalParameters);
			_lexer.NextToken().CheckSymbol(Keywords.TypeSpecifier);
			statement.ReturnType = TypeSpecifier();
			
			if (!isDeclarationOnly)
			{
				#if USETYPEINHERITANCE			
				// [reintroduce] [abstract | virtual | override]
				switch (FLexer.PeekTokenSymbol(1))
				{
					case Keywords.Reintroduce:
						FLexer.NextToken();
						statement.IsReintroduced = true;
						switch (FLexer.PeekTokenSymbol(1))
						{
							case Keywords.Abstract:
								FLexer.NextToken();
								statement.IsAbstract = true;
							break;
							
							case Keywords.Virtual:
								FLexer.NextToken();
								statement.IsVirtual = true;
							break;
							
							case Keywords.Override:
								throw new ParserException(ParserException.Codes.InvalidOverrideDirective);
						}
					break;

					case Keywords.Abstract:
						FLexer.NextToken();
						statement.IsAbstract = true;
					break;
					
					case Keywords.Virtual:
						FLexer.NextToken();
						statement.IsVirtual = true;
					break;
					
					case Keywords.Override:
						FLexer.NextToken();
						statement.IsOverride = true;
					break;
				}

				if (!statement.IsAbstract)
				{
				#endif
					_lexer.NextToken().CheckSymbol(Keywords.Initialization);
					statement.Initialization.SetPosition(_lexer);
					if (_lexer.PeekTokenSymbol(1) == Keywords.Class)
						statement.Initialization.ClassDefinition = ClassDefinition();
					else
					{
						_lexer.NextToken().CheckSymbol(Keywords.Begin);
						statement.Initialization.Block = Block();
						_lexer.NextToken().CheckSymbol(Keywords.End);
					}
					statement.Initialization.SetEndPosition(_lexer);
						
					_lexer.NextToken().CheckSymbol(Keywords.Aggregation);
					statement.Aggregation.SetPosition(_lexer);
					if (_lexer.PeekTokenSymbol(1) == Keywords.Class)
						statement.Aggregation.ClassDefinition = ClassDefinition();
					else
					{
						_lexer.NextToken().CheckSymbol(Keywords.Begin);
						statement.Aggregation.Block = Block();
						_lexer.NextToken().CheckSymbol(Keywords.End);
					}
					statement.Aggregation.SetEndPosition(_lexer);
						
					_lexer.NextToken().CheckSymbol(Keywords.Finalization);
					statement.Finalization.SetPosition(_lexer);
					if (_lexer.PeekTokenSymbol(1) == Keywords.Class)
						statement.Finalization.ClassDefinition = ClassDefinition();
					else
					{
						_lexer.NextToken().CheckSymbol(Keywords.Begin);
						statement.Finalization.Block = Block();
						_lexer.NextToken().CheckSymbol(Keywords.End);
					}
					statement.Finalization.SetEndPosition(_lexer);

				#if USETYPEINHERITANCE
				}
				else
					if (FLexer.PeekTokenSymbol(1) == Keywords.Initialization)
						throw new ParserException(ParserException.Codes.InvalidAbstractDirective);
				#endif

				MetaData(statement);
				statement.SetEndPosition(_lexer);
			}
				
			return statement;
		}
		
		/* 
			BNF:
			<create server link statement> ::=
				create server <server link name> <metadata>

			<server link name> ::=
				<qualified identifier>
		*/        
		protected CreateServerStatement CreateServerStatement(int line, int linePos)
		{
			CreateServerStatement statement = new CreateServerStatement();
			statement.Line = line;
			statement.LinePos = linePos;
			statement.ServerName = QualifiedIdentifier();
			MetaData(statement);
			statement.SetEndPosition(_lexer);
			return statement;
		}
		
		/* 
			BNF:
			<create device statement> ::=
				create device <device name>
					<reconciliation settings>
					<class definition>
					<metadata>
					
			<device map item> ::=
				<device scalar type map> |
				<device operator map> |
				<device store definition>
		*/        

/*
	BTR 5/30/2006 ->
		Removed the create device maps capability from the create device statement.
		1) It would never have actually worked, because of the way device mapping worked internally
		2) Nobody actually did it, because it didn't actually work
		3) It makes things easier to implement overall if you can only create device maps as part of an alter statement
		4) We should maybe even consider a create device map statement, because device maps are, after all, catalog objects
		
		This is the BNF line that was removed (was right after <device name>):
					["{"<device map item commalist>"}"]
*/
		protected CreateDeviceStatement CreateDeviceStatement(int line, int linePos)
		{
			CreateDeviceStatement statement = new CreateDeviceStatement();
			statement.Line = line;
			statement.LinePos = linePos;
			statement.DeviceName = QualifiedIdentifier();
/*
			if (FLexer.PeekTokenSymbol() == Keywords.BeginList)
			{
				FLexer.NextToken();
				bool LDone = false;
				do
				{
					switch (FLexer.NextToken().AsSymbol)
					{
						case Keywords.Type: LStatement.DeviceScalarTypeMaps.Add(DeviceScalarTypeMap()); break;
						case Keywords.Operator: LStatement.DeviceOperatorMaps.Add(DeviceOperatorMap()); break;
						case Keywords.Store: LStatement.DeviceStoreDefinitions.Add(DeviceStoreDefinition()); break;
						default: throw new ParserException(ParserException.Codes.UnknownCreateDirective, FLexer[0].AsSymbol);
					}
					
					switch (FLexer.NextToken().AsSymbol)
					{
						case Keywords.ListSeparator: break;
						case Keywords.EndList: LDone = true; break;
						default: throw new ParserException(ParserException.Codes.ListTerminatorExpected);
					}
				} while (!LDone);
			}
*/
			statement.ReconciliationSettings = ReconciliationSettings();
			statement.ClassDefinition = ClassDefinition();
			MetaData(statement);
			statement.SetEndPosition(_lexer);
			return statement;
		}
		
		/* 
			BNF:
			<device scalar type map> ::=
				type <scalar type name> [<class definition>] <metadata>
		*/
		protected DeviceScalarTypeMap DeviceScalarTypeMap()
		{
			DeviceScalarTypeMap deviceScalarTypeMap = new DeviceScalarTypeMap();
			deviceScalarTypeMap.SetPosition(_lexer);
			deviceScalarTypeMap.ScalarTypeName = QualifiedIdentifier();
			if (_lexer.PeekTokenSymbol(1) == Keywords.Class)
				deviceScalarTypeMap.ClassDefinition = ClassDefinition();
			MetaData(deviceScalarTypeMap);
			deviceScalarTypeMap.SetEndPosition(_lexer);
			return deviceScalarTypeMap;
		}
		
		/* 
			BNF:
			<device operator map> ::=
				operator <operator specifier> [<class definition>] <metadata>
		*/
		protected DeviceOperatorMap DeviceOperatorMap()
		{
			DeviceOperatorMap deviceOperatorMap = new DeviceOperatorMap();
			deviceOperatorMap.SetPosition(_lexer);
			deviceOperatorMap.OperatorSpecifier = OperatorSpecifier();
			if (_lexer.PeekTokenSymbol(1) == Keywords.Class)
				deviceOperatorMap.ClassDefinition = ClassDefinition();
			MetaData(deviceOperatorMap);
			deviceOperatorMap.SetEndPosition(_lexer);
			return deviceOperatorMap;
		}
		
		/*
			BNF:
			<operator specifier> ::=
				<operator name>"("<formal parameter specifier commalist>")"
		*/
		protected OperatorSpecifier OperatorSpecifier()
		{
			OperatorSpecifier operatorSpecifier = new OperatorSpecifier();
			operatorSpecifier.SetPosition(_lexer);
			operatorSpecifier.OperatorName = QualifiedIdentifier();
			FormalParameterSpecifiers(operatorSpecifier.FormalParameterSpecifiers);
			operatorSpecifier.SetEndPosition(_lexer);
			return operatorSpecifier;
		}
		
		/*
			BNF:
			<device store definition> ::=
				store <store name> 
					[<expression>] 
					by (default | ("{"<index column definition commalist>"}" <metadata>))
					[indexes (default | "{"<ne index definition commalist>"}")]
					<metadata>
				
			<store name> ::=
				<qualified identifier>
		*/
		protected DeviceStoreDefinition DeviceStoreDefinition()
		{
			DeviceStoreDefinition definition = new DeviceStoreDefinition();
			definition.SetPosition(_lexer);
			definition.StoreName = QualifiedIdentifier();
			if (_lexer.PeekTokenSymbol(1) != Keywords.By)
				definition.Expression = Expression();
			_lexer.NextToken().CheckSymbol(Keywords.By);
			if (_lexer.PeekTokenSymbol(1) == Keywords.Default)
			{
				_lexer.NextToken();
				definition.ClusteredDefault = true;
			}
			else
			{
				definition.ClusteredIndexDefinition = new IndexDefinition();
				definition.SetPosition(_lexer);
				IndexColumnDefinitionList(definition.ClusteredIndexDefinition.Columns);
				MetaData(definition.ClusteredIndexDefinition);
			}

			if (_lexer.PeekTokenSymbol(1) == Keywords.Indexes)
			{
				if (_lexer.PeekTokenSymbol(1) == Keywords.Default)
				{
					_lexer.NextToken();
					definition.IndexesDefault = true;
				}
				else
				{
					_lexer.NextToken().CheckSymbol(Keywords.BeginList);
					bool done = false;
					while (!done)
					{
						definition.IndexDefinitions.Add(IndexDefinition());
						
						switch (_lexer.NextToken().AsSymbol)
						{
							case Keywords.ListSeparator : break;
							case Keywords.EndList : done = true; break;
							default : throw new ParserException(ParserException.Codes.ListTerminatorExpected);
						}
					}
				}
			}
			
			MetaData(definition);
			definition.SetEndPosition(_lexer);
			return definition;
		}        

		/*
			BNF:
			<index definition> ::=
				index "{"<index column definition commalist>"}" <metadata>
		*/
		protected IndexDefinition IndexDefinition()
		{
			IndexDefinition definition = new IndexDefinition();
			_lexer.NextToken().CheckSymbol(Keywords.Index);
			definition.SetPosition(_lexer);
			IndexColumnDefinitionList(definition.Columns);
			MetaData(definition);
			definition.SetEndPosition(_lexer);
			return definition;
		}
		
		protected void IndexColumnDefinitionList(IndexColumnDefinitions columns)
		{
			_lexer.NextToken().CheckSymbol(Keywords.BeginList);
			if (_lexer.PeekTokenSymbol(1) == Keywords.EndList)
				_lexer.NextToken();
			else
				do
				{
					columns.Add(IndexColumnDefinition());
					switch (_lexer.NextToken().AsSymbol)
					{
						case Keywords.ListSeparator: break;
						case Keywords.EndList: return;
						default: throw new ParserException(ParserException.Codes.ListTerminatorExpected);
					}
				} while (true);
		}

		/*
			BNF:
			<index column definition> ::=
				<column name> [sort <expression>] [asc | desc]
		*/        
		protected IndexColumnDefinition IndexColumnDefinition()
		{
			IndexColumnDefinition column = new IndexColumnDefinition();
			column.ColumnName = QualifiedIdentifier();
			column.SetPosition(_lexer);

			if (_lexer.PeekTokenSymbol(1) == Keywords.Sort)
				column.Sort = SortDefinition();

			column.Ascending = true;
			switch (_lexer.PeekTokenSymbol(1))
			{
				case Keywords.Desc: column.Ascending = false; goto case Keywords.Asc;
				case Keywords.Asc: _lexer.NextToken(); break;
			}
			
			column.SetEndPosition(_lexer);
			return column;
		}
		
		/* 
			BNF:
			<reconciliation settings> ::=
				[reconciliation "{"<reconciliation settings item commalist>"}"]
				
			<reconciliation settings item> ::=
				<reconciliation mode definition> |
				<reconciliation master>
				
			<reconciliation mode definition> ::=
				mode = "{"<reconciliation mode commalist>"}"
				
			<reconciliation mode> ::=
				none |
				startup |
				command |
				automatic
				
			<reconciliation master> ::=
				master = (server | device | both)
		*/
		public ReconciliationSettings ReconciliationSettings()
		{
			ReconciliationSettings settings = new ReconciliationSettings();
			if (_lexer.PeekTokenSymbol(1) == Keywords.Reconciliation)
			{
				_lexer.NextToken();
				settings.SetPosition(_lexer);
				_lexer.NextToken().CheckSymbol(Keywords.BeginList);
				bool done = false;
				do
				{
					switch (_lexer.NextToken().AsSymbol)
					{
						case Keywords.Mode:
							_lexer.NextToken().CheckSymbol(Keywords.Equal);
							_lexer.NextToken().CheckSymbol(Keywords.BeginList);
							bool innerDone = false;
							do
							{
								settings.ReconcileMode = settings.ReconcileMode | (ReconcileMode)Enum.Parse(typeof(ReconcileMode), _lexer.NextToken().AsSymbol, true);
								
								switch (_lexer.NextToken().AsSymbol)
								{
									case Keywords.ListSeparator: break;
									case Keywords.EndList: innerDone = true; break;
									default: throw new ParserException(ParserException.Codes.ListTerminatorExpected);
								}
							} while (!innerDone);
						break;

						case Keywords.Master:
							_lexer.NextToken().CheckSymbol(Keywords.Equal);
							settings.ReconcileMaster = (ReconcileMaster)Enum.Parse(typeof(ReconcileMaster), _lexer.NextToken().AsSymbol, true);
						break;
					}
					
					switch (_lexer.NextToken().AsSymbol)
					{
						case Keywords.ListSeparator: break;
						case Keywords.EndList: done = true; break;
						default: throw new ParserException(ParserException.Codes.ListTerminatorExpected);
					}
				} while (!done);
			}

			return settings;
		}

		/*
			BNF:
			<create sort statement> ::=
				create sort <scalar type name> using <expression> <metadata>
		*/        
		protected CreateSortStatement CreateSortStatement(int line, int linePos)
		{
			CreateSortStatement statement = new CreateSortStatement();
			statement.Line = line;
			statement.LinePos = linePos;
			statement.ScalarTypeName = QualifiedIdentifier();
			_lexer.NextToken().CheckSymbol(Keywords.Using);
			statement.Expression = Expression();
			MetaData(statement);
			statement.SetEndPosition(_lexer);
			return statement;
		}
		
		/*
			BNF:
			<create conversion statement> ::=
				create conversion <scalar type name> to <scalar type name> using <operator name> [widening | narrowing] <metadata>
		*/
		protected CreateConversionStatement CreateConversionStatement(int line, int linePos)
		{
			CreateConversionStatement statement = new CreateConversionStatement();
			statement.Line = line;
			statement.LinePos = linePos;
			statement.SourceScalarTypeName = TypeSpecifier();
			_lexer.NextToken().CheckSymbol(Keywords.To);
			statement.TargetScalarTypeName = TypeSpecifier();
			_lexer.NextToken().CheckSymbol(Keywords.Using);
			statement.OperatorName = new IdentifierExpression();
			statement.OperatorName.Identifier = QualifiedIdentifier();
			statement.OperatorName.SetPosition(_lexer);
			switch (_lexer.PeekTokenSymbol(1))
			{
				case Keywords.Widening :
					_lexer.NextToken();
					statement.IsNarrowing = false;
				break;
				
				case Keywords.Narrowing :
					_lexer.NextToken();
					statement.IsNarrowing = true;
				break;
			}
			MetaData(statement);
			statement.SetEndPosition(_lexer);
			return statement;
		}
		
		/*
			BNF:
			<create role statement> ::=
				create role <role name> <metadata>
		*/
		protected CreateRoleStatement CreateRoleStatement(int line, int linePos)
		{
			CreateRoleStatement statement = new CreateRoleStatement();
			statement.Line = line;
			statement.LinePos = linePos;
			statement.RoleName = QualifiedIdentifier();
			MetaData(statement);
			statement.SetEndPosition(_lexer);
			return statement;
		}
		
		/*
			BNF:
			<create right statement> ::=
				create right <right name>
		*/
		protected CreateRightStatement CreateRightStatement(int line, int linePos)
		{
			CreateRightStatement statement = new CreateRightStatement();
			statement.Line = line;
			statement.LinePos = linePos;
			statement.RightName = QualifiedIdentifier();
			statement.SetEndPosition(_lexer);
			return statement;
		}
		
		/* 
			BNF:
			<alter statement> ::=
				<alter table statement> |
				<alter view statement> |
				<alter constraint statement> |
				<alter reference statement> |
				<alter scalar type statement> |
				<alter operator statement> |
				<alter aggregate operator statement> |
				<alter device statement> |
				<alter server statement> |
				<alter sort statement> |
				<alter role statement>
		*/
		protected Statement AlterStatement()
		{
			_lexer.NextToken();
			int line = _lexer[0, false].Line;
			int linePos = _lexer[0, false].LinePos;
			switch (_lexer.NextToken().AsSymbol)
			{
				case Keywords.Table: return AlterTableStatement(line, linePos);
				case Keywords.View: return AlterViewStatement(line, linePos);
				case Keywords.Constraint: return AlterConstraintStatement(line, linePos);
				case Keywords.Reference: return AlterReferenceStatement(line, linePos);
				case Keywords.Type: return AlterScalarTypeStatement(line, linePos);
				case Keywords.Operator: return AlterOperatorStatement(line, linePos);
				case Keywords.Aggregate: return AlterAggregateOperatorStatement(line, linePos);
				case Keywords.Server: return AlterServerStatement(line, linePos);
				case Keywords.Device: return AlterDeviceStatement(line, linePos);
				case Keywords.Sort: return AlterSortStatement(line, linePos);
				case Keywords.Role: return AlterRoleStatement(line, linePos);
				default: throw new ParserException(ParserException.Codes.UnknownAlterDirective, _lexer[0].AsSymbol);
			}
		}
		
		/* 
			BNF:
			<alter table statement> ::=
				alter table <table name> 
					["{"<alter table definition item commalist>"}"]
					<alter metadata>
		*/
		protected Statement AlterTableStatement(int line, int linePos)
		{
			AlterTableStatement statement = new AlterTableStatement();
			statement.Line = line;
			statement.LinePos = linePos;
			statement.TableVarName = QualifiedIdentifier();
			if (_lexer.PeekTokenSymbol(1) == Keywords.BeginList)
			{
				_lexer.NextToken();
				bool done = false;
				do
				{
					AlterTableStatementItem(statement);
					switch (_lexer.NextToken().AsSymbol)
					{
						case Keywords.ListSeparator: break;
						case Keywords.EndList: done = true; break;
						default: throw new ParserException(ParserException.Codes.ListTerminatorExpected);
					}
				} while (!done);
			}
			AlterMetaData(statement, false);
			statement.SetEndPosition(_lexer);
			return statement;
		}

		/* 
			BNF:
			<alter table definition item> ::=
				<alter column definition> |
				<alter row constraint definition> |
				<alter key definition> |
				<alter reference definition> |
				<alter order definition>

			<alter row constraint definition> ::=
				(create <row constraint definition>) |
				(alter constraint <constraint name> [<expression>] <alter metadata>) |
				<alter transition constraint definition> |
				(drop [transition] constraint <constraint name>)
		*/        
		protected void AlterTableStatementItem(AlterTableStatement statement)
		{
			switch (_lexer.NextToken().AsSymbol)
			{
				case Keywords.Create: AlterTableCreateDefinition(statement); break;
				case Keywords.Alter: AlterTableAlterDefinition(statement); break;
				case Keywords.Drop: AlterTableDropDefinition(statement); break;
				default: throw new ParserException(ParserException.Codes.DDLDirectiveExpected);
			}
		}
		
		protected void AlterTableCreateDefinition(AlterTableStatement statement)
		{
			switch (_lexer.PeekTokenSymbol(1))
			{
				case Keywords.Column: 
					_lexer.NextToken();
					statement.CreateColumns.Add(ColumnDefinition());
				break;
				case Keywords.Transition:
				case Keywords.Constraint: statement.CreateConstraints.Add(RowConstraintDefinition()); break;
				case Keywords.Key: statement.CreateKeys.Add(KeyDefinition()); break;
				case Keywords.Reference: statement.CreateReferences.Add(ReferenceDefinition()); break;
				case Keywords.Order: statement.CreateOrders.Add(OrderDefinition()); break;
				default: throw new ParserException(ParserException.Codes.UnknownCreateDirective, _lexer[0].AsSymbol);
			}
		}
		
		protected void AlterTableAlterDefinition(AlterTableStatement statement)
		{
			switch (_lexer.PeekTokenSymbol(1))
			{
				case Keywords.Tags: AlterMetaData(statement, false); break;
				default:
					switch (_lexer.NextToken().AsSymbol)
					{
						case Keywords.Column: statement.AlterColumns.Add(AlterColumnDefinition()); break;
						case Keywords.Transition: statement.AlterConstraints.Add(AlterTransitionConstraintDefinition()); break;
						case Keywords.Constraint: statement.AlterConstraints.Add(AlterConstraintDefinition()); break;
						case Keywords.Key: statement.AlterKeys.Add(AlterKeyDefinition()); break;
						case Keywords.Reference: statement.AlterReferences.Add(AlterReferenceDefinition()); break;
						case Keywords.Order: statement.AlterOrders.Add(AlterOrderDefinition()); break;
						default: throw new ParserException(ParserException.Codes.UnknownAlterDirective, _lexer[0].AsSymbol);
					}
					break;
			}
		}
		
		protected void AlterTableDropDefinition(AlterTableStatement statement)
		{
			switch (_lexer.NextToken().AsSymbol)
			{
				case Keywords.Column: statement.DropColumns.Add(DropColumnDefinition()); break;
				case Keywords.Transition:
				case Keywords.Constraint: statement.DropConstraints.Add(DropConstraintDefinition(true)); break;
				case Keywords.Key: statement.DropKeys.Add(DropKeyDefinition()); break;
				case Keywords.Reference: statement.DropReferences.Add(DropReferenceDefinition()); break;
				case Keywords.Order: statement.DropOrders.Add(DropOrderDefinition()); break;
				default: throw new ParserException(ParserException.Codes.UnknownDropDirective, _lexer[0].AsSymbol);
			}
		}
		
		/* 
			BNF:
			<alter view statement> ::=
				alter view <view name> 
					["{"<alter view definition item commalist>"}"]
					<alter metadata>
		*/
		protected Statement AlterViewStatement(int line, int linePos)
		{
			AlterViewStatement statement = new AlterViewStatement();
			statement.Line = line;
			statement.LinePos = linePos;
			statement.TableVarName = QualifiedIdentifier();
			if (_lexer.PeekTokenSymbol(1) == Keywords.BeginList)
			{
				_lexer.NextToken();
				bool done = false;
				do
				{
					AlterViewStatementItem(statement);
					switch (_lexer.NextToken().AsSymbol)
					{
						case Keywords.ListSeparator: break;
						case Keywords.EndList: done = true; break;
						default: throw new ParserException(ParserException.Codes.ListTerminatorExpected);
					}
				} while (!done);
			}
			AlterMetaData(statement, false);
			statement.SetEndPosition(_lexer);
			return statement;
		}
		
		/*			 
			BNF:
			<alter view definition item> ::=
				<alter row constraint definition> |
				<alter key definition> |
				<alter reference definition> |
				<alter order definition>
		*/
		protected void AlterViewStatementItem(AlterViewStatement statement)
		{
			switch (_lexer.NextToken().AsSymbol)
			{
				case Keywords.Create: AlterViewCreateDefinition(statement); break;
				case Keywords.Alter: AlterViewAlterDefinition(statement); break;
				case Keywords.Drop: AlterViewDropDefinition(statement); break;
				default: throw new ParserException(ParserException.Codes.DDLDirectiveExpected);
			}
		}
		
		protected void AlterViewCreateDefinition(AlterViewStatement statement)
		{
			switch (_lexer.PeekTokenSymbol(1))
			{
				case Keywords.Transition:
				case Keywords.Constraint: statement.CreateConstraints.Add(RowConstraintDefinition()); break;
				case Keywords.Key: statement.CreateKeys.Add(KeyDefinition()); break;
				case Keywords.Reference: statement.CreateReferences.Add(ReferenceDefinition()); break;
				case Keywords.Order: statement.CreateOrders.Add(OrderDefinition()); break;
				default: throw new ParserException(ParserException.Codes.UnknownCreateDirective, _lexer[0].AsSymbol);
			}
		}
		
		protected void AlterViewAlterDefinition(AlterViewStatement statement)
		{
			switch (_lexer.NextToken().AsSymbol)
			{
				case Keywords.Transition: statement.AlterConstraints.Add(AlterTransitionConstraintDefinition()); break;
				case Keywords.Constraint: statement.AlterConstraints.Add(AlterConstraintDefinition()); break;
				case Keywords.Key: statement.AlterKeys.Add(AlterKeyDefinition()); break;
				case Keywords.Reference: statement.AlterReferences.Add(AlterReferenceDefinition()); break;
				case Keywords.Order: statement.AlterOrders.Add(AlterOrderDefinition()); break;
				default: throw new ParserException(ParserException.Codes.UnknownAlterDirective, _lexer[0].AsSymbol);
			}
		}
		
		protected void AlterViewDropDefinition(AlterViewStatement statement)
		{
			switch (_lexer.NextToken().AsSymbol)
			{
				case Keywords.Transition:
				case Keywords.Constraint: statement.DropConstraints.Add(DropConstraintDefinition(true)); break;
				case Keywords.Key: statement.DropKeys.Add(DropKeyDefinition()); break;
				case Keywords.Reference: statement.DropReferences.Add(DropReferenceDefinition()); break;
				case Keywords.Order: statement.DropOrders.Add(DropOrderDefinition()); break;
				default: throw new ParserException(ParserException.Codes.UnknownDropDirective, _lexer[0].AsSymbol);
			}
		}
		
		/* 
			BNF:
			<alter column definition> ::=
				create column <column definition> |
				alter column <column name> 
					[: <type specifier>] 
					<alter nilable definition>
					["{"<ne alter column definition item>"}"] 
					<alter metadata> |
				drop column <column name>
			
			<alter column definition item> ::=
				<alter default definition> |
				<alter constraint definition> |
				<alter nilable definition>
				
			<alter nilable definition> ::=
				[[not] nil]
		*/
		protected Statement AlterColumnDefinition()
		{
			AlterColumnDefinition definition = new AlterColumnDefinition();
			definition.SetPosition(_lexer);
			definition.ColumnName = QualifiedIdentifier();
			if (_lexer.PeekTokenSymbol(1) == Keywords.TypeSpecifier)
			{
				_lexer.NextToken();
				definition.TypeSpecifier = TypeSpecifier();
			}
			
			if (_lexer.PeekTokenSymbol(1) == Keywords.Not)
			{
				_lexer.NextToken();
				_lexer.NextToken().CheckType(TokenType.Nil);
				definition.ChangeNilable = true;
				definition.IsNilable = false;
			}
			else if (_lexer[1].Type == TokenType.Nil)
			{
				_lexer.NextToken();
				definition.ChangeNilable = true;
				definition.IsNilable = true;
			}
			
			if (_lexer.PeekTokenSymbol(1) == Keywords.BeginList)
			{
				_lexer.NextToken();
				bool done = false;
				do
				{
					_lexer.NextToken();
					if (_lexer[0].Type == TokenType.Nil)
					{
						definition.ChangeNilable = true;
						definition.IsNilable = true;
					}
					else
					{
						switch (_lexer[0].AsSymbol)
						{
							case Keywords.Not:
								_lexer.NextToken().CheckType(TokenType.Nil);
								definition.ChangeNilable = true;
								definition.IsNilable = false;
							break;
							
							case Keywords.Create:
								switch (_lexer.PeekTokenSymbol(1))
								{
									case Keywords.Default: 
										if (definition.Default != null)
											throw new ParserException(ParserException.Codes.DefaultDefinitionExists);
										definition.Default = DefaultDefinition();
									break;

									case Keywords.Constraint: 
										definition.CreateConstraints.Add(ConstraintDefinition()); 
									break;
									
									default: throw new ParserException(ParserException.Codes.UnknownCreateDirective, _lexer.PeekTokenSymbol(1));
								}
							break;
							
							case Keywords.Alter:
								switch (_lexer.NextToken().AsSymbol)
								{
									case Keywords.Default: 
										if (definition.Default != null)
											throw new ParserException(ParserException.Codes.DefaultDefinitionExists);
										definition.Default = AlterDefaultDefinition(); 
									break;
									case Keywords.Constraint: definition.AlterConstraints.Add(AlterConstraintDefinition()); break;
									default: throw new ParserException(ParserException.Codes.UnknownAlterDirective, _lexer[0].AsSymbol);
								}
							break;
							
							case Keywords.Drop:
								switch (_lexer.NextToken().AsSymbol)
								{
									case Keywords.Default: 
										if (definition.Default != null)
											throw new ParserException(ParserException.Codes.DefaultDefinitionExists);
										definition.Default = DropDefaultDefinition(); 
									break;
									case Keywords.Constraint: definition.DropConstraints.Add(DropConstraintDefinition()); break;
									default: throw new ParserException(ParserException.Codes.UnknownDropDirective, _lexer[0].AsSymbol);
								}
							break;
							
							default: throw new ParserException(ParserException.Codes.DDLDirectiveExpected);
						}
					}
					
					switch (_lexer.NextToken().AsSymbol)
					{
						case Keywords.ListSeparator: break;
						case Keywords.EndList: done = true; break;
						default: throw new ParserException(ParserException.Codes.ListTerminatorExpected);
					}
				} while (!done);
			}
			
			AlterMetaData(definition, false);
			definition.SetEndPosition(_lexer);
			return definition;
		}
		
		protected Statement DropColumnDefinition()
		{
			DropColumnDefinition definition = new DropColumnDefinition();
			definition.SetPosition(_lexer);
			definition.ColumnName = QualifiedIdentifier();
			definition.SetEndPosition(_lexer);
			return definition;
		}
		
		/* 
			BNF:
			<alter constraint statement> ::=
				alter constraint <constraint name> [<expression>] <alter metadata>
		*/
		protected Statement AlterConstraintStatement(int line, int linePos)
		{
			AlterConstraintStatement statement = new AlterConstraintStatement();
			statement.Line = line;
			statement.LinePos = linePos;
			statement.ConstraintName = QualifiedIdentifier();
			if (_lexer.PeekTokenSymbol(1) != Keywords.Alter)
				statement.Expression = Expression();
			AlterMetaData(statement, false);
			statement.SetEndPosition(_lexer);
			return statement;
		}
		
		/* 
			BNF:
			<alter constraint definition> ::=
				(create <constraint definition>) |
				(alter constraint <constraint name> [<expression>] <alter metadata>) |
				(drop constraint <constraint name>)
		*/
		protected Statement AlterConstraintDefinition()
		{
			AlterConstraintDefinition definition = new AlterConstraintDefinition();
			definition.SetPosition(_lexer);
			definition.ConstraintName = QualifiedIdentifier();
			if (_lexer.PeekTokenSymbol(1) != Keywords.Alter)
				definition.Expression = Expression();
			AlterMetaData(definition, false);
			definition.SetEndPosition(_lexer);
			return definition;
		}
		
		/*
			BNF:
			<alter transition constraint definition> ::=
				alter transition constraint <constraint name>
					[<alter transition constraint definition item>]
					[<alter transition constraint definition item>]
					[<alter transition constraint definition item>]
					<alter metadata>
					
			<alter transition constraint definition item> ::=
				(create on <transition> <expression>) |
				(alter on <transition> <expression>) |
				(drop on <transition>)
				
			<transition> ::=
				insert | update | delete
		*/        
		protected Statement AlterTransitionConstraintDefinition()
		{
			AlterTransitionConstraintDefinition definition = new AlterTransitionConstraintDefinition();
			definition.SetPosition(_lexer);
			_lexer.NextToken();
			definition.ConstraintName = QualifiedIdentifier();
			AlterTransitionConstraintDefinitionItem(definition);
			AlterTransitionConstraintDefinitionItem(definition);
			AlterTransitionConstraintDefinitionItem(definition);
			AlterMetaData(definition, (_lexer[0].Type == TokenType.Symbol) && (_lexer[0].AsSymbol == Keywords.Alter));
			definition.SetEndPosition(_lexer);
			return definition;
		}
		
		protected void AlterTransitionConstraintDefinitionItem(AlterTransitionConstraintDefinition definition)
		{
			switch (_lexer.PeekTokenSymbol(1))
			{
				case Keywords.Create : 
					_lexer.NextToken();
					if (_lexer.PeekTokenSymbol(1) == Keywords.On)
					{
						_lexer.NextToken();
						switch (_lexer.NextToken().AsSymbol)
						{
							case Keywords.Insert : definition.OnInsert = new AlterTransitionConstraintDefinitionCreateItem(Expression()); break;
							case Keywords.Update : definition.OnUpdate = new AlterTransitionConstraintDefinitionCreateItem(Expression()); break;
							case Keywords.Delete : definition.OnDelete = new AlterTransitionConstraintDefinitionCreateItem(Expression()); break;
							default : throw new ParserException(ParserException.Codes.UnknownConstraintTarget);
						}
					}
					break;
					
				case Keywords.Alter :
					_lexer.NextToken();
					if (_lexer.PeekTokenSymbol(1) == Keywords.On)
					{
						_lexer.NextToken();
						switch (_lexer.NextToken().AsSymbol)
						{
							case Keywords.Insert : definition.OnInsert = new AlterTransitionConstraintDefinitionAlterItem(Expression()); break;
							case Keywords.Update : definition.OnUpdate = new AlterTransitionConstraintDefinitionAlterItem(Expression()); break;
							case Keywords.Delete : definition.OnDelete = new AlterTransitionConstraintDefinitionAlterItem(Expression()); break;
							default : throw new ParserException(ParserException.Codes.UnknownConstraintTarget);
						}
					}
					break;

				case Keywords.Drop :
					_lexer.NextToken();
					if (_lexer.PeekTokenSymbol(1) == Keywords.On)
					{
						_lexer.NextToken();
						switch (_lexer.NextToken().AsSymbol)
						{
							case Keywords.Insert : definition.OnInsert = new AlterTransitionConstraintDefinitionDropItem(); break;
							case Keywords.Update : definition.OnUpdate = new AlterTransitionConstraintDefinitionDropItem(); break;
							case Keywords.Delete : definition.OnDelete = new AlterTransitionConstraintDefinitionDropItem(); break;
							default : throw new ParserException(ParserException.Codes.UnknownConstraintTarget);
						}
					}
					break;
			}
		}
		
		protected Statement DropConstraintDefinition(bool transitionContext)
		{
			DropConstraintDefinition definition = new DropConstraintDefinition();
			definition.SetPosition(_lexer);
			if ((transitionContext) && (_lexer[0].AsSymbol == Keywords.Transition))
			{
				_lexer.NextToken();
				definition.IsTransition = true;
			}
			definition.ConstraintName = QualifiedIdentifier();
			definition.SetEndPosition(_lexer);
			return definition;
		}
		
		protected Statement DropConstraintDefinition()
		{
			return DropConstraintDefinition(false);
		}

		/* 
			BNF:
			<alter key definition> ::=
				(create <key definition>) |
				(alter key "{"<column name commalist>"}" <alter metadata>) |
				(drop key "{"<column name commalist>"}")
		*/        
		protected Statement AlterKeyDefinition()
		{
			AlterKeyDefinition definition = new AlterKeyDefinition();
			definition.SetPosition(_lexer);
			KeyColumnList(definition.Columns);
			AlterMetaData(definition, false);
			definition.SetEndPosition(_lexer);
			return definition;
		}
		
		protected Statement DropKeyDefinition()
		{
			DropKeyDefinition definition = new DropKeyDefinition();
			definition.SetPosition(_lexer);
			KeyColumnList(definition.Columns);
			definition.SetEndPosition(_lexer);
			return definition;
		}
		
		/* 
			BNF:
			<alter reference statement> ::=
				alter reference <reference name> <alter metadata>
		*/
		protected Statement AlterReferenceStatement(int line, int linePos)
		{
			AlterReferenceStatement statement = new AlterReferenceStatement();
			statement.Line = line;
			statement.LinePos = linePos;
			statement.ReferenceName = QualifiedIdentifier();
			AlterMetaData(statement, false);
			statement.SetEndPosition(_lexer);
			return statement;
		}

		/* 
			BNF:
			<alter reference definition> ::=
				(create <reference definition>) |
				(alter reference <reference name> <alter metadata>) |
				(drop <reference name>)
		*/        
		protected Statement AlterReferenceDefinition()
		{
			AlterReferenceDefinition definition = new AlterReferenceDefinition();
			definition.SetPosition(_lexer);
			definition.ReferenceName = QualifiedIdentifier();
			AlterMetaData(definition, false);
			definition.SetEndPosition(_lexer);
			return definition;
		}
		
		protected Statement DropReferenceDefinition()
		{
			DropReferenceDefinition definition = new DropReferenceDefinition();
			definition.SetPosition(_lexer);
			definition.ReferenceName = QualifiedIdentifier();
			definition.SetEndPosition(_lexer);
			return definition;
		}

		/* 
			BNF:
			<alter order definition> ::=
				(create <order definition>) |
				(alter order "{"<order column definition commalist>"}" <alter metadata>) |
				(drop order "{"<order column definition commalist>"}")
		*/        
		protected Statement AlterOrderDefinition()
		{
			AlterOrderDefinition definition = new AlterOrderDefinition();
			definition.SetPosition(_lexer);
			OrderColumnDefinitionList(definition.Columns);
			AlterMetaData(definition, false);
			definition.SetEndPosition(_lexer);
			return definition;
		}
		
		protected Statement DropOrderDefinition()
		{
			DropOrderDefinition definition = new DropOrderDefinition();
			definition.SetPosition(_lexer);
			OrderColumnDefinitionList(definition.Columns);
			definition.SetEndPosition(_lexer);
			return definition;
		}
		
		/* 
			BNF:
			<alter scalar type statement> ::=
				alter type <scalar type name> 
					["{"<alter scalar type definition item commalist>"}"]
					<alter class definition>
					<alter metadata>
		*/
		protected Statement AlterScalarTypeStatement(int line, int linePos)
		{
			AlterScalarTypeStatement statement = new AlterScalarTypeStatement();
			statement.Line = line;
			statement.LinePos = linePos;
			statement.ScalarTypeName = QualifiedIdentifier();
			if (_lexer.PeekTokenSymbol(1) == Keywords.BeginList)
			{
				_lexer.NextToken();
				bool done = false;
				do
				{
					AlterScalarTypeStatementItem(statement);
					switch (_lexer.NextToken().AsSymbol)
					{
						case Keywords.ListSeparator: break;
						case Keywords.EndList: done = true; break;
						default: throw new ParserException(ParserException.Codes.ListTerminatorExpected);
					}
				} while (!done);
			}

			if (_lexer.PeekTokenSymbol(1) == Keywords.Alter)
			{
				_lexer.NextToken();
				switch (_lexer.PeekTokenSymbol(1))
				{
					case Keywords.Class: 
						statement.AlterClassDefinition = AlterClassDefinition(); 
						AlterMetaData(statement, false);
					break;
					
					case Keywords.Tags: AlterMetaData(statement, true); break;
					default: throw new ParserException(ParserException.Codes.UnknownAlterDirective, _lexer.PeekTokenSymbol(1));
				}
			}
				
			statement.SetEndPosition(_lexer);
			return statement;
		}
		
		/* 
			BNF:
			<alter scalar type definition item> ::=
				<alter representation definition> |
				<alter constraint definition> |
				<alter default definition> |
				<alter special definition>
		*/
		protected void AlterScalarTypeStatementItem(AlterScalarTypeStatement statement)
		{
			switch (_lexer.NextToken().AsSymbol)
			{
				case Keywords.Create: AlterScalarTypeCreateDefinition(statement); break;
				case Keywords.Alter: AlterScalarTypeAlterDefinition(statement); break;
				case Keywords.Drop: AlterScalarTypeDropDefinition(statement); break;
				default: throw new ParserException(ParserException.Codes.DDLDirectiveExpected);
			}
		}
		
		protected void AlterScalarTypeCreateDefinition(AlterScalarTypeStatement statement)
		{
			switch (_lexer.PeekTokenSymbol(1))
			{
				case Keywords.Representation: statement.CreateRepresentations.Add(RepresentationDefinition()); break;
				case Keywords.Constraint: statement.CreateConstraints.Add(ConstraintDefinition()); break;
				case Keywords.Default:
					if (statement.Default != null)
						throw new ParserException(ParserException.Codes.DefaultDefinitionExists);
					statement.Default = DefaultDefinition();
				break;
				case Keywords.Special: statement.CreateSpecials.Add(SpecialDefinition()); break;
				default: throw new ParserException(ParserException.Codes.UnknownCreateDirective, _lexer[0].AsSymbol);
			}
		}
		
		protected void AlterScalarTypeAlterDefinition(AlterScalarTypeStatement statement)
		{
			switch (_lexer.NextToken().AsSymbol)
			{
				case Keywords.Representation: statement.AlterRepresentations.Add(AlterRepresentationDefinition()); break;
				case Keywords.Constraint: statement.AlterConstraints.Add(AlterConstraintDefinition()); break;
				case Keywords.Default:
					if (statement.Default != null)
						throw new ParserException(ParserException.Codes.DefaultDefinitionExists);
					statement.Default = AlterDefaultDefinition();
				break;
				case Keywords.Special: statement.AlterSpecials.Add(AlterSpecialDefinition()); break;
				default: throw new ParserException(ParserException.Codes.UnknownAlterDirective, _lexer[0].AsSymbol);
			}
		}
		
		protected void AlterScalarTypeDropDefinition(AlterScalarTypeStatement statement)
		{
			switch (_lexer.NextToken().AsSymbol)
			{
				case Keywords.Representation: statement.DropRepresentations.Add(DropRepresentationDefinition()); break;
				case Keywords.Constraint: statement.DropConstraints.Add(DropConstraintDefinition()); break;
				case Keywords.Default:
					if (statement.Default != null)
						throw new ParserException(ParserException.Codes.DefaultDefinitionExists);
					statement.Default = DropDefaultDefinition();
				break;
				case Keywords.Special: statement.DropSpecials.Add(DropSpecialDefinition()); break;
				default: throw new ParserException(ParserException.Codes.UnknownDropDirective, _lexer[0].AsSymbol);
			}
		}
		
		/* 
			BNF:
			<alter representation definition> ::=
				(create <representation definition>) |
				(
					alter representation 
						<representation name> 
						["{"<ne alter property definition commalist>"}"] 
						[alter selector <alter accessor block>]
						<alter metadata>
				) |
				(drop representation <representation name>)
				
			<alter accessor block> ::=
				<alter class definition> | <expression> | <block>
		*/        
		protected Statement AlterRepresentationDefinition()
		{
			AlterRepresentationDefinition definition = new AlterRepresentationDefinition();
			definition.SetPosition(_lexer);
			definition.RepresentationName = QualifiedIdentifier();
			if (_lexer.PeekTokenSymbol(1) == Keywords.BeginList)
			{
				_lexer.NextToken();
				bool done = false;
				do
				{
					switch (_lexer.NextToken().AsSymbol)
					{
						case Keywords.Create: definition.CreateProperties.Add(PropertyDefinition()); break;
						case Keywords.Alter: definition.AlterProperties.Add(AlterPropertyDefinition()); break;
						case Keywords.Drop: definition.DropProperties.Add(DropPropertyDefinition()); break;
						default: throw new ParserException(ParserException.Codes.DDLDirectiveExpected);
					}
					
					switch (_lexer.NextToken().AsSymbol)
					{
						case Keywords.ListSeparator: break;
						case Keywords.EndList: done = true; break;
						default: throw new ParserException(ParserException.Codes.ListTerminatorExpected);
					}
				} while (!done);
			}
			
			if (_lexer.PeekTokenSymbol(1) == Keywords.Alter)
			{
				_lexer.NextToken();
				switch (_lexer.PeekTokenSymbol(1))
				{
					case Keywords.Selector:
						_lexer.NextToken();
						definition.SelectorAccessorBlock = new AlterAccessorBlock();
						AlterAccessorBlock(definition.SelectorAccessorBlock); 
						AlterMetaData(definition, false);
					break;
					
					case Keywords.Tags: AlterMetaData(definition, true); break;
					default: throw new ParserException(ParserException.Codes.UnknownAlterDirective, _lexer.PeekTokenSymbol(1));
				}
			}
				
			definition.SetEndPosition(_lexer);
			return definition;
		}
		
		protected void AlterAccessorBlock(AlterAccessorBlock accessorBlock)
		{
			switch (_lexer.PeekTokenSymbol(1))
			{
				case Keywords.Alter :
					_lexer.NextToken(); 
					accessorBlock.AlterClassDefinition = AlterClassDefinition();
				break;
				
				case Keywords.Begin :
					_lexer.NextToken();
					accessorBlock.Block = Block();
					_lexer.NextToken().CheckSymbol(Keywords.End);
				break;
				
				default : accessorBlock.Expression = Expression(); break;
			}
		}
		
		protected Statement DropRepresentationDefinition()
		{
			DropRepresentationDefinition definition = new DropRepresentationDefinition();
			definition.SetPosition(_lexer);
			definition.RepresentationName = QualifiedIdentifier();
			definition.SetEndPosition(_lexer);
			return definition;
		}
		
		/* 
			BNF:
			<alter property definition> ::=
				(create <property definition>) |
				(
					alter <property name>
						[: <type specifier>]
						[alter read <alter accessor block>]
						[alter write <alter accessor block>]
						<alter metadata>
				) |
				(drop <property name>)
		*/
		protected Statement AlterPropertyDefinition()
		{
			int line = _lexer[0, false].Line;
			int linePos = _lexer[0, false].LinePos;
			AlterPropertyDefinition definition = new AlterPropertyDefinition(QualifiedIdentifier());
			definition.Line = line;
			definition.LinePos = linePos;
			if (_lexer.PeekTokenSymbol(1) == Keywords.TypeSpecifier)
			{
				_lexer.NextToken();
				definition.PropertyType = TypeSpecifier();
			}
			
			if (_lexer.PeekTokenSymbol(1) == Keywords.Alter)
			{
				_lexer.NextToken();
				_lexer.NextToken().CheckSymbol(Keywords.Read);
				definition.ReadAccessorBlock = new AlterAccessorBlock();
				AlterAccessorBlock(definition.ReadAccessorBlock);
			}
			
			if (_lexer.PeekTokenSymbol(1) == Keywords.Alter)
			{
				_lexer.NextToken();
				_lexer.NextToken().CheckSymbol(Keywords.Write);
				definition.WriteAccessorBlock = new AlterAccessorBlock();
				AlterAccessorBlock(definition.WriteAccessorBlock);
			}
			
			AlterMetaData(definition, false);
			definition.SetEndPosition(_lexer);
			return definition;
		}
		
		protected Statement DropPropertyDefinition()
		{
			DropPropertyDefinition definition = new DropPropertyDefinition();
			definition.SetPosition(_lexer);
			definition.PropertyName = QualifiedIdentifier();
			definition.SetEndPosition(_lexer);
			return definition;
		}

		/* 
			BNF:
			<alter special definition> ::=
				(create <special definition>) |
				(alter special <special name> [<expression>] <alter metadata>) |
				(drop special <special name>)
		*/        
		protected Statement AlterSpecialDefinition()
		{
			AlterSpecialDefinition definition = new AlterSpecialDefinition();
			definition.SetPosition(_lexer);
			definition.Name = QualifiedIdentifier();
			if (_lexer.PeekTokenSymbol(1) != Keywords.Alter)
				definition.Value = Expression();
			AlterMetaData(definition, false);
			definition.SetEndPosition(_lexer);
			return definition;
		}
		
		protected Statement DropSpecialDefinition()
		{
			DropSpecialDefinition definition = new DropSpecialDefinition();
			definition.SetPosition(_lexer);
			definition.Name = QualifiedIdentifier();
			definition.SetEndPosition(_lexer);
			return definition;
		}
		
		/* 
			BNF:
			<alter default definition> ::=
				(create <default definition>) |
				(alter default [<expression>] <alter metadata>) |
				(drop default)
		*/
		protected AlterDefaultDefinition AlterDefaultDefinition()
		{
			AlterDefaultDefinition definition = new AlterDefaultDefinition();
			definition.SetPosition(_lexer);
			if (_lexer.PeekTokenSymbol(1) != Keywords.Alter)
				definition.Expression = Expression();
			AlterMetaData(definition, false);
			definition.SetEndPosition(_lexer);
			return definition;
		}
		
		protected DropDefaultDefinition DropDefaultDefinition()
		{
			DropDefaultDefinition definition = new DropDefaultDefinition();
			definition.SetPosition(_lexer);
			definition.SetEndPosition(_lexer);
			return definition;
		}
		
		/* 
			BNF:
			<alter operator statement> ::=
				alter operator <operator name>"("<formal parameter specifier commalist>")"
					[(<alter class definition> | <block>)]
					<alter metadata>
		*/        
		protected Statement AlterOperatorStatement(int line, int linePos)
		{
			AlterOperatorStatement statement = new AlterOperatorStatement();
			statement.Line = line;
			statement.LinePos = linePos;
			statement.OperatorSpecifier = OperatorSpecifier();
			
			if (_lexer.PeekTokenSymbol(1) == Keywords.Alter)
			{
				_lexer.NextToken();
				if (_lexer.PeekTokenSymbol(1) == Keywords.Class)
				{
					statement.Block.SetPosition(_lexer);
					statement.Block.AlterClassDefinition = AlterClassDefinition();
					statement.Block.SetEndPosition(_lexer);
					AlterMetaData(statement, false);
				}
				else
					AlterMetaData(statement, true);
			}
			else
			{
				_lexer.NextToken().CheckSymbol(Keywords.Begin);
				statement.Block.SetPosition(_lexer);
				statement.Block.Block = Block();
				_lexer.NextToken().CheckSymbol(Keywords.End);
				statement.Block.SetEndPosition(_lexer);
				AlterMetaData(statement, false);
			}

			statement.SetEndPosition(_lexer);
			return statement;
		}

		/* 
			BNF:
			<alter aggregate operator statement> ::=
				alter aggregate operator <operator name>"("<formal parameter specifier commalist>")"
					[initialization (<alter class definition> | <block>)]
					[aggregation (<alter class definition> | <block>)]
					[finalization (<alter class definition> | <block>)]
					<alter metadata>
		*/        
		protected Statement AlterAggregateOperatorStatement(int line, int linePos)
		{
			AlterAggregateOperatorStatement statement = new AlterAggregateOperatorStatement();
			statement.Line = line;
			statement.LinePos = linePos;
			_lexer.NextToken().CheckSymbol(Keywords.Operator);
			statement.OperatorSpecifier = OperatorSpecifier();
			
			if (_lexer.PeekTokenSymbol(1) == Keywords.Initialization)
			{
				_lexer.NextToken();
				if (_lexer.PeekTokenSymbol(1) == Keywords.Alter)
				{
					statement.Initialization.SetPosition(_lexer);
					statement.Initialization.AlterClassDefinition = AlterClassDefinition();
					statement.Initialization.SetEndPosition(_lexer);
				}
				else
				{
					_lexer.NextToken().CheckSymbol(Keywords.Begin);
					statement.Initialization.SetPosition(_lexer);
					statement.Initialization.Block = Block();
					_lexer.NextToken().CheckSymbol(Keywords.End);
					statement.Initialization.SetEndPosition(_lexer);
				}
			}
			
			if (_lexer.PeekTokenSymbol(1) == Keywords.Aggregation)
			{
				_lexer.NextToken();
				if (_lexer.PeekTokenSymbol(1) == Keywords.Alter)
				{
					statement.Aggregation.SetPosition(_lexer);
					statement.Aggregation.AlterClassDefinition = AlterClassDefinition();
					statement.Aggregation.SetEndPosition(_lexer);
				}
				else
				{
					_lexer.NextToken().CheckSymbol(Keywords.Begin);
					statement.Aggregation.SetPosition(_lexer);
					statement.Aggregation.Block = Block();
					_lexer.NextToken().CheckSymbol(Keywords.End);
					statement.Aggregation.SetEndPosition(_lexer);
				}
			}
			
			if (_lexer.PeekTokenSymbol(1) == Keywords.Finalization)
			{
				_lexer.NextToken();
				if (_lexer.PeekTokenSymbol(1) == Keywords.Alter)
				{
					statement.Finalization.SetPosition(_lexer);
					statement.Finalization.AlterClassDefinition = AlterClassDefinition();
					statement.Finalization.SetEndPosition(_lexer);
				}
				else
				{
					_lexer.NextToken().CheckSymbol(Keywords.Begin);
					statement.Finalization.SetPosition(_lexer);
					statement.Finalization.Block = Block();
					_lexer.NextToken().CheckSymbol(Keywords.End);
					statement.Finalization.SetEndPosition(_lexer);
				}
			}
			
			AlterMetaData(statement, false);
			statement.SetEndPosition(_lexer);
			return statement;
		}

		/* 
			BNF:
			<alter server link statement> ::=
				alter server <server link name> <alter metadata>
		*/        
		protected Statement AlterServerStatement(int line, int linePos)
		{
			AlterServerStatement statement = new AlterServerStatement();
			statement.Line = line;
			statement.LinePos = linePos;
			statement.ServerName = QualifiedIdentifier();
			AlterMetaData(statement, false);
			statement.SetEndPosition(_lexer);
			return statement;
		}
		
		/* 
			BNF:
			<alter device statement> ::=
				alter device <device name> 
					["{"<alter device map item commalist>"}"]
					<alter reconciliation settings>
					<alter class definition> 
					<alter metadata>

			<alter reconciliation settings> ::=
				[alter reconciliation "{"<reconciliation settings item commalist>"}"]
		*/
		protected Statement AlterDeviceStatement(int line, int linePos)
		{
			AlterDeviceStatement statement = new AlterDeviceStatement();
			statement.Line = line;
			statement.LinePos = linePos;
			statement.DeviceName = QualifiedIdentifier();
			
			if (_lexer.PeekTokenSymbol(1) == Keywords.BeginList)
			{
				_lexer.NextToken();
				bool done = false;
				do
				{
					AlterDeviceStatementItem(statement);
					switch (_lexer.NextToken().AsSymbol)
					{
						case Keywords.ListSeparator: break;
						case Keywords.EndList: done = true; break;
						default: throw new ParserException(ParserException.Codes.ListTerminatorExpected);
					}
				} while (!done);
			}

			if (_lexer.PeekTokenSymbol(1) == Keywords.Alter)
			{
				_lexer.NextToken();
				switch (_lexer.PeekTokenSymbol(1))
				{
					case Keywords.Reconciliation:
						statement.ReconciliationSettings = ReconciliationSettings();
						if (_lexer.PeekTokenSymbol(1) == Keywords.Alter)
						{
							_lexer.NextToken();
							switch (_lexer.PeekTokenSymbol(1))
							{
								case Keywords.Class:
									statement.AlterClassDefinition = AlterClassDefinition();
									AlterMetaData(statement, false);
								break;
								
								case Keywords.Tags: AlterMetaData(statement, true); break;
								default: throw new ParserException(ParserException.Codes.UnknownAlterDirective, _lexer.PeekTokenSymbol(1));
							}
						}
					break;
					
					case Keywords.Class: 
						statement.AlterClassDefinition = AlterClassDefinition(); 
						AlterMetaData(statement, false);
					break;
					
					case Keywords.Tags: AlterMetaData(statement, true); break;
					default: throw new ParserException(ParserException.Codes.UnknownAlterDirective, _lexer.PeekTokenSymbol(1));
				}
			}
				
			statement.SetEndPosition(_lexer);
			return statement;
		}
		
		/* 
			BNF:
			<alter device map item> ::=
				<alter device scalar type map> |
				<alter device operator map> |
				<alter device store definition>
				
			<alter device scalar type map> ::=
				(create <device scalar type map>) | 
				(alter type <scalar type name> [<alter class definition>] <alter metadata>) | 
				(drop type <scalar type name>)
				
			<alter device operator map> ::=
				(create <device operator map>) |
				(alter operator <operator specifier> [<alter class definition>] <alter metadata>) |
				(drop operator <operator specifier>)
				
			<alter device store definition> ::=
				(create <device store definition>) |
				(alter store <store name> 
					[<expression>] 
					[alter by (default | ("{"<index column definition commalist>"}" <metadata>))] 
					[alter indexes (default | "{"<alter index definition commalist>"}")] 
					<alter metadata>) |
				(drop store <store name>)
				
			<alter index definition> ::=
				(create <index definition>) |
				(alter index "{"<index definition commalist>"}" <alter metadata>) |
				(drop index "{"<index definition commalist>"}")
		*/
		protected void AlterDeviceStatementItem(AlterDeviceStatement statement)
		{
			switch (_lexer.NextToken().AsSymbol)
			{
				case Keywords.Create: AlterDeviceCreateItem(statement); break;
				case Keywords.Alter: AlterDeviceAlterItem(statement); break;
				case Keywords.Drop: AlterDeviceDropItem(statement); break;
				default: throw new ParserException(ParserException.Codes.DDLDirectiveExpected);
			}
		}
		
		protected void AlterDeviceCreateItem(AlterDeviceStatement statement)
		{
			switch (_lexer.NextToken().AsSymbol)
			{
				case Keywords.Type: statement.CreateDeviceScalarTypeMaps.Add(DeviceScalarTypeMap()); break;
				case Keywords.Operator: statement.CreateDeviceOperatorMaps.Add(DeviceOperatorMap()); break;
				case Keywords.Store: statement.CreateDeviceStoreDefinitions.Add(DeviceStoreDefinition()); break;
				default: throw new ParserException(ParserException.Codes.UnknownCreateDirective, _lexer[0].AsSymbol);
			}
		}
		
		protected void AlterDeviceAlterItem(AlterDeviceStatement statement)
		{
			switch (_lexer.PeekTokenSymbol(1))
			{
				case Keywords.Type: statement.AlterDeviceScalarTypeMaps.Add(AlterDeviceScalarTypeMap()); break;
				case Keywords.Operator: statement.AlterDeviceOperatorMaps.Add(AlterDeviceOperatorMap()); break;
				case Keywords.Store: statement.AlterDeviceStoreDefinitions.Add(AlterDeviceStoreDefinition()); break;
				default: throw new ParserException(ParserException.Codes.UnknownAlterDirective, _lexer[0].AsSymbol);
			}
		}
		
		protected AlterDeviceScalarTypeMap AlterDeviceScalarTypeMap()
		{
			AlterDeviceScalarTypeMap alterDeviceScalarTypeMap = new AlterDeviceScalarTypeMap();
			alterDeviceScalarTypeMap.SetPosition(_lexer);
			_lexer.NextToken().CheckSymbol(Keywords.Type);
			alterDeviceScalarTypeMap.ScalarTypeName = QualifiedIdentifier();
			_lexer.NextToken().CheckSymbol(Keywords.Alter);
			if (_lexer.PeekTokenSymbol(1) == Keywords.Class)
			{
				alterDeviceScalarTypeMap.AlterClassDefinition = AlterClassDefinition();
				AlterMetaData(alterDeviceScalarTypeMap, false);
			}
			else
				AlterMetaData(alterDeviceScalarTypeMap, true);
			alterDeviceScalarTypeMap.SetEndPosition(_lexer);
			return alterDeviceScalarTypeMap;
		}
		
		protected AlterDeviceOperatorMap AlterDeviceOperatorMap()
		{
			AlterDeviceOperatorMap alterDeviceOperatorMap = new AlterDeviceOperatorMap();
			alterDeviceOperatorMap.SetPosition(_lexer);
			_lexer.NextToken().CheckSymbol(Keywords.Operator);
			alterDeviceOperatorMap.OperatorSpecifier = OperatorSpecifier();
			_lexer.NextToken().CheckSymbol(Keywords.Alter);
			if (_lexer.PeekTokenSymbol(1) == Keywords.Class)
			{
				alterDeviceOperatorMap.AlterClassDefinition = AlterClassDefinition();
				AlterMetaData(alterDeviceOperatorMap, false);
			}
			else
				AlterMetaData(alterDeviceOperatorMap, true);
			alterDeviceOperatorMap.SetEndPosition(_lexer);
			return alterDeviceOperatorMap;
		}
		
		protected AlterDeviceStoreDefinition AlterDeviceStoreDefinition()
		{
			AlterDeviceStoreDefinition definition = new AlterDeviceStoreDefinition();
			definition.SetPosition(_lexer);
			_lexer.NextToken().CheckSymbol(Keywords.Store);
			definition.StoreName = QualifiedIdentifier();
			if (_lexer.PeekTokenSymbol(1) != Keywords.Alter)
				definition.Expression = Expression();
			_lexer.NextToken().CheckSymbol(Keywords.Alter);
			switch (_lexer.PeekTokenSymbol(1))
			{
				case Keywords.By : 
					_lexer.NextToken();
					if (_lexer.PeekTokenSymbol(1) == Keywords.Default)
					{
						_lexer.NextToken();
						definition.ClusteredDefault = true;
					}
					else
					{
						definition.ClusteredIndexDefinition = new IndexDefinition();
						definition.ClusteredIndexDefinition.SetPosition(_lexer);
						IndexColumnDefinitionList(definition.ClusteredIndexDefinition.Columns);
						MetaData(definition.ClusteredIndexDefinition);
					}
				break;

				case Keywords.Indexes : AlterDeviceStoreDefinitionIndexes(definition); break;

				case Keywords.Tags : AlterMetaData(definition, true); break;
				default : throw new ParserException(ParserException.Codes.UnknownAlterDirective, _lexer[0].AsSymbol);
			}

			if (_lexer.PeekTokenSymbol(1) == Keywords.Alter)
			{
				_lexer.NextToken();
				switch (_lexer.PeekTokenSymbol(1))
				{
					case Keywords.Indexes : AlterDeviceStoreDefinitionIndexes(definition); break;

					case Keywords.Tags : AlterMetaData(definition, true); break;
				}
			}

			if (_lexer.PeekTokenSymbol(1) == Keywords.Alter)
				AlterMetaData(definition, true);

			definition.SetEndPosition(_lexer);
			return definition;
		}
		
		protected void AlterDeviceStoreDefinitionIndexes(AlterDeviceStoreDefinition definition)
		{
			_lexer.NextToken();
			if (_lexer.PeekTokenSymbol(1) == Keywords.Default)
			{
				_lexer.NextToken();
				definition.IndexesDefault = true;
			}
			else
			{
				_lexer.NextToken().CheckSymbol(Keywords.BeginList);
				bool done = false;
				while (!done)
				{
					switch (_lexer.NextToken().AsSymbol)
					{
						case Keywords.Create : definition.CreateIndexDefinitions.Add(IndexDefinition()); break;
						case Keywords.Alter : definition.AlterIndexDefinitions.Add(AlterIndexDefinition()); break;
						case Keywords.Drop : definition.DropIndexDefinitions.Add(DropIndexDefinition()); break;
						default : throw new ParserException(ParserException.Codes.DDLDirectiveExpected);
					}
					
					switch (_lexer.NextToken().AsSymbol)
					{
						case Keywords.ListSeparator : break;
						case Keywords.EndList : done = true; break;
						default : throw new ParserException(ParserException.Codes.ListTerminatorExpected);
					}
				}
			}
		}
		
		protected AlterIndexDefinition AlterIndexDefinition()
		{
			AlterIndexDefinition definition = new AlterIndexDefinition();
			definition.SetPosition(_lexer);
			_lexer.NextToken().CheckSymbol(Keywords.Index);
			IndexColumnDefinitionList(definition.Columns);
			AlterMetaData(definition, true);
			definition.SetEndPosition(_lexer);
			return definition;
		}
		
		protected DropIndexDefinition DropIndexDefinition()
		{
			DropIndexDefinition definition = new DropIndexDefinition();
			definition.SetPosition(_lexer);
			_lexer.NextToken().CheckSymbol(Keywords.Index);
			IndexColumnDefinitionList(definition.Columns);
			definition.SetEndPosition(_lexer);
			return definition;
		}
		
		protected void AlterDeviceDropItem(AlterDeviceStatement statement)
		{
			switch (_lexer.PeekTokenSymbol(1))
			{
				case Keywords.Type: statement.DropDeviceScalarTypeMaps.Add(DropDeviceScalarTypeMap()); break;
				case Keywords.Operator: statement.DropDeviceOperatorMaps.Add(DropDeviceOperatorMap()); break;
				case Keywords.Store: statement.DropDeviceStoreDefinitions.Add(DropDeviceStoreDefinition()); break;
				default: throw new ParserException(ParserException.Codes.UnknownDropDirective, _lexer[0].AsSymbol);
			}
		}
		
		protected DropDeviceScalarTypeMap DropDeviceScalarTypeMap()
		{
			DropDeviceScalarTypeMap dropDeviceScalarTypeMap = new DropDeviceScalarTypeMap();
			dropDeviceScalarTypeMap.SetPosition(_lexer);
			_lexer.NextToken().CheckSymbol(Keywords.Type);
			dropDeviceScalarTypeMap.ScalarTypeName = QualifiedIdentifier();
			dropDeviceScalarTypeMap.SetEndPosition(_lexer);
			return dropDeviceScalarTypeMap;
		}
		
		protected DropDeviceOperatorMap DropDeviceOperatorMap()
		{
			DropDeviceOperatorMap dropDeviceOperatorMap = new DropDeviceOperatorMap();
			dropDeviceOperatorMap.SetPosition(_lexer);
			_lexer.NextToken().CheckSymbol(Keywords.Operator);
			dropDeviceOperatorMap.OperatorSpecifier = OperatorSpecifier();
			dropDeviceOperatorMap.SetEndPosition(_lexer);
			return dropDeviceOperatorMap;
		}
		
		protected DropDeviceStoreDefinition DropDeviceStoreDefinition()
		{
			DropDeviceStoreDefinition definition = new DropDeviceStoreDefinition();
			definition.SetPosition(_lexer);
			_lexer.NextToken().CheckSymbol(Keywords.Store);
			definition.StoreName = QualifiedIdentifier();
			definition.SetEndPosition(_lexer);
			return definition;
		}
		
		/*
			BNF:
			<alter sort statement> ::=
				alter sort <scalar type name> [using <expression>] <alter metadata>
		*/
		protected AlterSortStatement AlterSortStatement(int line, int linePos)
		{
			AlterSortStatement statement = new AlterSortStatement();
			statement.Line = line;
			statement.LinePos = linePos;
			statement.ScalarTypeName = QualifiedIdentifier();
			if (_lexer.PeekTokenSymbol(1) == Keywords.Using)
			{
				_lexer.NextToken();
				statement.Expression = Expression();
			}
			AlterMetaData(statement, false);
			statement.SetEndPosition(_lexer);
			return statement;
		}
		
		/*
			BNF:
			<alter role statement> ::=
				alter role <role name> <alter metadata>
		*/
		protected AlterRoleStatement AlterRoleStatement(int line, int linePos)
		{
			AlterRoleStatement statement = new AlterRoleStatement();
			statement.Line = line;
			statement.LinePos = linePos;
			statement.RoleName = QualifiedIdentifier();
			AlterMetaData(statement, false);
			statement.SetEndPosition(_lexer);
			return statement;
		}
		
		/* 
			BNF:
			<drop statement> ::=
				(drop table <table name>) |
				(drop view <view name>) |
				(drop constraint <constraint name>) |
				(drop reference <reference name>) |
				(drop type <scalar type name>) |
				(drop operator <operator name>"("<formal parameter specifier commalist>")") |
				(drop aggregate operator <operator name>"("<formal parameter specifier commalist>")") |
				(drop device <device name>) |
				(drop server <server name>) |
				(drop sort <scalar type name>) |
				(drop conversion <scalar type name> to <scalar type name> using <operator name>) |
				(drop role <role name>) |
				(drop right <right name>)
		*/
		protected Statement DropStatement()
		{
			_lexer.NextToken();
			int line = _lexer[0, false].Line;
			int linePos = _lexer[0, false].LinePos;
			switch (_lexer.NextToken().AsSymbol)
			{
				case Keywords.Table: return DropTableStatement(line, linePos);
				case Keywords.View: return DropViewStatement(line, linePos);
				case Keywords.Constraint: return DropConstraintStatement(line, linePos);
				case Keywords.Reference: return DropReferenceStatement(line, linePos);
				case Keywords.Type: return DropScalarTypeStatement(line, linePos);
				case Keywords.Operator: return DropOperatorStatement(line, linePos);
				case Keywords.Aggregate:
					_lexer.NextToken().CheckSymbol(Keywords.Operator);
					return DropOperatorStatement(line, linePos);
				case Keywords.Server: return DropServerStatement(line, linePos);
				case Keywords.Device: return DropDeviceStatement(line, linePos);
				case Keywords.Sort: return DropSortStatement(line, linePos);
				case Keywords.Conversion: return DropConversionStatement(line, linePos);
				case Keywords.Role: return DropRoleStatement(line, linePos);
				case Keywords.Right: return DropRightStatement(line, linePos);
				default: throw new ParserException(ParserException.Codes.UnknownDropDirective, _lexer[0].AsSymbol);
			}
		}
		
		protected DropTableStatement DropTableStatement(int line, int linePos)
		{
			DropTableStatement statement = new DropTableStatement();
			statement.Line = line;
			statement.LinePos = linePos;
			statement.ObjectName = QualifiedIdentifier();
			statement.SetEndPosition(_lexer);
			return statement;
		}
		
		protected DropViewStatement DropViewStatement(int line, int linePos)
		{
			DropViewStatement statement = new DropViewStatement();
			statement.Line = line;
			statement.LinePos = linePos;
			statement.ObjectName = QualifiedIdentifier();
			statement.SetEndPosition(_lexer);
			return statement;
		}
		
		protected DropConstraintStatement DropConstraintStatement(int line, int linePos)
		{
			DropConstraintStatement statement = new DropConstraintStatement();
			statement.Line = line;
			statement.LinePos = linePos;
			statement.ConstraintName = QualifiedIdentifier();
			statement.SetEndPosition(_lexer);
			return statement;
		}
		
		protected DropReferenceStatement DropReferenceStatement(int line, int linePos)
		{
			DropReferenceStatement statement = new DropReferenceStatement();
			statement.Line = line;
			statement.LinePos = linePos;
			statement.ReferenceName = QualifiedIdentifier();
			statement.SetEndPosition(_lexer);
			return statement;
		}
		
		protected DropScalarTypeStatement DropScalarTypeStatement(int line, int linePos)
		{
			DropScalarTypeStatement statement = new DropScalarTypeStatement();
			statement.Line = line;
			statement.LinePos = linePos;
			statement.ObjectName = QualifiedIdentifier();
			statement.SetEndPosition(_lexer);
			return statement;
		}

		protected DropOperatorStatement DropOperatorStatement(int line, int linePos)
		{
			DropOperatorStatement statement = new DropOperatorStatement();
			statement.Line = line;
			statement.LinePos = linePos;
			statement.ObjectName = QualifiedIdentifier();
			FormalParameterSpecifiers(statement.FormalParameterSpecifiers);
			statement.SetEndPosition(_lexer);
			return statement;
		}
		
		protected DropServerStatement DropServerStatement(int line, int linePos)
		{
			DropServerStatement statement = new DropServerStatement();
			statement.Line = line;
			statement.LinePos = linePos;
			statement.ObjectName = QualifiedIdentifier();
			statement.SetEndPosition(_lexer);
			return statement;
		}
		
		protected DropDeviceStatement DropDeviceStatement(int line, int linePos)
		{
			DropDeviceStatement statement = new DropDeviceStatement();
			statement.Line = line;
			statement.LinePos = linePos;
			statement.ObjectName = QualifiedIdentifier();
			statement.SetEndPosition(_lexer);
			return statement;
		}

		protected DropSortStatement DropSortStatement(int line, int linePos)
		{
			DropSortStatement statement = new DropSortStatement();
			statement.Line = line;
			statement.LinePos = linePos;
			statement.ScalarTypeName = QualifiedIdentifier();
			statement.SetEndPosition(_lexer);
			return statement;
		}
		
		protected DropConversionStatement DropConversionStatement(int line, int linePos)
		{
			DropConversionStatement statement = new DropConversionStatement();
			statement.Line = line;
			statement.LinePos = linePos;
			statement.SourceScalarTypeName = TypeSpecifier();
			_lexer.NextToken().CheckSymbol(Keywords.To);
			statement.TargetScalarTypeName = TypeSpecifier();
			statement.SetEndPosition(_lexer);
			return statement;
		}
		
		protected DropRoleStatement DropRoleStatement(int line, int linePos)
		{
			DropRoleStatement statement = new DropRoleStatement();
			statement.Line = line;
			statement.LinePos = linePos;
			statement.RoleName = QualifiedIdentifier();
			statement.SetEndPosition(_lexer);
			return statement;
		}
		
		protected DropRightStatement DropRightStatement(int line, int linePos)
		{
			DropRightStatement statement = new DropRightStatement();
			statement.Line = line;
			statement.LinePos = linePos;
			statement.RightName = QualifiedIdentifier();
			statement.SetEndPosition(_lexer);
			return statement;
		}

		/*
			BNF:
			<attach statement> ::=
				attach [operator] <operator name> 
					to <event source specifier> 
					<event specifier clause>
					[before "{"<ne operator name commalist>"}"]
					<metadata>
		*/
		protected AttachStatement AttachStatement()
		{
			AttachStatement statement = new AttachStatement();
			_lexer.NextToken().CheckSymbol(Keywords.Attach);
			statement.SetPosition(_lexer);
			if (_lexer.PeekTokenSymbol(1) == Keywords.Operator)
				_lexer.NextToken();
			statement.OperatorName = QualifiedIdentifier();
			_lexer.NextToken().CheckSymbol(Keywords.To);
			statement.EventSourceSpecifier = EventSourceSpecifier();
			statement.EventSpecifier = EventSpecifierClause();
			if (_lexer.PeekTokenSymbol(1) == Keywords.Before)
			{
				_lexer.NextToken();
				_lexer.NextToken().CheckSymbol(Keywords.BeginList);
				bool done = false;
				do
				{
					statement.BeforeOperatorNames.Add(QualifiedIdentifier());
					
					switch (_lexer.NextToken().AsSymbol)
					{
						case Keywords.ListSeparator : break;
						case Keywords.EndList : done = true; break;
						default: throw new ParserException(ParserException.Codes.ListTerminatorExpected);
					}
				} while (!done);
			}
			MetaData(statement);
			statement.SetEndPosition(_lexer);
			return statement;
		}
		
		/*
			BNF:
			<event source specifier> ::=
				<tablevar name> |
				(<column name> in <tablevar name>) |
				<scalar type name>
		*/
		protected EventSourceSpecifier EventSourceSpecifier()
		{
			string identifier = QualifiedIdentifier();
			if (_lexer.PeekTokenSymbol(1) == Keywords.In)
			{
				ColumnEventSourceSpecifier columnSpecifier = new ColumnEventSourceSpecifier();
				_lexer.NextToken();
				columnSpecifier.SetPosition(_lexer);
				columnSpecifier.TableVarName = QualifiedIdentifier();
				columnSpecifier.ColumnName = identifier;
				columnSpecifier.SetEndPosition(_lexer);
				return columnSpecifier;
			}
			else
			{
				ObjectEventSourceSpecifier specifier = new ObjectEventSourceSpecifier();
				specifier.SetPosition(_lexer);
				specifier.ObjectName = identifier;
				specifier.SetEndPosition(_lexer);
				return specifier;
			}
		}
		
		/*
			BNF:
			<event specifier clause> ::=
				on (<event specifier> | ("{"<ne event specifier commalist>"}"))
				
			<event specifier> ::=
				((before | after) (insert | update | delete)) | 
				(default | validate | change)
		*/
		protected EventSpecifier EventSpecifierClause()
		{
			EventSpecifier eventSpecifier = new EventSpecifier();
			_lexer.NextToken().CheckSymbol(Keywords.On);
			eventSpecifier.SetPosition(_lexer);
			if (_lexer.PeekTokenSymbol(1) == Keywords.BeginList)
			{
				_lexer.NextToken().CheckSymbol(Keywords.BeginList);
				bool done = false;
				while (!done)
				{
					EventSpecifier(eventSpecifier);

					switch (_lexer.NextToken().AsSymbol)
					{
						case Keywords.ListSeparator: break;
						case Keywords.EndList: done = true; break;
						default: throw new ParserException(ParserException.Codes.ListTerminatorExpected);
					}
				}
			}
			else
				EventSpecifier(eventSpecifier);
			eventSpecifier.SetEndPosition(_lexer);
			return eventSpecifier;
		}
		
		protected void EventSpecifier(EventSpecifier eventSpecifier)
		{
			switch (_lexer.NextToken().AsSymbol)
			{
				case Keywords.Before:
				case Keywords.After:
					bool before = (_lexer[0].AsSymbol == Keywords.Before);
					
					switch (_lexer.NextToken().AsSymbol)
					{
						case Keywords.Insert: eventSpecifier.EventType |= (before ? EventType.BeforeInsert : EventType.AfterInsert); break;
						case Keywords.Update: eventSpecifier.EventType |= (before ? EventType.BeforeUpdate : EventType.AfterUpdate); break;
						case Keywords.Delete: eventSpecifier.EventType |= (before ? EventType.BeforeDelete : EventType.AfterDelete); break;
						default: throw new ParserException(ParserException.Codes.UnknownEventSpecifier);
					}
				break;

				case Keywords.Default: eventSpecifier.EventType |= EventType.Default; break;
				case Keywords.Validate: eventSpecifier.EventType |= EventType.Validate; break;
				case Keywords.Change: eventSpecifier.EventType |= EventType.Change; break;
				
				default: throw new ParserException(ParserException.Codes.UnknownEventSpecifier, _lexer[0].AsSymbol);
			}
		}
		
		/*
			BNF:
			<detach statement> ::=
				detach [operator] <operator name>
					from <event source specifier>
					<event specifier clause>
		*/
		protected DetachStatement DetachStatement()
		{
			DetachStatement statement = new DetachStatement();
			_lexer.NextToken().CheckSymbol(Keywords.Detach);
			statement.SetPosition(_lexer);
			if (_lexer.PeekTokenSymbol(1) == Keywords.Operator)
				_lexer.NextToken();
			statement.OperatorName = QualifiedIdentifier();
			_lexer.NextToken().CheckSymbol(Keywords.From);
			statement.EventSourceSpecifier = EventSourceSpecifier();
			statement.EventSpecifier = EventSpecifierClause();
			statement.SetEndPosition(_lexer);
			return statement;
		}
		
		/*
			BNF:
			<invoke statement> ::=
				invoke <operator name>
					on <event source specifier>
					<event specifier clause>
					before "{"<ne operator name commalist>"}"
		*/
		protected InvokeStatement InvokeStatement()
		{
			InvokeStatement statement = new InvokeStatement();
			_lexer.NextToken().CheckSymbol(Keywords.Invoke);
			statement.SetPosition(_lexer);
			statement.OperatorName = QualifiedIdentifier();
			_lexer.NextToken().CheckSymbol(Keywords.On);
			statement.EventSourceSpecifier = EventSourceSpecifier();
			statement.EventSpecifier = EventSpecifierClause();
			_lexer.NextToken().CheckSymbol(Keywords.Before);
			_lexer.NextToken().CheckSymbol(Keywords.BeginList);
			bool done = false;
			do
			{
				statement.BeforeOperatorNames.Add(QualifiedIdentifier());
				
				switch (_lexer.NextToken().AsSymbol)
				{
					case Keywords.ListSeparator : break;
					case Keywords.EndList : done = true; break;
					default: throw new ParserException(ParserException.Codes.ListTerminatorExpected);
				}
			} while (!done);
			statement.SetEndPosition(_lexer);
			return statement;
		}
		
		/*
			BNF:
			<grant statement> ::=
				grant <right specifier>
					[on <catalog object specifier>] 
					to <security specifier>
					
			<right specifier> ::=
				all | usage | ("{"<right name commalist>"}")
					
			<right name> ::=
				<qualified identifier>
				
			<catalog object specifier> ::=
				<qualified identifier> | <operator specifier>
				
			<user id> ::=
				<string>
				
			<group name> ::=
				<string>
				
			<role name> ::=
				<qualified identifier>

			<security specifier> ::=
				(user <user id>) | 
				(role <role name>) |
				(group <group name> [inherited] [apply recursively] [include users])
		*/
		protected void RightSpecifier(RightStatementBase statement)
		{
			switch (_lexer.NextToken().AsSymbol)
			{
				case Keywords.All : statement.RightType = RightSpecifierType.All; break;
				case Keywords.Usage : statement.RightType = RightSpecifierType.Usage; break;
				case Keywords.BeginList : 
					statement.RightType = RightSpecifierType.List;
					bool done = false;
					while (!done)
					{
						RightSpecifier specifier = new RightSpecifier();
						specifier.RightName = QualifiedIdentifier();
						specifier.SetPosition(_lexer);
						statement.Rights.Add(specifier);
						switch (_lexer.NextToken().AsSymbol)
						{
							case Keywords.ListSeparator : break;
							case Keywords.EndList : done = true; break;
							default : throw new ParserException(ParserException.Codes.ListTerminatorExpected);
						}
					}
				break;
				default : throw new ParserException(ParserException.Codes.InvalidRightSpecifier);
			}
		}
		
		protected CatalogObjectSpecifier CatalogObjectSpecifier()
		{
			CatalogObjectSpecifier specifier = new CatalogObjectSpecifier();
			specifier.ObjectName = QualifiedIdentifier();
			specifier.SetPosition(_lexer);
			if (_lexer.PeekTokenSymbol(1) == Keywords.BeginGroup)
			{
				specifier.IsOperator = true;
				FormalParameterSpecifiers(specifier.FormalParameterSpecifiers);
			}
			
			specifier.SetEndPosition(_lexer);
			return specifier;
		}
		
		protected void CatalogObjectSpecifier(RightStatementBase statement)
		{
			if (_lexer.PeekTokenSymbol(1) == Keywords.On)
			{
				_lexer.NextToken();
				statement.Target = CatalogObjectSpecifier();
			}
		}
		
		protected void SecuritySpecifier(RightStatementBase statement)
		{
			switch (_lexer.NextToken().AsSymbol)
			{
				case Keywords.User :
					statement.GranteeType = GranteeType.User;
					_lexer.NextToken();
					#if USEISTRING
					if (FLexer[0].Type == LexerToken.String)
						AStatement.Grantee = FLexer[0].AsString();
					else
						AStatement.Grantee = FLexer.TokenIString();
					#else
					statement.Grantee = _lexer[0].AsString;
					#endif
				break;
				
				case Keywords.Role :
					statement.GranteeType = GranteeType.Role;
					statement.Grantee = QualifiedIdentifier();
				break;
				
				case Keywords.Group :
					statement.GranteeType = GranteeType.Group;
					_lexer.NextToken();
					#if USEISTRING
					if (FLexer[0].Type == LexerToken.String)
						AStatement.Grantee = FLexer[0].AsString();
					else
						AStatement.Grantee = FLexer.TokenIString();
					#else
					statement.Grantee = _lexer[0].AsString;
					#endif
					if (_lexer.PeekTokenSymbol(1) == Keywords.Inherited)
					{
						_lexer.NextToken();
						statement.IsInherited = true;
					}
					
					if (_lexer.PeekTokenSymbol(1) == Keywords.Apply)
					{
						_lexer.NextToken();
						statement.ApplyRecursively = true;
					}
					
					if (_lexer.PeekTokenSymbol(1) == Keywords.Include)
					{
						_lexer.NextToken();
						statement.IncludeUsers = true;
					}
				break;
				
				default : throw new ParserException(ParserException.Codes.InvalidSecuritySpecifier);
			}
		}
		
		protected GrantStatement GrantStatement()
		{
			GrantStatement grantStatement = new GrantStatement();
			_lexer.NextToken().CheckSymbol(Keywords.Grant);
			grantStatement.SetPosition(_lexer);
			RightSpecifier(grantStatement);
			CatalogObjectSpecifier(grantStatement);
			_lexer.NextToken().CheckSymbol(Keywords.To);
			SecuritySpecifier(grantStatement);
			grantStatement.SetEndPosition(_lexer);
			return grantStatement;
		}
		
		/*
			BNF:
			<revoke statement> ::=
				revoke <right specifier> [on <catalog object specifier>] from <security specifier>
		*/
		protected RevokeStatement RevokeStatement()
		{
			RevokeStatement revokeStatement = new RevokeStatement();
			_lexer.NextToken().CheckSymbol(Keywords.Revoke);
			revokeStatement.SetPosition(_lexer);
			RightSpecifier(revokeStatement);
			CatalogObjectSpecifier(revokeStatement);
			_lexer.NextToken().CheckSymbol(Keywords.From);
			SecuritySpecifier(revokeStatement);
			revokeStatement.SetEndPosition(_lexer);
			return revokeStatement;
		}
		
		/*
			BNF:
			<revert statement> ::=
				revert <right specifier> [on <catalog object specifier>] for <security specifier>
		*/
		protected RevertStatement RevertStatement()
		{
			RevertStatement revertStatement = new RevertStatement();
			_lexer.NextToken().CheckSymbol(Keywords.Revert);
			revertStatement.SetPosition(_lexer);
			RightSpecifier(revertStatement);
			CatalogObjectSpecifier(revertStatement);
			_lexer.NextToken().CheckSymbol(Keywords.For);
			SecuritySpecifier(revertStatement);
			revertStatement.SetEndPosition(_lexer);
			return revertStatement;
		}
	}
}

