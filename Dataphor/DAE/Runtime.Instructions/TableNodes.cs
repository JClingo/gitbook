/*
	Dataphor
	Â© Copyright 2000-2008 Alphora
	This file is licensed under a modified BSD-license which can be found here: http://dataphor.org/dataphor_license.txt
*/
#define UseReferenceDerivation
#define USEUPDATEVALUEFLAGS
	
using System;
using System.Text;
using System.Threading;
using System.Collections;
using System.Collections.Generic;
using System.Collections.Specialized;

namespace Alphora.Dataphor.DAE.Runtime.Instructions
{
	using Alphora.Dataphor.DAE.Language;
	using Alphora.Dataphor.DAE.Language.D4;
	using Alphora.Dataphor.DAE.Compiling;
	using Alphora.Dataphor.DAE.Compiling.Visitors;
	using Alphora.Dataphor.DAE.Server;	
	using Alphora.Dataphor.DAE.Runtime;
	using Alphora.Dataphor.DAE.Runtime.Data;
	using Alphora.Dataphor.DAE.Device.ApplicationTransaction;
	using Schema = Alphora.Dataphor.DAE.Schema;

	// TODO: Make sure the cursors only select the columns that are absolutely necessary to perform their task.
	// (i.e. make sure a join only selects the fields it needs to compare to do the join from its source cursors.)
            
	// TODO: determine how to optimize for non-rowlevel modification operations
	// TODO: incorporate the General Unification Theorem into these nodes
	
	/*
        Key determination for expressions per operator ->
        
            Retrieve ->
                Key is defined by the table or view being retrieved
                
            Project ->
                if the columns of the projection include the key of the source bag
                    the key is inherited from the source bag
                else
                    if the projection is distinct
                        the key is all columns of the projection
                    else
                        the key is undefined
                        
            Aggregate ->
                if the by columns of the aggregation include the key of the source bag
                    the key is inherited from the source bag
                else
                    the key is all by columns of the aggregation
                        
            Restrict ->
                Key is inherited from the source bag
                    
            Order ->
                Key is inherited from the source bag
                
            Intersect ->
                Key is inherited from the left source bag
                    The operation is implemented by including rows from the 
                    left side that can be found in the right side.  If the intersect
                    is based on sets, the operation is commutative.  If the intersect
                    is based on bags or a bag and set, the operation loses commutativity,
                    hence the implementation specific assumption that the key is derived 
                    from the left bag.
                
            Difference ->
                Key is inherited from the left source bag
            
            Union ->
                if the union is distinct
                    if there is a left key and a right key
                        the keys are the distinct set of keys generated by taking the cartesian product
                        of the left and right keys, and unioning the attributes of the keys in each pair
                    else
                        the key is all columns in the union
                else
                    the key is undefined
            
            Product ->
                If the left bag and the right bag have keys,
                    the key of the product is the union of the keys
                else
                    the key is undefined
                    
            Join ->
                Determine uniqueness for the right and left columns over which the join is defined
                
                if the left join columns and the right join columns are unique
                    the key is the left key or the right key
                else if the left join columns are unique
                    if there is a right key
                        the key is the right key
                    else 
                        the key is undefined
                else if the right join columns are unique
                    if there is a left key
                        the key is the left key
                    else
                        the key is undefined
                else if neither join columns are unique
                    if there is a left key and a right key
                        the key is the left key and the right key
                    else
                        the key is undefined
                    
                if the join is a full outer
                    add an exists column to the left and right column list
                else if the join is a left outer
                    add an exists column to the right column list
                else if the join is a right outer
                    add an exists column to the left column list
                  
            Divide ->
                if the attributes of A that are not in B form a key in A,
                    the key is that key
                else
                    the key is undefined
                  
            Great Divide ->
                if bag A has a key
                    the key is the key for bag A
                else
                    the key is undefined
                    
        Predicate derivation rules per operator ->
        
            Retrieve ->
                the predicate is inherited from the source object
                
            Project ->
            
            Aggregate ->
            
            Restrict ->
                the predicate is the predicate of the source object and the restriction expression
            
            Order ->
                the predicate is inherited from the source object
            
            Intersect ->
                the predicate is P(A) and P(B)
            
            Difference ->
                the predicate is P(A) and not P(B)
            
            Union ->
                the predicate is P(A) or P(B)
            
            Product ->
            
            Join ->
                given (A) join (B) on <theta>
                    there is a row in A such that theta evaluates to true for at least one row in B
                    
                given (A) left outer join (B) on <theta>
                    there is a row in A such that theta evaluates to true for some row(s) in B
                    
                given (A) right outer join (B) on <theta>
                    there is a row in B such that theta evaluates to true for some row(s) in A
                    
                given (A) full outer join (B) on <theta>
                    there is a row in A such that theta evaluates to true for some row(s) in A or
                    there is a row in B such that theta evaluates to true for some row(s) in B
            
            Divide ->
                    
        Modification propagation rules per operator ->
            
            Retrieve ->
                if the operator cursor is updateable
                    modifications take place through the cursor (Insert, Update, Delete methods)
                else
                    if the operator cursor has at least one key
                        if a server is available and supports the modification being requested
                            the statement is executed against the server
                        else
                            the modification is propogated to the source cursor
                    else
                        the modification is rejected
                        
            Project ->
                same as retrieve 
                
            Aggregate ->
                same as retrieve
            
            Restrict ->
                same as retrieve with the exception that the incoming row must satisfy the conditions
                of the restriction.
            
            Order ->
                same as retrieve
                
            Union ->
                if the cursor is updateable
                    modifications take place through the cursor
                else
                    if the operator cursor has at least one key
                        if a server is available and supports the operation being requested
                            the statement is executed against the server
                        else
                            for an insert
                                if the row satisfies the predicate for the left source cursor
                                    the row is inserted in the left source cursor
                                if the row satisfies the predicate for the right source cursor
                                    if the row still does not exist in the right source cursor
                                        the row is inserted into the right source cursor
                            for an update
                                if the old row satisfies the predicate for the left source cursor
                                    the row is deleted from the left source cursor (without checking integrity constraints)
                                if the old row satisfies the predicate for the right source cursor
                                    the row is deleted from the right source cursor (without checking integrity constraints)
                                if the new row satisfies the predicate for the left source cursor
                                    the new row is inserted in the left source cursor
                                if the new row satisfies the predicate for the right source cursor
                                    if the row still does not exist in the right source cursor
                                        the new row is inserted in the right source cursor
                            for a delete
                                if the row satisfies the predicate for the left source cursor
                                    the row is deleted from the left source cursor
                                if the row satisfies the predicate for the right source cursor
                                    the row is deleted from the right source cursor
                    else
                        the modification is rejected
                
            Intersect ->
                if the cursor is updateable
                    the modification takes place through the cursor
                else
                    if the operator has at least one key
                        if a server is available and supports the modification being requested
                            the modification is executed against the server
                        else
                            for an insert
                                the new row must satisfy the predicate for both source cursors
                                the new row is inserted into the left source cursor
                                if it still does not exist in the right source cursor
                                    the row is inserted into the right source cursor
                            for an update
                                the new row must satisfy the predicate for both source cursors
                                the old row is deleted from the left source cursor (without checking integrity)
                                the old row is deleted from the right source cursor (without checking integrity)
                                the new row is inserted into the left source cursor
                                if the row still does not exist in the right source cursor
                                    the row is inserted into the right source cursor
                            for a delete
                                the row is deleted from the left source cursor
                                the row is deleted from the right source cursor
                    else
                        the modification is rejected
            
            Difference ->
                if the cursor is updateable
                    the modification takes place through the cursor
                else
                    if the operator has at least one key
                        if a server is available and supports the modification being requested
                            the modification is executed against the server
                        else
                            for an insert
                                the new row must satisfy the left predicate and not the right predicate
                                the row is inserted into the left source cursor
                            for an update
                                the new row must satisfy the left predicate and not the right predicate
                                the old row is deleted from the left source cursor (without checking integrity)
                                the new row is inserted into the left source cursor
                            for a delete
                                the row is deleted from the left source cursor
                    else
                        the modification is rejected
            
            Product ->   
                if the cursor is updateable
                    the modification takes place through the cursor
                else
                    if the operator has at least one key
                        if a server is available and supports the modification being requested
                            the modification is executed against the server
                        else
                            for an insert
                                the new rows are inserted into the left and right source cursors
                            for an update
                                the old rows are deleted from the left and right source cursors (without checking integrity)
                                the new rows are inserted into the left and right source cursors
                            for a delete
                                the old rows are deleted from the left and right source cursors
                    else
                        the modification is rejected
                             
            Join ->
                if the cursor is updateable
                    the modification takes place through the cursor
                else
                    if the operator has at least one key
                        if a server is available and supports the modification being requested
                            the modification is executed against the server
                        else
                            for an insert
                                the new row must satisfy the join expression
                                if the join is inner
                                    the new rows are inserted into the left and right source cursors
                                if the join is outer
                                    if there is no exists flag, or the exists flag is true for the left row
                                        the left row is inserted in the left source cursor
                                    if there is no exists flag, or the exists flag is true for the right row
                                        the right row is inserted in the right source cursor
                            for an update
                                the new row must satisfy the join expression
                                if the join is inner
                                    the rows are updated in the left and right source cursors
                                if the join is outer
                                    if there is no exists flag, or the exists flag is true for the left row
                                        if the old exists flag is false
                                            the left row is inserted in the left source cursor
                                        else
                                            the left row is updated in the left source cursor
                                    else
                                        the left row is deleted from the left source cursor
                                    if there is no exists flag, or the exists flag is true for the right row
                                        if the old exists flag is false
                                            the right row is inserted in the right source cursor
                                        else
                                            the right row is updated in the right source cursor
                                    else
                                        the right row is deleted from the right source cursor
                            for a delete
                                the rows are deleted from the left and right source cursors
                    else
                        the modification is rejected
                        
            Divide ->
                if the cursor is updateable
                    the modification takes place through the cursor
                else
                    if the operator has at least one key
                        if a server is available and supports the modification being requested
                            the modification is executed against the server
                        else
                            for an insert
                                the product of the new row with B is inserted into A
                            for an update
                                the product of the old row with B is deleted from A (without checking integrity)
                                the product of the new row with B is inserted into A
                            for a delete
                                the product of the new row with B is inserted into A
                    else
                        the modification is rejected
                             
            Great Divide ->
                if the cursor is updateable
                    the modification takes place through the cursor
                else
                    if the operator has at least one key
                        if a server is available and supports the modification being requested
                            the modification is executed against the server
                        else
                            for an insert
                                the new row is inserted into A along with all matching rows are in C for all rows in B
                            for an update
                                the old row is deleted from A along with all matching rows from C for all rows in B (without checking integrity)
                                the new row is inserted into A along with all matching rows in C for all rows in B
                            for a delete
                                the old row is deleted from A along with all matching rows from C for all rows in B
                    else
                        the modification is rejected
                             
	*/
	
    public abstract class DMLNode : PlanNode
    {
		public DMLNode() : base()
		{
			IsBreakable = true;
		}
		
		private bool _unchecked = false;
		public bool Unchecked { get { return _unchecked; } }
		
		protected override void DetermineModifiers(Plan plan)
		{
			base.DetermineModifiers(plan);
			if (Modifiers != null)
				_unchecked = Boolean.Parse(LanguageModifiers.GetModifier(Modifiers, "Unchecked", Unchecked.ToString()));
		}
		
		public override void DetermineDataType(Plan plan)
		{
			DetermineModifiers(plan);
		}
    }

	// Nodes[0] - Source table / row value
	// Nodes[1] - Target table variable
    public class InsertNode : DMLNode
    {
		private bool _insertedUpdate;
		public bool InsertedUpdate
		{
			get { return _insertedUpdate; }
			set { _insertedUpdate = value; }
		}
		
		private string _updateColumnNames;
		public string UpdateColumnNames
		{
			get { return _updateColumnNames; }
			set { _updateColumnNames = value; }
		}
		
		protected override void DetermineModifiers(Plan plan)
		{
			base.DetermineModifiers(plan);
			if (Modifiers != null)
			{
				InsertedUpdate = Boolean.Parse(LanguageModifiers.GetModifier(Modifiers, "InsertedUpdate", InsertedUpdate.ToString()));
				UpdateColumnNames = LanguageModifiers.GetModifier(Modifiers, "UpdateColumnNames", UpdateColumnNames);
			}
		}
		
		protected override void InternalBindingTraversal(Plan plan, PlanNodeVisitor visitor)
		{
			plan.PushCursorContext(new CursorContext(CursorType.Static, CursorCapability.Navigable, CursorIsolation.None));
			try
			{
				#if USEVISIT
				Nodes[0] = visitor.Visit(plan, Nodes[0]);
				#else
				Nodes[0].BindingTraversal(plan, visitor);
				#endif
			}
			finally
			{
				plan.PopCursorContext();
			}
			
			plan.PushCursorContext(new CursorContext(CursorType.Static, CursorCapability.Navigable | CursorCapability.Updateable, CursorIsolation.Isolated));
			try
			{
				bool saveIsInsert = plan.IsInsert;
				plan.IsInsert = true;
				try
				{
					#if USEVISIT
					Nodes[1] = visitor.Visit(plan, Nodes[1]);
					#else
					Nodes[1].BindingTraversal(plan, visitor);
					#endif
				}
				finally
				{
					plan.IsInsert = saveIsInsert;
				}
			}
			finally
			{
				plan.PopCursorContext();
			}
		}
		
		public override void BindToProcess(Plan plan)
		{
			plan.PushCursorContext(new CursorContext(CursorType.Static, CursorCapability.Navigable, CursorIsolation.None));
			try
			{
				Nodes[0].BindToProcess(plan);
			}
			finally
			{
				plan.PopCursorContext();
			}

			plan.PushStatementContext(new StatementContext(StatementType.Insert));
			try
			{
				plan.PushCursorContext(new CursorContext(CursorType.Static, CursorCapability.Navigable | CursorCapability.Updateable, CursorIsolation.Isolated));
				try
				{
					bool saveIsInsert = plan.IsInsert;
					plan.IsInsert = true;
					try
					{
						Nodes[1].BindToProcess(plan);
					}
					finally
					{
						plan.IsInsert = saveIsInsert;
					}
				}
				finally
				{
					plan.PopCursorContext();
				}
			}
			finally
			{
				plan.PopStatementContext();
			}
		}

		public override object InternalExecute(Program program)
		{
			if (program.ServerProcess.IsReconciliationEnabled())
			{
				// Open a table for the source expression
				// Open a table for the target expression
				// Insert each row of the source expression into the target expression
				object source = Nodes[0].Execute(program);

				object target;
				bool saveIsInsert = program.ServerProcess.IsInsert; 
				bool saveIsOpeningInsertCursor = program.ServerProcess.IsOpeningInsertCursor; 
				program.ServerProcess.IsInsert = true; // To indicate to application transactions that data should not be populated
				program.ServerProcess.IsOpeningInsertCursor = true; // To indicate to devices involved in the expression that it is not necessary to open the cursor
				try
				{
					target = Nodes[1].Execute(program);
				}
				finally
				{
					program.ServerProcess.IsInsert = saveIsInsert;
					program.ServerProcess.IsOpeningInsertCursor = saveIsOpeningInsertCursor;
				}

				if (source is IRow)
				{
					using (IRow row = (IRow)source)
					{
						using (ITable targetTable = (ITable)target)
						{
							if (InsertedUpdate)
							{
								Schema.RowType oldRowType = new Schema.RowType();
								Schema.RowType newRowType = new Schema.RowType();
								for (int index = 0; index < row.DataType.Columns.Count; index++)
									if (Schema.Object.Qualifier(row.DataType.Columns[index].Name) == Keywords.Old)
										oldRowType.Columns.Add(row.DataType.Columns[index].CopyAndRename(Schema.Object.Dequalify(row.DataType.Columns[index].Name)));
									else
										newRowType.Columns.Add(row.DataType.Columns[index].CopyAndRename(Schema.Object.Dequalify(row.DataType.Columns[index].Name)));
										
								using (Row oldRow = new Row(program.ValueManager, oldRowType))
								{
									using (Row newRow = new Row(program.ValueManager, newRowType))
									{
										for (int index = 0; index < row.DataType.Columns.Count; index++)
											if (Schema.Object.Qualifier(row.DataType.Columns[index].Name) == Keywords.Old)
												oldRow[Schema.Object.Dequalify(row.DataType.Columns[index].Name)] = row[index];
											else
												newRow[Schema.Object.Dequalify(row.DataType.Columns[index].Name)] = row[index];
											
										#if USEUPDATEVALUEFLAGS
										BitArray valueFlags = new BitArray(newRow.DataType.Columns.Count);
										if (UpdateColumnNames != null)
										{
											string[] updateColumnNames = UpdateColumnNames.Split(';');
											Schema.Columns updateColumns = new Schema.Columns();
											for (int index = 0; index < updateColumnNames.Length; index++)
												updateColumns.Add(newRow.DataType.Columns[updateColumnNames[index]]);
											for (int index = 0; index < valueFlags.Length; index++)
												valueFlags[index] = updateColumns.ContainsName(newRow.DataType.Columns[index].Name);
										}
										else
											for (int index = 0; index < valueFlags.Length; index++)
												valueFlags[index] = true;

										targetTable.Insert(oldRow, newRow, valueFlags, Unchecked);
										#else
										targetTable.Insert(oldRow, newRow, null, Unchecked);
										#endif
									}
								}
							}
							else
							{
								BitArray valueFlags = new BitArray(row.DataType.Columns.Count);
								for (int index = 0; index < valueFlags.Length; index++)
									valueFlags[index] = true;

								targetTable.Insert(null, row, valueFlags, Unchecked);
							}

							return null;
						}
					}
				}
				else
				{
					using (ITable sourceTable = ((ITable)source))
					{
						using (Row row = new Row(program.ValueManager, sourceTable.DataType.RowType))
						{
							using (ITable targetTable = ((ITable)target))
							{
								// TODO: Make sure LSource is static if it is referenced by the expression of LTarget
								if (InsertedUpdate)
								{
									Schema.RowType oldRowType = new Schema.RowType();
									Schema.RowType newRowType = new Schema.RowType();
									for (int index = 0; index < row.DataType.Columns.Count; index++)
										if (Schema.Object.Qualifier(row.DataType.Columns[index].Name) == Keywords.Old)
											oldRowType.Columns.Add(row.DataType.Columns[index].CopyAndRename(Schema.Object.Dequalify(row.DataType.Columns[index].Name)));
										else
											newRowType.Columns.Add(row.DataType.Columns[index].CopyAndRename(Schema.Object.Dequalify(row.DataType.Columns[index].Name)));
											
									using (Row oldRow = new Row(program.ValueManager, oldRowType))
									{
										using (Row newRow = new Row(program.ValueManager, newRowType))
										{
											#if USEUPDATEVALUEFLAGS
											BitArray valueFlags = new BitArray(newRow.DataType.Columns.Count);
											if (UpdateColumnNames != null)
											{
												string[] updateColumnNames = UpdateColumnNames.Split(';');
												Schema.Columns updateColumns = new Schema.Columns();
												for (int index = 0; index < updateColumnNames.Length; index++)
													updateColumns.Add(newRow.DataType.Columns[updateColumnNames[index]]);
												for (int index = 0; index < valueFlags.Length; index++)
													valueFlags[index] = updateColumns.ContainsName(newRow.DataType.Columns[index].Name);
											}
											else
												for (int index = 0; index < valueFlags.Length; index++)
													valueFlags[index] = true;
											#endif

											while (sourceTable.Next())
											{
												sourceTable.Select(row);

												for (int index = 0; index < row.DataType.Columns.Count; index++)
													if (Schema.Object.Qualifier(row.DataType.Columns[index].Name) == Keywords.Old)
														oldRow[Schema.Object.Dequalify(row.DataType.Columns[index].Name)] = row[index];
													else
														newRow[Schema.Object.Dequalify(row.DataType.Columns[index].Name)] = row[index];
														
												#if USEUPDATEVALUEFLAGS
												targetTable.Insert(oldRow, newRow, valueFlags, Unchecked);
												#else
												targetTable.Insert(oldRow, newRow, null, Unchecked);
												#endif
											}
										}
									}
								}
								else
								{
									BitArray valueFlags = new BitArray(row.DataType.Columns.Count);
									for (int index = 0; index < valueFlags.Length; index++)
										valueFlags[index] = true;

									while (sourceTable.Next())
									{
										sourceTable.Select(row);
										targetTable.Insert(null, row, valueFlags, Unchecked);
									}
								}
								return null;
							}
						}
					}
				}
			}
			
			return null;
		}

		public override Statement EmitStatement(EmitMode mode)
		{
			InsertStatement statement = new InsertStatement();
			statement.Modifiers = Modifiers;
			statement.SourceExpression = (Expression)Nodes[0].EmitStatement(mode);
			statement.Target = (Expression)Nodes[1].EmitStatement(mode);
			return statement;
		}
    }
    
    public class UpdateColumnNode : PlanNode
    {
		// constructor
		public UpdateColumnNode() : base()
		{
			IgnoreUnsupported = true;
		}
		#if USECOLUMNLOCATIONBINDING
		public UpdateColumnNode(Schema.IDataType ADataType, int AColumnLocation, PlanNode ATargetValue) : base()
		{
			IgnoreUnsupported = true;
			FDataType = ADataType;
			FColumnLocation = AColumnLocation;
			Nodes.Add(ATargetValue);
		}

		// ColumnLocation
		protected int FColumnLocation;
		public int ColumnLocation
		{
			get { return FColumnLocation; }
			set { FColumnLocation = value; }
		}
		#else
		public UpdateColumnNode(Schema.IDataType dataType, string columnName, PlanNode targetValue) : base()
		{
			IgnoreUnsupported = true;
			_dataType = dataType;
			ColumnName = columnName;
			Nodes.Add(targetValue);
		}
		
		// ColumnName
		public string ColumnName;
		#endif
		
		public override object InternalExecute(Program program)
		{
			return Nodes[0].Execute(program);
		}
    }
    
    public class UpdateNode : DMLNode
    {
		protected bool _isKeyAffected = false;
		public bool IsKeyAffected
		{
			get { return _isKeyAffected; }
			set { _isKeyAffected = value; }
		}
		
		protected PlanNode _targetNode = null;
		public PlanNode TargetNode
		{
			get { return _targetNode; }
			set { _targetNode = value; }
		}
		
		protected PlanNode _conditionNode = null;
		public PlanNode ConditionNode
		{
			get { return _conditionNode; }
			set { _conditionNode = value; }
		}

		protected override void InternalBindingTraversal(Plan plan, PlanNodeVisitor visitor)
		{
			plan.PushCursorContext(new CursorContext(CursorType.Static, CursorCapability.Navigable | CursorCapability.Updateable, CursorIsolation.Isolated));
			try
			{
				#if USEVISIT
				Nodes[0] = visitor.Visit(plan, Nodes[0]);
				#else
				Nodes[0].BindingTraversal(plan, visitor);
				#endif
				if (!(((TableNode)Nodes[0]).CursorType == CursorType.Static))
				{
					Nodes[0] = Compiler.EmitCopyNode(plan, (TableNode)Nodes[0]);
					plan.PushGlobalContext();
					try
					{
						((TableNode)Nodes[0]).InferPopulateNode(plan);
						Nodes[0].DeterminePotentialDevice(plan);
						Nodes[0].DetermineDevice(plan);
						Nodes[0].DetermineAccessPath(plan);
					}
					finally
					{
						plan.PopGlobalContext();
					}
				}
			}
			finally
			{
				plan.PopCursorContext();
			}

			plan.EnterRowContext();
			try
			{
				plan.Symbols.Push(new Symbol(String.Empty, ((Schema.TableType)Nodes[0].DataType).RowType));
				try
				{
					for (int index = 1; index < Nodes.Count; index++)
						#if USEVISIT
						Nodes[index] = visitor.Visit(plan, Nodes[index]);
						#else
						Nodes[index].BindingTraversal(plan, visitor);
						#endif
				}
				finally
				{
					plan.Symbols.Pop();
				}
			}
			finally
			{
				plan.ExitRowContext();
			}
		}
		
		public override void BindToProcess(Plan plan)
		{
			plan.PushStatementContext(new StatementContext(StatementType.Update));
			try
			{
				plan.PushCursorContext(new CursorContext(CursorType.Static, CursorCapability.Navigable | CursorCapability.Updateable, CursorIsolation.Isolated));
				try
				{
					Nodes[0].BindToProcess(plan);
				}
				finally
				{
					plan.PopCursorContext();
				}
			}
			finally
			{
				plan.PopStatementContext();
			}

			for (int index = 1; index < Nodes.Count; index++)
				Nodes[index].BindToProcess(plan);
		}
		
		public override object InternalExecute(Program program)
		{
			if (program.ServerProcess.IsReconciliationEnabled())
			{
				// Open a table for the expression
				// for each row in the table, update the value of each column to the given expression
				using (ITable table = (ITable)Nodes[0].Execute(program))
				{
					Row oldRow = new Row(program.ValueManager, table.DataType.RowType);
					try
					{
						Row newRow = new Row(program.ValueManager, table.DataType.RowType);
						try
						{
							if (table.Next())
							{
								#if USEUPDATEVALUEFLAGS
								BitArray valueFlags = new BitArray(newRow.DataType.Columns.Count);
								Schema.Columns updateColumns = new Schema.Columns();
								for (int index = 1; index < Nodes.Count; index++)
									updateColumns.Add(newRow.DataType.Columns[((UpdateColumnNode)Nodes[index]).ColumnName]);
								for (int index = 0; index < valueFlags.Length; index++)
									valueFlags[index] = updateColumns.ContainsName(newRow.DataType.Columns[index].Name);
								#endif
									
								while (true)
								{
									table.Select(oldRow);
									table.Select(newRow);
									program.Stack.Push(oldRow);
									try
									{
										for (int index = 1; index < Nodes.Count; index++)
										{
											object objectValue = Nodes[index].Execute(program);
											try
											{
												#if USECOLUMNLOCATIONBINDING
												newRow[((UpdateColumnNode)Nodes[index]).ColumnLocation] = objectValue;
												#else
												newRow[((UpdateColumnNode)Nodes[index]).ColumnName] = objectValue;
												#endif
											}
											finally
											{
												DataValue.DisposeValue(program.ValueManager, objectValue);
											}
										}
									}
									finally
									{
										program.Stack.Pop();
									}
									
									#if USEUPDATEVALUEFLAGS
									table.Update(newRow, valueFlags, Unchecked);
									#else
									table.Update(newRow, null, Unchecked);
									#endif
										
									if (!table.Next())
										break;
								}
							}
							
							return null;
						}
						finally
						{
							newRow.Dispose();
						}
					}
					finally
					{
						oldRow.Dispose();
					}
				}
			}
			
			return null;
		}
		
		public override Statement EmitStatement(EmitMode mode)
		{
			UpdateStatement statement = new UpdateStatement();
			statement.Modifiers = Modifiers;
			statement.Target = (Expression)_targetNode.EmitStatement(mode);
			if (_conditionNode != null)
				statement.Condition = (Expression)_conditionNode.EmitStatement(mode);
			Schema.TableType dataType = (Schema.TableType)Nodes[0].DataType;
			UpdateColumnNode node;
			for (int index = 1; index < Nodes.Count; index++)
			{
				node = (UpdateColumnNode)Nodes[index];
				#if USECOLUMNLOCATIONBINDING
				statement.Columns.Add(new UpdateColumnExpression(new IdentifierExpression(dataType.Columns[node.ColumnLocation].Name), (Expression)node.Nodes[0].EmitStatement(AMode)));
				#else
				statement.Columns.Add(new UpdateColumnExpression(new IdentifierExpression(node.ColumnName), (Expression)node.Nodes[0].EmitStatement(mode)));
				#endif
			}
			return statement;
		}
    }
    
    public class UpdateRowNode : DMLNode
    {
		private bool _isGeneric;
		public bool IsGeneric { get { return _isGeneric; } }
		
		private UpdateColumnExpressions _columnExpressions = new UpdateColumnExpressions();
		public UpdateColumnExpressions ColumnExpressions { get { return _columnExpressions; } }
		
		public override void DetermineDataType(Plan plan)
		{
			DetermineModifiers(plan);
			if (!Nodes[0].DataType.IsGeneric)
			{
				plan.EnterRowContext();
				try
				{
					plan.Symbols.Push(new Symbol(String.Empty, Nodes[0].DataType));
					try
					{
						foreach (UpdateColumnExpression expression in _columnExpressions)
							Nodes.Add(Compiler.CompileUpdateColumnExpression(plan, expression));
					}
					finally
					{
						plan.Symbols.Pop();
					}
				}
				finally
				{
					plan.ExitRowContext();
				}
			}
			else
			{
				_isGeneric = true;
				foreach (UpdateColumnExpression expression in _columnExpressions)
					Nodes.Add(Compiler.CompileExpression(plan, expression.Expression));
			}
		}

		protected override void InternalBindingTraversal(Plan plan, PlanNodeVisitor visitor)
		{
			if (!_isGeneric)
			{
				#if USEVISIT
				Nodes[0] = visitor.Visit(plan, Nodes[0]);
				#else
				Nodes[0].BindingTraversal(plan, visitor);
				#endif
				plan.EnterRowContext();
				try
				{
					plan.Symbols.Push(new Symbol(String.Empty, Nodes[0].DataType));
					try
					{
						for (int index = 1; index < Nodes.Count; index++)
							#if USEVISIT
							Nodes[index] = visitor.Visit(plan, Nodes[index]);
							#else
							Nodes[index].BindingTraversal(plan, visitor);
							#endif
					}
					finally
					{
						plan.Symbols.Pop();
					}
				}
				finally
				{
					plan.ExitRowContext();
				}
			}
			else
				base.InternalBindingTraversal(plan, visitor);
		}

		public override object InternalExecute(Program program)
		{
			if (!IsGeneric)
			{
				IRow target = (IRow)program.Stack.Peek(((StackReferenceNode)Nodes[0]).Location);
				program.Stack.Push(target);
				try
				{
					for (int index = 1; index < Nodes.Count; index++)
					{
						object objectValue = Nodes[index].Execute(program);
						try
						{
							#if USECOLUMNLOCATIONBINDING
							target[((UpdateColumnNode)Nodes[index]).ColumnLocation] = objectValue;
							#else
							target[((UpdateColumnNode)Nodes[index]).ColumnName] = objectValue;
							#endif
						}
						finally
						{
							DataValue.DisposeValue(program.ValueManager, objectValue);
						}
					}
				}
				finally
				{
					program.Stack.Pop();
				}
			}
			else
			{
				IRow target = (IRow)program.Stack.Peek(((StackReferenceNode)Nodes[0]).Location);
				UpdateColumnNode[] columnNodes = new UpdateColumnNode[_columnExpressions.Count];
				program.Plan.EnterRowContext();
				try
				{
					program.Plan.Symbols.Push(new Symbol(String.Empty, target.DataType));
					try
					{
						for (int index = 0; index < _columnExpressions.Count; index++)
							columnNodes[index] = 
								Compiler.EmitUpdateColumnNode
								(
									program.Plan, 
									_columnExpressions[index], 
									new ValueNode
									(
										Nodes[index + 1].DataType, 
										Nodes[index + 1].Execute(program)
									)
								);
					}
					finally
					{
						program.Plan.Symbols.Pop();
					}
				}
				finally
				{
					program.Plan.ExitRowContext();
				}
				
				program.Stack.Push(target);
				try
				{
					for (int index = 0; index < _columnExpressions.Count; index++)
					{
						object objectValue = columnNodes[index].Execute(program);
						try
						{
							target[columnNodes[index].ColumnName] = objectValue;
						}
						finally
						{
							DataValue.DisposeValue(program.ValueManager, objectValue);
						}
					}
				}
				finally
				{
					program.Stack.Pop();
				}
			}
			return null;
		}
		
		public override Statement EmitStatement(EmitMode mode)
		{
			UpdateStatement statement = new UpdateStatement();
			statement.Modifiers = Modifiers;
			statement.Target = (Expression)Nodes[0].EmitStatement(mode);
			Schema.RowType dataType = (Schema.RowType)Nodes[0].DataType;
			statement.Columns.AddRange(_columnExpressions);
			return statement;
		}
    }
    
    public class DeleteNode : DMLNode
    {
		protected override void InternalBindingTraversal(Plan plan, PlanNodeVisitor visitor)
		{
			plan.PushCursorContext(new CursorContext(CursorType.Static, CursorCapability.Navigable | CursorCapability.Updateable, CursorIsolation.Isolated));
			try
			{
				#if USEVISIT
				Nodes[0] = visitor.Visit(plan, Nodes[0]);
				#else
				Nodes[0].BindingTraversal(plan, visitor);
				#endif
				if (!(((TableNode)Nodes[0]).CursorType == CursorType.Static))
				{
					Nodes[0] = Compiler.EmitCopyNode(plan, (TableNode)Nodes[0]);
					plan.PushGlobalContext();
					try
					{
						((TableNode)Nodes[0]).InferPopulateNode(plan);
						Nodes[0].DeterminePotentialDevice(plan);
						Nodes[0].DetermineDevice(plan);
						Nodes[0].DetermineAccessPath(plan);
					}
					finally
					{
						plan.PopGlobalContext();
					}
				}
			}
			finally
			{
				plan.PopCursorContext();
			}
		}
		
		public override void BindToProcess(Plan plan)
		{
			plan.PushStatementContext(new StatementContext(StatementType.Delete));
			try
			{
				plan.PushCursorContext(new CursorContext(CursorType.Static, CursorCapability.Navigable | CursorCapability.Updateable, CursorIsolation.Isolated));
				try
				{
					Nodes[0].BindToProcess(plan);
				}
				finally
				{
					plan.PopCursorContext();
				}
			}
			finally
			{
				plan.PopStatementContext();
			}
		}
		
		public override object InternalExecute(Program program)
		{
			if (program.ServerProcess.IsReconciliationEnabled())
			{
				// Open a table for the expression
				// delete all the rows
				using (ITable table = (ITable)Nodes[0].Execute(program))
				{
					if (table.Next())
					{
						while (true)
						{
							table.Delete(Unchecked);
							if (table.CursorType == CursorType.Static)
								table.Next();
								
							if (table.EOF())
								break;
						}
					}
					
					return null;
				}
			}
			
			return null;
		}
		
		public override Statement EmitStatement(EmitMode mode)
		{
			DeleteStatement statement = new DeleteStatement();
			statement.Modifiers = Modifiers;
			statement.Target = (Expression)Nodes[0].EmitStatement(mode);
			return statement;
		}
    }

    public class TableSelectorNode : TableNode
    {
		public TableSelectorNode(Schema.ITableType dataType) : base()
		{
			_dataType = dataType;
			_tableVar = new Schema.ResultTableVar(this);
		}
		
		public override void DetermineCharacteristics(Plan plan)
		{
			IsLiteral = true;
			IsFunctional = true;
			IsDeterministic = true;
			IsRepeatable = true;
			for (int index = 0; index < NodeCount; index++)
			{
				IsLiteral = IsLiteral && Nodes[index].IsLiteral;
				IsFunctional = IsFunctional && Nodes[index].IsFunctional;
				IsDeterministic = IsDeterministic && Nodes[index].IsDeterministic;
				IsRepeatable = IsRepeatable && Nodes[index].IsRepeatable;
			} 
			_tableVar.DetermineRemotable(plan.CatalogDeviceSession);
			_tableVar.Owner = plan.User;
			if (Order == null)
				Order = Compiler.OrderFromKey(plan, Compiler.FindClusteringKey(plan, _tableVar));
		}
		
		public override void DetermineCursorBehavior(Plan plan)
		{
			_cursorType = CursorType.Static;
			_requestedCursorType = plan.CursorContext.CursorType;
			_cursorCapabilities = CursorCapability.Navigable | CursorCapability.BackwardsNavigable | CursorCapability.Searchable | CursorCapability.Bookmarkable | (plan.CursorContext.CursorCapabilities & CursorCapability.Elaborable);
			_cursorIsolation = CursorIsolation.None;
			Order = Compiler.OrderFromKey(plan, Compiler.FindClusteringKey(plan, _tableVar));
		}
		
		public override object InternalExecute(Program program)
		{
			LocalTable table = new LocalTable(this, program);
			try
			{
				table.Open();
				// Insert each row from the arguments into this new table
				for (int index = 0; index < NodeCount; index++)
				{
					IRow row = (IRow)Nodes[index].Execute(program);
					try
					{
						table._nativeTable.Insert(program.ValueManager, row); // Insert directly into the native table value to avoid the updatable capability check
					}
					finally
					{
						row.Dispose();
					}
				}

				table.First();
				return table;
			}
			catch
			{
				table.Dispose();
				throw;
			}
		}
		
		public override Statement EmitStatement(EmitMode mode)
		{
			if (_dataType is Schema.ITableType)
			{
				TableSelectorExpression expression = new TableSelectorExpression();
				expression.TypeSpecifier = DataType.EmitSpecifier(mode);
				for (int index = 0; index < NodeCount; index++)
					expression.Expressions.Add(Nodes[index].EmitStatement(mode));
				expression.Modifiers = Modifiers;
				foreach (Schema.Key key in TableVar.Keys)
					if (key.Columns.Count < TableVar.Columns.Count)
						expression.Keys.Add(key.EmitStatement(mode));
				return expression;
			}
			else
			{
				PresentationSelectorExpression expression = new PresentationSelectorExpression();
				expression.TypeSpecifier = DataType.EmitSpecifier(mode);
				for (int index = 0; index < NodeCount; index++)
					expression.Expressions.Add(Nodes[index].EmitStatement(mode));
				expression.Modifiers = Modifiers;
				foreach (Schema.Key key in TableVar.Keys)
					if (key.Columns.Count < TableVar.Columns.Count)
						expression.Keys.Add(key.EmitStatement(mode));
				return expression;
			}
		}
    }
    
	// Internal instruction to convert a table opened from a TableNode.Execute to a TableValue
    public class TableToTableValueNode : PlanNode
    {
		public TableToTableValueNode() : base()
		{
			IgnoreUnsupported = true;
		}
		
		public TableToTableValueNode(TableNode sourceNode) : base()
		{
			IgnoreUnsupported = true;
			Nodes.Add(sourceNode);
		}
		
		public TableNode SourceNode { get { return (TableNode)Nodes[0]; } }
		
		public override void DetermineCharacteristics(Plan plan)
		{
			IsLiteral = SourceNode.IsLiteral;
			IsFunctional = SourceNode.IsFunctional;
			IsDeterministic = SourceNode.IsDeterministic;
			IsRepeatable = SourceNode.IsRepeatable;
			IsNilable = SourceNode.IsLiteral;
		}
		
		public override void DetermineDataType(Plan plan)
		{
			DetermineModifiers(plan);
			_dataType = SourceNode.DataType;
		}

		public override object InternalExecute(Program program)
		{	
			ITable table = (ITable)SourceNode.Execute(program);
			table.Open();
			try
			{
				return new TableValue(program.ValueManager, table.DataType, (NativeTable)table.CopyNative());
			}
			finally
			{
				table.Dispose();
			}
		}
		
		public override Statement EmitStatement(EmitMode mode)
		{
			return SourceNode.EmitStatement(mode);
		}
    }
    
    // Internal instruction to convert a TableValue returned from a non-TableNode.Execute to a Table
    public class TableValueToTableNode : TableNode
    {
		public TableValueToTableNode() : base() {}
		
		public override void DetermineCharacteristics(Plan plan)
		{
			IsLiteral = Nodes[0].IsLiteral;
			IsFunctional = Nodes[0].IsFunctional;
			IsDeterministic = Nodes[0].IsDeterministic;
			IsRepeatable = Nodes[0].IsRepeatable;
			IsNilable = Nodes[0].IsLiteral;
		}
		
		public override void DetermineDataType(Plan plan)
		{
			DetermineModifiers(plan);
			_dataType = Nodes[0].DataType;
			TableVar = new Schema.ResultTableVar(this);
			_tableVar.Owner = plan.User;
			TableVar.EnsureTableVarColumns();

			// If the source node has a Modifier named KeyInfo, compile it into a key for the table var.
			if (Nodes[0].Modifiers != null)
			{
				var keyDefinition = LanguageModifiers.GetModifier(Nodes[0].Modifiers, "KeyInfo", String.Empty);
				if (!String.IsNullOrEmpty(keyDefinition))
				{
					_tableVar.Keys.Add(Compiler.CompileKeyDefinition(plan, _tableVar, new Parser().ParseKeyDefinition(keyDefinition)));
				}
			}

			Compiler.EnsureKey(plan, TableVar);
		}

		public override void DetermineCursorBehavior(Plan plan)
		{
			_cursorType = CursorType.Static;
			_requestedCursorType = plan.CursorContext.CursorType;
			_cursorCapabilities = CursorCapability.Navigable | CursorCapability.BackwardsNavigable | CursorCapability.Searchable | CursorCapability.Bookmarkable | (plan.CursorContext.CursorCapabilities & CursorCapability.Elaborable);
			if (Nodes[0] is StackReferenceNode)
				_cursorCapabilities |= CursorCapability.Updateable;
			_cursorIsolation = CursorIsolation.None;
			Order = Compiler.FindClusteringOrder(plan, _tableVar);
		}
		
		public override object InternalExecute(Program program)
		{
			TableScan table = new TableValueScan(this, (TableValue)Nodes[0].Execute(program));
			table.Open();
			return table;
		}
		
		public override Statement EmitStatement(EmitMode mode)
		{
			return Nodes[0].EmitStatement(mode);
		}
		
		protected NativeTable GetNativeTable(Program program)
		{
			StackReferenceNode node = Nodes[0] as StackReferenceNode;
			if (node != null)
			{
				TableValue tableValue = program.Stack.Peek(node.Location) as TableValue;
				if (tableValue != null)
					return tableValue.AsNative as NativeTable;
			}
			return null;
		}

		// TODO: Revisit update semantics here. Why are we updating what should be an rvalue?		
		protected override void InternalExecuteInsert(Program program, IRow oldRow, IRow newRow, BitArray valueFlags, bool uncheckedValue)
		{
			NativeTable nativeTable = GetNativeTable(program);
			if (nativeTable != null)
				nativeTable.Insert(program.ValueManager, newRow);
			else
				base.InternalExecuteInsert(program, oldRow, newRow, valueFlags, uncheckedValue);
		}
		
		protected override void InternalExecuteUpdate(Program program, IRow oldRow, IRow newRow, BitArray valueFlags, bool checkConcurrency, bool uncheckedValue)
		{
		
			NativeTable nativeTable = GetNativeTable(program);
			if (nativeTable != null)
				nativeTable.Update(program.ValueManager, oldRow, newRow);
			else
				base.InternalExecuteUpdate(program, oldRow, newRow, valueFlags, checkConcurrency, uncheckedValue);
		}
		
		protected override void InternalExecuteDelete(Program program, IRow row, bool checkConcurrency, bool uncheckedValue)
		{
			NativeTable nativeTable = GetNativeTable(program);
			if (nativeTable != null)
				nativeTable.Delete(program.ValueManager, row);
			else
				base.InternalExecuteDelete(program, row, checkConcurrency, uncheckedValue);
		}
    }
    
    public abstract class TableVarNode : TableNode
    {
		public TableVarNode() : base(){}
		public TableVarNode(Schema.TableVar tableVar) : base()
		{
			_tableVar = tableVar;
		}
		
		public override void DetermineCharacteristics(Plan plan)
		{
			IsLiteral = false;
			IsFunctional = true;
			IsDeterministic = true;
			IsRepeatable = true;
			_tableVar.DetermineRemotable(plan.CatalogDeviceSession);

			/*
			 * BTR 10/30/2009 -> This is totally wrong to do to a catalog table variable, 
			 * it is changing the definition of a catalog object as a result of it being 
			 * referenced in an expression. Ouch. The same code is properly present on the 
			 * UnaryTableNode, so I believe this was copied here just for consistency, rather 
			 * than to actually implement a feature, so I am okay with commenting it out. If a 
			 * defect is discovered, we will have to come up with something then, but this is 
			 * just plain wrong.
			bool LIsNilable = (PropagateInsert == PropagateAction.False || !PropagateUpdate);
			
			if (LIsNilable)
				foreach (Schema.TableVarColumn LColumn in TableVar.Columns)
					LColumn.IsNilable = LIsNilable;
			*/
		}
		
		public virtual void DetermineVariableProperties(Plan plan)
		{
			switch (plan.StatementContext.StatementType)
			{
				case StatementType.Insert : 
				case StatementType.Update :
				case StatementType.Delete :
				case StatementType.Assignment :
					if (_tableVar.IsConstant)
						throw new CompilerException(CompilerException.Codes.ConstantObjectCannotBeAssigned, plan.CurrentStatement(), _tableVar.DisplayName);
					_tableVar.IsModified = true;
				break;
			}
		}
		
		public virtual void DetermineRights(Plan plan)
		{
			_insertRight = null;
			_updateRight = null;
			_deleteRight = null;
			
			_hasInsertRight = false;
			_hasUpdateRight = false;
			_hasDeleteRight = false;
			
			Schema.TableVar tableVar = null;
			if (_tableVar.IsATObject)
			{
				int catalogIndex = plan.Catalog.IndexOfName(_tableVar.SourceTableName);
				if (catalogIndex >= 0)
					tableVar = (Schema.TableVar)plan.Catalog[catalogIndex];
			}
			else
				tableVar = _tableVar;
				
			if (tableVar != null)
			{
				_insertRight = tableVar.GetRight(Schema.RightNames.Insert);
				_updateRight = tableVar.GetRight(Schema.RightNames.Update);
				_deleteRight = tableVar.GetRight(Schema.RightNames.Delete);
				
				switch (plan.StatementContext.StatementType)
				{
					case StatementType.Select : 
						plan.CheckRight(tableVar.GetRight(Schema.RightNames.Select));
						if ((plan.CursorContext.CursorCapabilities & CursorCapability.Updateable) != 0)
						{
							_hasInsertRight = plan.HasRight(_insertRight);
							_hasUpdateRight = plan.HasRight(_updateRight);
							_hasDeleteRight = plan.HasRight(_deleteRight);
						}
					break;
					case StatementType.Insert : 
						plan.CheckRight(_insertRight); 
						_hasInsertRight = true;
						_hasUpdateRight = plan.HasRight(_updateRight);
						_hasDeleteRight = plan.HasRight(_deleteRight);
					break;
					
					case StatementType.Update : 
						plan.CheckRight(_updateRight); 
						_hasInsertRight = plan.HasRight(_insertRight);
						_hasUpdateRight = true;
						_hasDeleteRight = plan.HasRight(_deleteRight);
					break;

					case StatementType.Delete : 
						plan.CheckRight(_deleteRight); 
						_hasInsertRight = plan.HasRight(_insertRight);
						_hasUpdateRight = plan.HasRight(_updateRight);
						_hasDeleteRight = true;
					break;
					
					case StatementType.Assignment : 
						plan.CheckRight(_deleteRight);
						plan.CheckRight(_insertRight);
						_hasDeleteRight = true;
						_hasUpdateRight = plan.HasRight(_updateRight);
						_hasInsertRight = true;
					break;
				}
			}
			else
			{
				_hasInsertRight = true;
				_hasUpdateRight = true;
				_hasDeleteRight = true;
			}
		}
		
		protected string _insertRight;
		protected string _updateRight;
		protected string _deleteRight;
		
		protected bool _hasInsertRight;
		public bool HasInsertRight
		{
			get { return _hasInsertRight; }
			set { _hasInsertRight = value; }
		}
		
		protected bool _hasUpdateRight;
		public bool HasUpdateRight
		{
			get { return _hasUpdateRight; }
			set { _hasUpdateRight = value; }
		}
		
		protected bool _hasDeleteRight;
		public bool HasDeleteRight
		{
			get { return _hasDeleteRight; }
			set { _hasDeleteRight = value; }
		}
		
		// PropagateInsert
		private PropagateAction _propagateInsert = PropagateAction.True;
		public PropagateAction PropagateInsert
		{
			get { return _propagateInsert; }
			set { _propagateInsert = value; }
		}
		
		// PropagateUpdate
		private bool _propagateUpdate = true;
		public bool PropagateUpdate
		{
			get { return _propagateUpdate; }
			set { _propagateUpdate = value; }
		}
		
		// PropagateDelete
		private bool _propagateDelete = true;
		public bool PropagateDelete
		{
			get { return _propagateDelete; }
			set { _propagateDelete = value; }
		}
		
		// PropagateDefault
		private bool _propagateDefault = true;
		public bool PropagateDefault
		{
			get { return _propagateDefault; }
			set { _propagateDefault = value; }
		}
		
		// PropagateValidate
		private bool _propagateValidate = true;
		public bool PropagateValidate
		{
			get { return _propagateValidate; }
			set { _propagateValidate = value; }
		}
		
		// PropagateChange
		private bool _propagateChange = true;
		public bool PropagateChange
		{
			get { return _propagateChange; }
			set { _propagateChange = value; }
		}
		
		// ShouldTranslate
		private bool _shouldTranslate = true;
		public bool ShouldTranslate
		{
			get { return _shouldTranslate; }
			set { _shouldTranslate = value; }
		}

		protected override void InternalClone(PlanNode newNode)
		{
			base.InternalClone(newNode);

			var newTableVarNode = (TableVarNode)newNode;
			newTableVarNode.PropagateInsert = PropagateInsert;
			newTableVarNode.PropagateUpdate = PropagateUpdate;
			newTableVarNode.PropagateDelete = PropagateDelete;
			newTableVarNode.PropagateDefault = PropagateDefault;
			newTableVarNode.PropagateChange = PropagateChange;
			newTableVarNode.PropagateValidate = PropagateValidate;
			newTableVarNode.ShouldTranslate = ShouldTranslate;
		}
		
		// ShouldValidateKeyConstraints
		protected override bool ShouldValidateKeyConstraints(Schema.Transition transition)
		{
			switch (transition)
			{
				case Schema.Transition.Insert: return (_propagateInsert == PropagateAction.True);
				case Schema.Transition.Update: return _propagateUpdate;
				default: return base.ShouldValidateKeyConstraints(transition);
			}
		}
		
		// Insert
		public override void Insert(Program program, IRow oldRow, IRow newRow, BitArray valueFlags, bool uncheckedValue)
		{
			if (_propagateInsert != PropagateAction.False)
			{
				base.Insert(program, oldRow, newRow, valueFlags, uncheckedValue);
			}
		}

		// Update
		public override void Update(Program program, IRow oldRow, IRow newRow, BitArray valueFlags, bool checkConcurrency, bool uncheckedValue)
		{
			if (_propagateUpdate)
			{
				base.Update(program, oldRow, newRow, valueFlags, checkConcurrency, uncheckedValue);
			}
		}

		// Delete
		public override void Delete(Program program, IRow row, bool checkConcurrency, bool uncheckedValue)
		{
			if (_propagateDelete)
			{
				base.Delete(program, row, checkConcurrency, uncheckedValue);
			}
		}

		// Validate
		public override bool Validate(Program program, IRow oldRow, IRow newRow, BitArray valueFlags, string columnName)
		{
			if (_propagateValidate)
				return base.Validate(program, oldRow, newRow, valueFlags, columnName);
			return false;
		}
		
		// Change
		public override bool Change(Program program, IRow oldRow, IRow newRow, BitArray valueFlags, string columnName)
		{
			if (_propagateChange)
				return base.Change(program, oldRow, newRow, valueFlags, columnName);
			return false;
		}
		
		// Default
		public override bool Default(Program program, IRow oldRow, IRow newRow, BitArray valueFlags, string columnName)
		{
			if (_propagateDefault)
				return base.Default(program, oldRow, newRow, valueFlags, columnName);
			return false;
		}

		protected override void DetermineModifiers(Plan plan)
		{
			base.DetermineModifiers(plan);

			if (Modifiers != null)
			{
				PropagateInsert = (PropagateAction)Enum.Parse(typeof(PropagateAction), LanguageModifiers.GetModifier(Modifiers, "PropagateInsert", PropagateInsert.ToString()), true);
				PropagateUpdate = Boolean.Parse(LanguageModifiers.GetModifier(Modifiers, "PropagateUpdate", PropagateUpdate.ToString()));
				PropagateDelete = Boolean.Parse(LanguageModifiers.GetModifier(Modifiers, "PropagateDelete", PropagateDelete.ToString()));
				PropagateDefault = Boolean.Parse(LanguageModifiers.GetModifier(Modifiers, "PropagateDefault", PropagateDefault.ToString()));
				PropagateValidate = Boolean.Parse(LanguageModifiers.GetModifier(Modifiers, "PropagateValidate", PropagateValidate.ToString()));
				PropagateChange = Boolean.Parse(LanguageModifiers.GetModifier(Modifiers, "PropagateChange", PropagateChange.ToString()));
				ShouldTranslate = Boolean.Parse(LanguageModifiers.GetModifier(Modifiers, "ShouldTranslate", ShouldTranslate.ToString()));
			}
		}
		
		// Default
		protected override bool InternalDefault(Program program, IRow oldRow, IRow newRow, BitArray valueFlags, string columnName, bool isDescending)
		{
			BitArray localValueFlags = newRow.GetValueFlags();
			bool changed = DefaultColumns(program, TableVar, newRow, valueFlags, columnName);
			if (isDescending && changed)
				for (int index = 0; index < newRow.DataType.Columns.Count; index++)
					if (!localValueFlags[index] && newRow.HasValue(index))
						Change(program, oldRow, newRow, valueFlags, newRow.DataType.Columns[index].Name);
			return changed;
		}
		
		// ExplicitBind
		private bool _explicitBind;
		/// <summary>Indicates that this table var node is explicitly bound to the supporting variable for an application transaction and should not be re-bound to the actual table variable when re-compiled as part of a dynamic execution.</summary>
		public bool ExplicitBind
		{
			get { return _explicitBind; }
			set { _explicitBind = value; }
		}
		
		// Statement
		public override Statement EmitStatement(EmitMode mode)
		{
			Expression expression;
			if ((_tableVar.SourceTableName != null) && ((mode == EmitMode.ForRemote) || !_explicitBind))
				expression = new TableIdentifierExpression(Schema.Object.EnsureRooted(_tableVar.SourceTableName));
			else if ((_tableVar.SessionObjectName != null) && (mode != EmitMode.ForRemote))
				expression = new TableIdentifierExpression(Schema.Object.EnsureRooted(_tableVar.SessionObjectName));
			else
				expression = new TableIdentifierExpression(Schema.Object.EnsureRooted(_tableVar.Name));
			expression.Modifiers = Modifiers;
			return expression;
		}
    }
    
    // BaseTableVarNode ->
    //  Represents retrieval of a base table var.  Validation is
    //  all handled by the TableNode.  If the device does not support
    //  modification through statements, this node uses row level
    //  modification on the device.
    //
    // operator iRetrieveTable(scalar) : table{}
    public class BaseTableVarNode : TableVarNode
    {
		public BaseTableVarNode() : base()
		{
			ShouldCheckConcurrency = true;
		}
		
		public BaseTableVarNode(Schema.TableVar tableVar) : base(tableVar)
		{
			ShouldCheckConcurrency = true;
		}
		
        public override Schema.TableVar TableVar 
        { 
			get { return base.TableVar; } 
			set { base.TableVar = value; } 
		}
		
		public override void DetermineDataType(Plan plan)
		{
			DetermineModifiers(plan);
			_dataType = _tableVar.DataType;
			DetermineRights(plan);
			DetermineVariableProperties(plan);
		}
		
		public override void DetermineVariableProperties(Plan plan)
		{
			base.DetermineVariableProperties(plan);
			switch (plan.StatementContext.StatementType)
			{
				case StatementType.Insert : 
				case StatementType.Update :
				case StatementType.Delete :
				case StatementType.Assignment :
					plan.SetIsFunctional(false);
				break;
			}
		}

		public override void DeterminePotentialDevice(Plan plan)
		{
			if (_tableVar is Schema.BaseTableVar)
				_potentialDevice = ((Schema.BaseTableVar)_tableVar).Device;
			else
				throw new CompilerException(CompilerException.Codes.InvalidRetrieveTarget, plan.CurrentStatement());
			NoDevice = !ShouldSupport || _potentialDevice == null;
		}

		public override void DetermineDevice(Plan plan)
		{
			if (_potentialDevice != null)
			{
				_device = _potentialDevice;
				plan.EnsureDeviceStarted(_device);
				Schema.DevicePlan devicePlan = _device.Prepare(plan, this);
				if (!devicePlan.IsSupported)
					throw new RuntimeException(RuntimeException.Codes.NoSupportingDevice, _device.Name, _tableVar.DisplayName);

				DeviceSupported = true;
				SetDevice(plan, _potentialDevice);

				_symbols = Compiler.SnapshotSymbols(plan);
			}
			else
				NoDevice = true;
		}

		public override void SetDevice(Plan plan, Schema.Device device)
		{
			base.SetDevice(plan, device);
			CheckDeviceRights(plan);
			if ((_cursorCapabilities & CursorCapability.Updateable) != 0)
			{
				DetermineModifySupported(plan);
				_symbols = Compiler.SnapshotSymbols(plan);
			}
		}
		
		protected void CheckDeviceRights(Plan plan)
		{
			if ((Device != null) && !_tableVar.IsATObject)
			{
				plan.CheckRight(Device.GetRight(Schema.RightNames.Read));
				if ((_cursorCapabilities & CursorCapability.Updateable) != 0)
					plan.CheckRight(Device.GetRight(Schema.RightNames.Write));
			}
		}
		
		public override void BindToProcess(Plan plan)
		{
			CheckDeviceRights(plan);
			DetermineRights(plan);
			plan.EnsureApplicationTransactionTableVar(_tableVar);
			base.BindToProcess(plan);
		}
		
		// Execute		
		public override object InternalExecute(Program program)
		{
			throw new RuntimeException(RuntimeException.Codes.NoSupportingDevice, _device == null ? "<no device>" : _device.Name, _tableVar == null ? "<no table>" : _tableVar.DisplayName);
		}
		
		protected void InternalInsert(Program program, IRow row, BitArray valueFlags)
		{
			if (!_hasInsertRight)
				throw new ServerException(ServerException.Codes.UnauthorizedRight, ErrorSeverity.Environment, program.Plan.User.ID, _insertRight);
			program.DeviceConnect(_device).InsertRow(program, _tableVar, row, valueFlags);
		}
		
		// Insert
		protected override void InternalExecuteInsert(Program program, IRow oldRow, IRow newRow, BitArray valueFlags, bool uncheckedValue)
		{
			switch (PropagateInsert)
			{
				case PropagateAction.True : 
					InternalInsert(program, newRow, valueFlags); 
				break;
				
				case PropagateAction.Ensure :
				case PropagateAction.Ignore :
					using (Row sourceRow = new Row(program.ValueManager, DataType.RowType))
					{
						newRow.CopyTo(sourceRow);
						using (IRow currentRow = Select(program, sourceRow))
						{
							if (currentRow != null)
							{
								if (PropagateInsert == PropagateAction.Ensure)
									InternalUpdate(program, currentRow, newRow, valueFlags, false);
							}
							else
								InternalInsert(program, newRow, valueFlags);
						}
					}
				break;
			}
		}
		
		protected void InternalUpdate(Program program, IRow oldRow, IRow newRow, BitArray valueFlags, bool checkConcurrency)
		{
			if (!_hasUpdateRight)
				throw new ServerException(ServerException.Codes.UnauthorizedRight, ErrorSeverity.Environment, program.Plan.User.ID, _updateRight);
			program.DeviceConnect(_device).UpdateRow(program, _tableVar, oldRow, newRow, valueFlags);
		}
		
		// Update
		protected override void InternalExecuteUpdate(Program program, IRow oldRow, IRow newRow, BitArray valueFlags, bool checkConcurrency, bool uncheckedValue)
		{
			if (PropagateUpdate)
				InternalUpdate(program, oldRow, newRow, valueFlags, checkConcurrency);
		}
		
		// Delete
		protected override void InternalExecuteDelete(Program program, IRow row, bool checkConcurrency, bool uncheckedValue)
		{
			if (PropagateDelete)
			{
				if (!_hasDeleteRight)
					throw new ServerException(ServerException.Codes.UnauthorizedRight, ErrorSeverity.Environment, program.Plan.User.ID, _deleteRight);
				program.DeviceConnect(_device).DeleteRow(program, _tableVar, row);
			}
		}
		
		private PlanNode _joinATNode;
		
		private void EnsureJoinATNode(Plan plan, Schema.RowType rowType)
		{
			if (_joinATNode == null)
			{
				Schema.RowType keyType = new Schema.RowType(Compiler.FindClusteringKey(plan, _tableVar).Columns);
				plan.Symbols.Push(new Symbol("ATRow", rowType));
				try
				{
					InsertStatement insertStatement =
						new InsertStatement
						(
							new RestrictExpression
							(
								new IdentifierExpression(Schema.Object.EnsureRooted(_tableVar.SourceTableName)), 
								Compiler.BuildKeyEqualExpression
								(
									plan, 
									String.Empty, 
									"ATRow", 
									keyType.Columns,
									keyType.Columns
								)
							), 
							new IdentifierExpression(Schema.Object.EnsureRooted(_tableVar.Name))
						);
						
					insertStatement.Modifiers = new LanguageModifiers();
					insertStatement.Modifiers.Add(new LanguageModifier("Unchecked", "True"));

					Statement statement = 
						new IfStatement
						(
							new UnaryExpression
							(
								Instructions.Not, 
								new UnaryExpression
								(
									Instructions.Exists, 
									new RestrictExpression
									(
										new IdentifierExpression(Schema.Object.EnsureRooted(_tableVar.Name)), 
										Compiler.BuildKeyEqualExpression
										(
											plan, 
											String.Empty, 
											"ATRow", 
											keyType.Columns, 
											keyType.Columns
										)
									)
								)
							), 
							insertStatement,
							null
						);

					ApplicationTransaction transaction = plan.GetApplicationTransaction();
					try
					{
						transaction.PushGlobalContext();
						try
						{
							plan.PushSecurityContext(new SecurityContext(_tableVar.Owner));
							try
							{
								_joinATNode = Compiler.Compile(plan, statement);
								plan.CheckCompiled();
							}
							finally
							{
								plan.PopSecurityContext();
							}
						}
						finally
						{
							transaction.PopGlobalContext();
						}
					}
					finally
					{
						Monitor.Exit(transaction);
					}
				}
				finally
				{
					plan.Symbols.Pop();
				}
			}
		}

		public override void JoinApplicationTransaction(Program program, IRow row) 
		{
			/*
				if this retrieve is from an ATTable
					if not exists (ATTable where KeyColumns = ARow.KeyColumns)
						insert with { Unchecked = "True" } SourceTable where KeyColumns = ARow.KeyColumns into ATTable
			*/
			if (_tableVar.SourceTableName != null)
			{
				EnsureJoinATNode(program.Plan, (Schema.RowType)row.DataType);
				program.Stack.Push(row);
				try
				{
					_joinATNode.Execute(program);
				}
				finally
				{
					program.Stack.Pop();
				}
			}
		}
    }
    
    // DerivedTableVarNode ->
    //  Represents retrieval of a virtual table var.
    //  There is no corresponding operator for this Node, it is used
    //  to ensure that the table type generated for the view maintains the
    //  keys, orders and constraints defined solely on this view.
    public class DerivedTableVarNode : TableVarNode
    {
		public DerivedTableVarNode() : base(){}
		public DerivedTableVarNode(Schema.TableVar tableVar) : base(tableVar){}

		public override void DetermineDataType(Plan plan)
		{
			DetermineModifiers(plan);
			_dataType = _tableVar.DataType;
			DetermineRights(plan);
			DetermineVariableProperties(plan);

			// Compile the invocation expression for the view
			plan.PushSecurityContext(new SecurityContext(_tableVar.Owner));
			try
			{
				plan.PushATCreationContext();
				try
				{
					Nodes.Add(Compiler.CompileExpression(plan, ((Schema.DerivedTableVar)_tableVar).InvocationExpression));
				}
				finally
				{
					plan.PopATCreationContext();
				}
			}
			finally
			{
				plan.PopSecurityContext();
			}
		}
		
		public override void DetermineVariableProperties(Plan plan)
		{
			base.DetermineVariableProperties(plan);
			switch (plan.StatementContext.StatementType)
			{
				case StatementType.Insert : 
				case StatementType.Update :
				case StatementType.Delete :
				case StatementType.Assignment :
					plan.SetIsFunctional(false);
				break;
			}
		}
		
		public override void DetermineCursorBehavior(Plan plan)
		{
			_cursorType = SourceNode.CursorType;
			_requestedCursorType = plan.CursorContext.CursorType;
			_cursorCapabilities = SourceNode.CursorCapabilities;
			if (TableVar.HasHandlers())
				_cursorCapabilities |= CursorCapability.Updateable;
			_cursorIsolation = SourceNode.CursorIsolation;
			if (SourceNode.Order != null)
				Order = CopyOrder(SourceNode.Order);
			else
				Order = null;
		}
		
		public override void BindToProcess(Plan plan)
		{
			DetermineRights(plan);
			plan.EnsureApplicationTransactionTableVar(_tableVar);

			// Binding below the derived table variable should be based on the security context of the view owner
			if (_tableVar.Owner != null)
				plan.PushSecurityContext(new SecurityContext(_tableVar.Owner));
			try
			{
				base.BindToProcess(plan); 
			}
			finally
			{
				if (_tableVar.Owner != null)
					plan.PopSecurityContext();
			}
		}
		
		// DerivedTableVar
		public Schema.DerivedTableVar DerivedTableVar { get { return (Schema.DerivedTableVar)TableVar; } }
		
		// SourceNode
		public TableNode SourceNode { get { return (TableNode)Nodes[0]; } }
		
		// SourceTableType
		public Schema.TableType SourceTableType { get { return (Schema.TableType)SourceNode.DataType; } }
		
		// Default
		protected override bool InternalDefault(Program program, IRow oldRow, IRow newRow, BitArray valueFlags, string columnName, bool isDescending)
		{
			bool changed = false;
			if (isDescending)
				changed = SourceNode.Default(program, oldRow, newRow, valueFlags, columnName);
			return base.InternalDefault(program, oldRow, newRow, valueFlags, columnName, isDescending) || changed;
		}
		
		// Validate
		protected override bool InternalValidate(Program program, IRow oldRow, IRow newRow, BitArray valueFlags, string columnName, bool isDescending, bool isProposable)
		{
			bool changed = false;
			if (isDescending)
				changed = SourceNode.Validate(program, oldRow, newRow, valueFlags, columnName);
			return base.InternalValidate(program, oldRow, newRow, valueFlags, columnName, isDescending, isProposable) || changed;
		}
		
		// Change
		protected override bool InternalChange(Program program, IRow oldRow, IRow newRow, BitArray valueFlags, string columnName)
		{
			return SourceNode.Change(program, oldRow, newRow, valueFlags, columnName);
		}
		
		// Insert
		protected void InternalInsert(Program program, IRow oldRow, IRow newRow, BitArray valueFlags, bool uncheckedValue)
		{
			if (!_hasInsertRight)
				throw new ServerException(ServerException.Codes.UnauthorizedRight, ErrorSeverity.Environment, program.Plan.User.ID, _insertRight);
			SourceNode.Insert(program, oldRow, newRow, valueFlags, uncheckedValue);
		}
		
		protected override void InternalExecuteInsert(Program program, IRow oldRow, IRow newRow, BitArray valueFlags, bool uncheckedValue)
		{
			switch (PropagateInsert)
			{
				case PropagateAction.True : 
					InternalInsert(program, oldRow, newRow, valueFlags, uncheckedValue);
				break;

				case PropagateAction.Ensure :
				case PropagateAction.Ignore :
					using (Row sourceRow = new Row(program.ValueManager, SourceNode.DataType.RowType))
					{
						newRow.CopyTo(sourceRow);
						using (IRow currentRow = SourceNode.Select(program, sourceRow))
						{
							if (currentRow != null)
							{
								if (PropagateInsert == PropagateAction.Ensure)
									InternalUpdate(program, currentRow, newRow, valueFlags, false, uncheckedValue);
							}
							else
								InternalInsert(program, oldRow, newRow, valueFlags, uncheckedValue);
						}
					}
				break;
			}
		}
		
		// Update
		protected void InternalUpdate(Program program, IRow oldRow, IRow newRow, BitArray valueFlags, bool checkConcurrency, bool uncheckedValue)
		{
			if (!_hasUpdateRight)
				throw new ServerException(ServerException.Codes.UnauthorizedRight, ErrorSeverity.Environment, program.Plan.User.ID, _updateRight);
			SourceNode.Update(program, oldRow, newRow, valueFlags, checkConcurrency, uncheckedValue);
		}
		
		protected override void InternalExecuteUpdate(Program program, IRow oldRow, IRow newRow, BitArray valueFlags, bool checkConcurrency, bool uncheckedValue)
		{
			if (PropagateUpdate)
				InternalUpdate(program, oldRow, newRow, valueFlags, checkConcurrency, uncheckedValue);
		}
		
		// Delete
		protected override void InternalExecuteDelete(Program program, IRow row, bool checkConcurrency, bool uncheckedValue)
		{
			if (PropagateDelete)
			{
				if (!_hasDeleteRight)
					throw new ServerException(ServerException.Codes.UnauthorizedRight, ErrorSeverity.Environment, program.Plan.User.ID, _deleteRight);
				SourceNode.Delete(program, row, checkConcurrency, uncheckedValue);
			}
		}
		
		public override object InternalExecute(Program program)
		{
			return Nodes[0].Execute(program);
		}

		public override void JoinApplicationTransaction(Program program, IRow row) 
		{
			SourceNode.JoinApplicationTransaction(program, row);
		}
    }
    
    public abstract class UnaryTableNode : TableNode
    {
		// SourceNode
		public TableNode SourceNode { get { return (TableNode)Nodes[0]; } }
		
		// SourceTableVar
		public Schema.TableVar SourceTableVar { get { return SourceNode.TableVar; } }
		
		// SourceTableType
		public Schema.ITableType SourceTableType { get { return SourceNode.DataType; } }
		
		// PropagateInsert
		private PropagateAction _propagateInsert = PropagateAction.True;
		public PropagateAction PropagateInsert
		{
			get { return _propagateInsert; }
			set { _propagateInsert = value; }
		}
		
		// PropagateUpdate
		private bool _propagateUpdate = true;
		public bool PropagateUpdate
		{
			get { return _propagateUpdate; }
			set { _propagateUpdate = value; }
		}
		
		// PropagateDelete
		private bool _propagateDelete = true;
		public bool PropagateDelete
		{
			get { return _propagateDelete; }
			set { _propagateDelete = value; }
		}
		
		// PropagateDefault
		private bool _propagateDefault = true;
		public bool PropagateDefault
		{
			get { return _propagateDefault; }
			set { _propagateDefault = value; }
		}
		
		// PropagateValidate
		private bool _propagateValidate = true;
		public bool PropagateValidate
		{
			get { return _propagateValidate; }
			set { _propagateValidate = value; }
		}
		
		// PropagateChange
		private bool _propagateChange = true;
		public bool PropagateChange
		{
			get { return _propagateChange; }
			set { _propagateChange = value; }
		}
		
		// ShouldTranslate
		private bool _shouldTranslate = true;
		public bool ShouldTranslate
		{
			get { return _shouldTranslate; }
			set { _shouldTranslate = value; }
		}
		
		protected override void DetermineModifiers(Plan plan)
		{
			base.DetermineModifiers(plan);

			if (Modifiers != null)
			{
				PropagateInsert = (PropagateAction)Enum.Parse(typeof(PropagateAction), LanguageModifiers.GetModifier(Modifiers, "PropagateInsert", PropagateInsert.ToString()), true);
				PropagateUpdate = Boolean.Parse(LanguageModifiers.GetModifier(Modifiers, "PropagateUpdate", PropagateUpdate.ToString()));
				PropagateDelete = Boolean.Parse(LanguageModifiers.GetModifier(Modifiers, "PropagateDelete", PropagateDelete.ToString()));
				PropagateDefault = Boolean.Parse(LanguageModifiers.GetModifier(Modifiers, "PropagateDefault", PropagateDefault.ToString()));
				PropagateValidate = Boolean.Parse(LanguageModifiers.GetModifier(Modifiers, "PropagateValidate", PropagateValidate.ToString()));
				PropagateChange = Boolean.Parse(LanguageModifiers.GetModifier(Modifiers, "PropagateChange", PropagateChange.ToString()));
				ShouldTranslate = Boolean.Parse(LanguageModifiers.GetModifier(Modifiers, "ShouldTranslate", ShouldTranslate.ToString()));
			}
		}
		
		protected override void InternalClone(PlanNode newNode)
		{
			base.InternalClone(newNode);

			var newUnaryTableNode = (UnaryTableNode)newNode;
			newUnaryTableNode.PropagateInsert = PropagateInsert;
			newUnaryTableNode.PropagateUpdate = PropagateUpdate;
			newUnaryTableNode.PropagateDelete = PropagateDelete;
			newUnaryTableNode.PropagateDefault = PropagateDefault;
			newUnaryTableNode.PropagateChange = PropagateChange;
			newUnaryTableNode.PropagateValidate = PropagateValidate;
			newUnaryTableNode.ShouldTranslate = ShouldTranslate;
		}
		
		public override void DetermineCharacteristics(Plan plan)
		{
			base.DetermineCharacteristics(plan);

			bool isNilable = (PropagateInsert == PropagateAction.False || !PropagateUpdate);
			
			if (isNilable)
				foreach (Schema.TableVarColumn column in TableVar.Columns)
					column.IsNilable = isNilable;
		}
		
		public override void DetermineRemotable(Plan plan)
		{
			Schema.ResultTableVar tableVar = (Schema.ResultTableVar)TableVar;
			tableVar.InferredIsDefaultRemotable = !PropagateDefault || SourceTableVar.IsDefaultRemotable;
			tableVar.InferredIsChangeRemotable = !PropagateChange || SourceTableVar.IsChangeRemotable;
			tableVar.InferredIsValidateRemotable = !PropagateValidate || SourceTableVar.IsValidateRemotable;
			base.DetermineRemotable(plan);
			
			tableVar.ShouldChange = PropagateChange && (tableVar.ShouldChange || SourceTableVar.ShouldChange);
			tableVar.ShouldDefault = PropagateDefault && (tableVar.ShouldDefault || SourceTableVar.ShouldDefault);
			tableVar.ShouldValidate = PropagateValidate && (tableVar.ShouldValidate || SourceTableVar.ShouldValidate);
			
			foreach (Schema.TableVarColumn column in tableVar.Columns)
			{
				int sourceColumnIndex = SourceTableVar.Columns.IndexOfName(column.Name);
				if (sourceColumnIndex >= 0)
				{
					Schema.TableVarColumn sourceColumn = SourceTableVar.Columns[sourceColumnIndex];

					column.ShouldChange = PropagateChange && (column.ShouldChange || sourceColumn.ShouldChange);
					tableVar.ShouldChange = tableVar.ShouldChange || column.ShouldChange;

					column.ShouldDefault = PropagateDefault && (column.ShouldDefault || sourceColumn.ShouldDefault);
					tableVar.ShouldDefault = tableVar.ShouldDefault || column.ShouldDefault;

					column.ShouldValidate = PropagateValidate && (column.ShouldValidate || sourceColumn.ShouldValidate);
					tableVar.ShouldValidate = tableVar.ShouldValidate || column.ShouldValidate;
				}
			}
		}
		
		// Default
		protected override bool InternalDefault(Program program, IRow oldRow, IRow newRow, BitArray valueFlags, string columnName, bool isDescending)
		{
			if (isDescending && PropagateDefault)
				return SourceNode.Default(program, oldRow, newRow, valueFlags, columnName);
			return base.InternalDefault(program, oldRow, newRow, valueFlags, columnName, isDescending);
		}
		
		// Change
		protected override bool InternalChange(Program program, IRow oldRow, IRow newRow, BitArray valueFlags, string columnName)
		{
			if (PropagateChange)
				return SourceNode.Change(program, oldRow, newRow, valueFlags, columnName);
			return base.InternalChange(program, oldRow, newRow, valueFlags, columnName);
		}
		
		// Validate
		protected override bool InternalValidate(Program program, IRow oldRow, IRow newRow, BitArray valueFlags, string columnName, bool isDescending, bool isProposable)
		{
			if (isDescending && PropagateValidate)
				return SourceNode.Validate(program, oldRow, newRow, valueFlags, columnName);
			return base.InternalValidate(program, oldRow, newRow, valueFlags, columnName, isDescending, isProposable);
		}

		// Insert
		protected override void InternalExecuteInsert(Program program, IRow oldRow, IRow newRow, BitArray valueFlags, bool uncheckedValue)
		{
			switch (PropagateInsert)
			{
				case PropagateAction.True : 
					SourceNode.Insert(program, oldRow, newRow, valueFlags, uncheckedValue); 
				break;

				case PropagateAction.Ensure :
				case PropagateAction.Ignore :
					using (Row sourceRow = new Row(program.ValueManager, SourceNode.DataType.RowType))
					{
						newRow.CopyTo(sourceRow);
						using (IRow currentRow = SourceNode.Select(program, sourceRow))
						{
							if (currentRow != null)
							{
								if (PropagateInsert == PropagateAction.Ensure)
									SourceNode.Update(program, currentRow, newRow, valueFlags, false, uncheckedValue);
							}
							else
								SourceNode.Insert(program, oldRow, newRow, valueFlags, uncheckedValue);
						}
					}
				break;
			}
		}
		
		// Update
		protected override void InternalExecuteUpdate(Program program, IRow oldRow, IRow newRow, BitArray valueFlags, bool checkConcurrency, bool uncheckedValue)
		{
			if (PropagateUpdate)
				SourceNode.Update(program, oldRow, newRow, valueFlags, checkConcurrency, uncheckedValue);
		}
		
		// Delete
		protected override void InternalExecuteDelete(Program program, IRow row, bool checkConcurrency, bool uncheckedValue)
		{
			if (PropagateDelete)
				SourceNode.Delete(program, row, checkConcurrency, uncheckedValue);
		}
		
		public override void JoinApplicationTransaction(Program program, IRow row) 
		{
			SourceNode.JoinApplicationTransaction(program, row);
		}
	}
	
	// operator iOn(object)	: table{}
	public class OnNode : TableNode
	{
		protected OnExpression _onExpression;
		public OnExpression OnExpression
		{
			get { return _onExpression; }
			set { _onExpression = value; }
		}
		
		protected Schema.ServerLink _serverLink;
		public Schema.ServerLink ServerLink
		{
			get { return _serverLink; }
			set { _serverLink = value; }
		}
		
		protected string _expression;
		public string Expression
		{
			get
			{
				return _expression;
			}
		}
		
		public override void DetermineDataType(Plan plan)
		{
			DetermineModifiers(plan);
			
			// OnNode data type is copied, not reference because the plan is volatile.
			Schema.Object objectValue = Compiler.ResolveCatalogIdentifier(plan, _onExpression.ServerName);
			if (objectValue == null)
				throw new CompilerException(CompilerException.Codes.UnknownIdentifier, _onExpression, _onExpression.ServerName);
				
			if (!(objectValue is Schema.ServerLink))
				throw new CompilerException(CompilerException.Codes.ServerLinkExpected, _onExpression);
				
			_serverLink = (Schema.ServerLink)objectValue;
			
			CursorDefinition cursorDefinition = _onExpression.Expression as CursorDefinition;
			if (cursorDefinition == null)
				cursorDefinition = new CursorDefinition(_onExpression.Expression);
			_expression = new D4TextEmitter().Emit(new SelectStatement(cursorDefinition));
			Schema.TableVar tableVar = plan.RemoteConnect(_serverLink).PrepareTableVar(plan, _expression, new DataParams());
			
			_dataType = new Schema.TableType();
			_tableVar = new Schema.ResultTableVar(this);
			_tableVar.Owner = plan.User;
			_tableVar.InheritMetaData(tableVar.MetaData);
			CopyTableVarColumns(tableVar.Columns);
			CopyKeys(tableVar.Keys);
			CopyOrders(tableVar.Orders);
			_tableVar.IsRemotable = false;
		}
		
		public override void DeterminePotentialDevice(Plan plan)
		{
			NoDevice = true;
		}

		public override Statement EmitStatement(EmitMode mode)
		{
			Statement result;

			if (mode == EmitMode.ForRemote)
			{
				// Emit an empty typed table selector
				var tableSelector = new TableSelectorExpression();
				tableSelector.TypeSpecifier = _dataType.EmitSpecifier(mode);
				foreach (var key in _tableVar.Keys)
				{
					tableSelector.Keys.Add(key.EmitStatement(mode));
				}

				result = tableSelector;

				// Adorn orders if necessary
				if (_tableVar.Orders.Count > 0)
				{
					var adornExpression = new AdornExpression();
					adornExpression.Expression = tableSelector;

					foreach (var order in _tableVar.Orders)
					{
						adornExpression.Orders.Add(order.EmitStatement(mode));
					}

					result = adornExpression;
				}
			}
			else
			{
				result = _onExpression;
			}

			return result;
		}
		
		public override object InternalExecute(Program program)
		{
			LocalTable table = new LocalTable(this, program, (TableValue)program.RemoteConnect(_serverLink).Evaluate(_expression, new DataParams()));
			try
			{
				table.Open();
				return table;
			}
			catch
			{
				table.Dispose();
				throw;
			}
		}
	}
	
	public abstract class BinaryTableNode : TableNode
	{
		// LeftNode
		public TableNode LeftNode { get { return (TableNode)Nodes[0]; } }
		
		// LeftTableVar
		public Schema.TableVar LeftTableVar { get { return LeftNode.TableVar; } }
		
		// LeftTableType
		public Schema.TableType LeftTableType { get { return (Schema.TableType)LeftNode.DataType; } }
		
		// RightNode
		public TableNode RightNode { get { return (TableNode)Nodes[1]; } }
		
		// RightTableVar
		public Schema.TableVar RightTableVar { get { return RightNode.TableVar; } }
		
		// RightTableType
		public Schema.TableType RightTableType { get { return (Schema.TableType)RightNode.DataType; } }

		// PropagateInsertLeft
		private PropagateAction _propagateInsertLeft = PropagateAction.True;
		public PropagateAction PropagateInsertLeft
		{
			get { return _propagateInsertLeft; }
			set { _propagateInsertLeft = value; }
		}
		
		// PropagateUpdateLeft
		private bool _propagateUpdateLeft = true;
		public bool PropagateUpdateLeft
		{
			get { return _propagateUpdateLeft; }
			set { _propagateUpdateLeft = value; }
		}
		
		// PropagateDeleteLeft
		private bool _propagateDeleteLeft = true;
		public bool PropagateDeleteLeft
		{
			get { return _propagateDeleteLeft; }
			set { _propagateDeleteLeft = value; }
		}
		
		// PropagateDefaultLeft
		private bool _propagateDefaultLeft = true;
		public bool PropagateDefaultLeft
		{
			get { return _propagateDefaultLeft; }
			set { _propagateDefaultLeft = value; }
		}
		
		// PropagateValidateLeft
		private bool _propagateValidateLeft = true;
		public bool PropagateValidateLeft
		{
			get { return _propagateValidateLeft; }
			set { _propagateValidateLeft = value; }
		}
		
		// PropagateChangeLeft
		private bool _propagateChangeLeft = true;
		public bool PropagateChangeLeft
		{
			get { return _propagateChangeLeft; }
			set { _propagateChangeLeft = value; }
		}
		
		// ShouldTranslateLeft
		private bool _shouldTranslateLeft = true;
		public bool ShouldTranslateLeft
		{
			get { return _shouldTranslateLeft; }
			set { _shouldTranslateLeft = value; }
		}
		
		// PropagateInsertRight
		private PropagateAction _propagateInsertRight = PropagateAction.True;
		public PropagateAction PropagateInsertRight
		{
			get { return _propagateInsertRight; }
			set { _propagateInsertRight = value; }
		}
		
		// PropagateUpdateRight
		private bool _propagateUpdateRight = true;
		public bool PropagateUpdateRight
		{
			get { return _propagateUpdateRight; }
			set { _propagateUpdateRight = value; }
		}
		
		// PropagateDeleteRight
		private bool _propagateDeleteRight = true;
		public bool PropagateDeleteRight
		{
			get { return _propagateDeleteRight; }
			set { _propagateDeleteRight = value; }
		}
		
		// PropagateDefaultRight
		private bool _propagateDefaultRight = true;
		public bool PropagateDefaultRight
		{
			get { return _propagateDefaultRight; }
			set { _propagateDefaultRight = value; }
		}
		
		// PropagateValidateRight
		private bool _propagateValidateRight = true;
		public bool PropagateValidateRight
		{
			get { return _propagateValidateRight; }
			set { _propagateValidateRight = value; }
		}
		
		// PropagateChangeRight
		private bool _propagateChangeRight = true;
		public bool PropagateChangeRight
		{
			get { return _propagateChangeRight; }
			set { _propagateChangeRight = value; }
		}
		
		// ShouldTranslateRight
		private bool _shouldTranslateRight = true;
		public bool ShouldTranslateRight
		{
			get { return _shouldTranslateRight; }
			set { _shouldTranslateRight = value; }
		}
		
		protected override void DetermineModifiers(Plan plan)
		{
			base.DetermineModifiers(plan);

			if (Modifiers != null)
			{
				PropagateInsertLeft = (PropagateAction)Enum.Parse(typeof(PropagateAction), LanguageModifiers.GetModifier(Modifiers, "Left.PropagateInsert", PropagateInsertLeft.ToString()), true);
				PropagateUpdateLeft = Boolean.Parse(LanguageModifiers.GetModifier(Modifiers, "Left.PropagateUpdate", PropagateUpdateLeft.ToString()));
				PropagateDeleteLeft = Boolean.Parse(LanguageModifiers.GetModifier(Modifiers, "Left.PropagateDelete", PropagateDeleteLeft.ToString()));
				PropagateDefaultLeft = Boolean.Parse(LanguageModifiers.GetModifier(Modifiers, "Left.PropagateDefault", PropagateDefaultLeft.ToString()));
				PropagateValidateLeft = Boolean.Parse(LanguageModifiers.GetModifier(Modifiers, "Left.PropagateValidate", PropagateValidateLeft.ToString()));
				PropagateChangeLeft = Boolean.Parse(LanguageModifiers.GetModifier(Modifiers, "Left.PropagateChange", PropagateChangeLeft.ToString()));
				ShouldTranslateLeft = Boolean.Parse(LanguageModifiers.GetModifier(Modifiers, "Left.ShouldTranslate", ShouldTranslateLeft.ToString()));
				PropagateInsertRight = (PropagateAction)Enum.Parse(typeof(PropagateAction), LanguageModifiers.GetModifier(Modifiers, "Right.PropagateInsert", PropagateInsertRight.ToString()), true);
				PropagateUpdateRight = Boolean.Parse(LanguageModifiers.GetModifier(Modifiers, "Right.PropagateUpdate", PropagateUpdateRight.ToString()));
				PropagateDeleteRight = Boolean.Parse(LanguageModifiers.GetModifier(Modifiers, "Right.PropagateDelete", PropagateDeleteRight.ToString()));
				PropagateDefaultRight = Boolean.Parse(LanguageModifiers.GetModifier(Modifiers, "Right.PropagateDefault", PropagateDefaultRight.ToString()));
				PropagateValidateRight = Boolean.Parse(LanguageModifiers.GetModifier(Modifiers, "Right.PropagateValidate", PropagateValidateRight.ToString()));
				PropagateChangeRight = Boolean.Parse(LanguageModifiers.GetModifier(Modifiers, "Right.PropagateChange", PropagateChangeRight.ToString()));
				ShouldTranslateRight = Boolean.Parse(LanguageModifiers.GetModifier(Modifiers, "Right.ShouldTranslate", ShouldTranslateRight.ToString()));
			}
		}
		
		protected override void InternalClone(PlanNode newNode)
		{
			base.InternalClone(newNode);

			var newBinaryTableNode = (BinaryTableNode)newNode;
			newBinaryTableNode.PropagateInsertLeft = PropagateInsertLeft;
			newBinaryTableNode.PropagateUpdateLeft = PropagateUpdateLeft;
			newBinaryTableNode.PropagateDeleteLeft = PropagateDeleteLeft;
			newBinaryTableNode.PropagateDefaultLeft = PropagateDefaultLeft;
			newBinaryTableNode.PropagateChangeLeft = PropagateChangeLeft;
			newBinaryTableNode.PropagateValidateLeft = PropagateValidateLeft;
			newBinaryTableNode.ShouldTranslateLeft = ShouldTranslateLeft;
			newBinaryTableNode.PropagateInsertRight = PropagateInsertRight;
			newBinaryTableNode.PropagateUpdateRight = PropagateUpdateRight;
			newBinaryTableNode.PropagateDeleteRight = PropagateDeleteRight;
			newBinaryTableNode.PropagateDefaultRight = PropagateDefaultRight;
			newBinaryTableNode.PropagateChangeRight = PropagateChangeRight;
			newBinaryTableNode.PropagateValidateRight = PropagateValidateRight;
			newBinaryTableNode.ShouldTranslateRight = ShouldTranslateRight;
		}
		
		public override void DetermineRemotable(Plan plan)
		{
			Schema.ResultTableVar tableVar = (Schema.ResultTableVar)TableVar;
			tableVar.InferredIsDefaultRemotable = (!PropagateDefaultLeft || LeftTableVar.IsDefaultRemotable) && (!PropagateDefaultRight || RightTableVar.IsDefaultRemotable);
			tableVar.InferredIsChangeRemotable = (!PropagateChangeLeft || LeftTableVar.IsChangeRemotable) && (!PropagateChangeRight || RightTableVar.IsChangeRemotable);
			tableVar.InferredIsValidateRemotable = (!PropagateValidateLeft || LeftTableVar.IsValidateRemotable) && (!PropagateValidateRight || RightTableVar.IsValidateRemotable);
			base.DetermineRemotable(plan);
		}
		
		protected override bool InternalDefault(Program program, IRow oldRow, IRow newRow, BitArray valueFlags, string columnName, bool isDescending)
		{
			return false;
		}
		
		protected override bool InternalChange(Program program, IRow oldRow, IRow newRow, BitArray valueFlags, string columnName)
		{
			return false;
		}
		
		protected override bool InternalValidate(Program program, IRow oldRow, IRow newRow, BitArray valueFlags, string columnName, bool isDescending, bool isProposable)
		{
			return false;
		}
		
		protected override void InternalBeforeInsert(Program program, IRow row, BitArray valueFlags)
		{
		}
		
		protected override void InternalAfterInsert(Program program, IRow row, BitArray valueFlags)
		{
		}
		
		protected override void InternalExecuteInsert(Program program, IRow oldRow, IRow newRow, BitArray valueFlags, bool uncheckedValue)
		{
		}
		
		protected override void InternalBeforeUpdate(Program program, IRow oldRow, IRow newRow, BitArray valueFlags)
		{
		}
		
		protected override void InternalAfterUpdate(Program program, IRow oldRow, IRow newRow, BitArray valueFlags)
		{
		}
		
		protected override void InternalExecuteUpdate(Program program, IRow oldRow, IRow newRow, BitArray valueFlags, bool checkConcurrency, bool uncheckedValue)
		{
		}
		
		protected override void InternalBeforeDelete(Program program, IRow row)
		{
		}
		
		protected override void InternalAfterDelete(Program program, IRow row)
		{
		}
		
		protected override void InternalExecuteDelete(Program program, IRow row, bool checkConcurrency, bool uncheckedValue)
		{
		}
	}
}

